(self.webpackChunksign_detection=self.webpackChunksign_detection||[]).push([[179],{9799:(Lt,ot,Y)=>{"use strict";var P={};Y.r(P),Y.d(P,{CompositeArrayBuffer:()=>Si,browserFiles:()=>xw,browserHTTPRequest:()=>Mv,concatenateArrayBuffers:()=>Wx,copyModel:()=>bv,decodeWeights:()=>Wp,decodeWeightsStream:()=>Gp,encodeWeights:()=>ov,fromMemory:()=>fm,fromMemorySync:()=>Iw,getLoadHandlers:()=>Yx,getModelArtifactsForJSON:()=>Td,getModelArtifactsForJSONSync:()=>qp,getModelArtifactsInfoForJSON:()=>Ua,getSaveHandlers:()=>Xx,getWeightSpecs:()=>Gh,http:()=>af,isHTTPScheme:()=>Pd,listModels:()=>nw,loadWeights:()=>Cw,moveModel:()=>_v,registerLoadRouter:()=>fv,registerSaveRouter:()=>qx,removeModel:()=>Yh,weightsLoaderFactory:()=>Rv,withSaveHandler:()=>Dw,withSaveHandlerSync:()=>pm});var ae={};Y.r(ae),Y.d(ae,{assertParamsValid:()=>Cm,computeFlatOffset:()=>Em,computeOutShape:()=>Ld,getNormalizedAxes:()=>Lv,isSliceContinous:()=>Dc,maskToAxes:()=>Aw,parseSliceParams:()=>Uv,sliceInfo:()=>cf,startForAxis:()=>Vv,startIndicesWithElidedDims:()=>Rw,stopForAxis:()=>Ic,stopIndicesWithElidedDims:()=>Bv,stridesForAxis:()=>Su,stridesWithElidedDims:()=>$v});var Oe={};Y.r(Oe),Y.d(Oe,{conv2d:()=>$1,depthwiseConv2d:()=>eh,matMul:()=>L1});var ve={};Y.r(ve),Y.d(ve,{collectGatherOpShapeInfo:()=>ks,computeOutShape:()=>g_,segOpComputeOptimalWindowSize:()=>ry});var Le={};Y.r(Le),Y.d(Le,{ERF_A1:()=>zg,ERF_A2:()=>ah,ERF_A3:()=>Uc,ERF_A4:()=>Hg,ERF_A5:()=>Wg,ERF_P:()=>ai,PARALLELIZE_THRESHOLD:()=>Lg,RowPartitionType:()=>Bo,SELU_SCALE:()=>ih,SELU_SCALEALPHA:()=>Ug,applyActivation:()=>Hl,assertAndGetBroadcastShape:()=>Nn,assertAxesAreInnerMostDims:()=>_s,assertParamsConsistent:()=>Mg,assignToTypedArray:()=>Gg,axesAreInnerMostDims:()=>Gm,calculateShapes:()=>Pc,checkEinsumDimSizes:()=>qf,checkPadOnDimRoundingMode:()=>Po,combineLocations:()=>f0,combineRaggedTensorToTensorShapes:()=>Og,complexWithEvenIndex:()=>ch,complexWithOddIndex:()=>d_,computeConv2DInfo:()=>Xr,computeConv3DInfo:()=>Ml,computeDefaultPad:()=>Nm,computeDilation2DInfo:()=>uf,computeOptimalWindowSize:()=>jf,computeOutAndReduceShapes:()=>as,computeOutShape:()=>fo,computePool2DInfo:()=>$o,computePool3DInfo:()=>Ka,convertConv2DDataFormat:()=>sn,decodeEinsumEquation:()=>uh,eitherStridesOrDilationsAreOne:()=>Ns,expandShapeToKeepDim:()=>Yr,exponent:()=>Gf,exponents:()=>Kg,fromStringArrayToUint8:()=>y_,fromUint8ToStringArray:()=>po,getAxesPermutation:()=>pr,getBroadcastDims:()=>Ec,getComplexWithIndex:()=>jg,getEinsumComputePath:()=>hh,getEinsumPermutation:()=>dh,getFusedBiasGradient:()=>Bf,getFusedDyActivation:()=>Lf,getImageCenter:()=>u_,getInnerMostAxes:()=>_r,getPermuted:()=>sh,getRaggedRank:()=>$g,getReductionAxes:()=>pw,getReshaped:()=>rh,getReshapedPermuted:()=>oh,getRowPartitionTypesHelper:()=>Fg,getSliceBeginCoords:()=>Bg,getSliceSize:()=>Vg,getSparseFillEmptyRowsIndicesDenseShapeMismatch:()=>f_,getSparseFillEmptyRowsNegativeIndexErrorMessage:()=>p_,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:()=>Xg,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:()=>Zg,getSparseReshapeInputOutputMismatchErrorMessage:()=>Jg,getSparseReshapeInputOutputMultipleErrorMessage:()=>Qg,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:()=>Xf,getSparseReshapeNegativeOutputDimErrorMessage:()=>Yg,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:()=>m_,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:()=>ey,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:()=>ty,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:()=>ny,getUndoAxesPermutation:()=>na,isIdentityPermutation:()=>fh,log:()=>Oa,mergeRealAndImagArrays:()=>Qa,prepareAndValidate:()=>Vc,prepareSplitSize:()=>qg,segment_util:()=>ve,shouldFuse:()=>Vf,slice_util:()=>ae,splitRealAndImagArrays:()=>lh,stridesOrDilationsArePositive:()=>Tc,tupleValuesAreOne:()=>Vd,upcastType:()=>ye,validateDefaultValueShape:()=>Pg,validateInput:()=>mg,validateUpdateShape:()=>xb,warn:()=>Js});var Fe={};Y.r(Fe),Y.d(Fe,{json:()=>Qf});var ct={};Y.r(ct),Y.d(ct,{json:()=>oy});var nt={};Y.r(nt),Y.d(nt,{json:()=>LD});var he={};Y.r(he),Y.d(he,{json:()=>b_});var Ie={};Y.r(Ie),Y.d(Ie,{json:()=>zS});var we={};Y.r(we),Y.d(we,{json:()=>__});var _e={};Y.r(_e),Y.d(_e,{json:()=>Qu});var Ge={};Y.r(Ge),Y.d(Ge,{json:()=>HS});var $e={};Y.r($e),Y.d($e,{json:()=>x_});var ut={};Y.r(ut),Y.d(ut,{json:()=>iy});var vt={};Y.r(vt),Y.d(vt,{json:()=>BD});var bt={};Y.r(bt),Y.d(bt,{json:()=>WS});var Jt={};Y.r(Jt),Y.d(Jt,{json:()=>VD});var Cn={};Y.r(Cn),Y.d(Cn,{json:()=>jS});var Dt={};Y.r(Dt),Y.d(Dt,{json:()=>GS});var at={};Y.r(at),Y.d(at,{json:()=>KS});var Ze={};Y.r(Ze),Y.d(Ze,{json:()=>w_});var Xe={};Y.r(Xe),Y.d(Xe,{json:()=>C_});var Ue={};Y.r(Ue),Y.d(Ue,{json:()=>qS});var ie={};Y.r(ie),Y.d(ie,{OP_SCOPE_SUFFIX:()=>tv,abs:()=>uo,acos:()=>Hv,acosh:()=>Im,add:()=>rn,addN:()=>$w,all:()=>Bd,any:()=>Lw,argMax:()=>Vw,argMin:()=>zw,asin:()=>Eu,asinh:()=>Ww,atan:()=>YI,atan2:()=>Wv,atanh:()=>jv,avgPool:()=>Kv,avgPool3d:()=>Yw,basicLSTMCell:()=>JI,batchNorm:()=>Rm,batchNorm2d:()=>Nu,batchNorm3d:()=>Qv,batchNorm4d:()=>rC,batchToSpaceND:()=>Jw,bincount:()=>e0,bitwiseAnd:()=>oC,booleanMaskAsync:()=>ED,broadcastArgs:()=>aC,broadcastTo:()=>zd,buffer:()=>gn,cast:()=>fr,ceil:()=>r0,clipByValue:()=>tD,clone:()=>kl,complex:()=>ti,concat:()=>zs,concat1d:()=>lC,concat2d:()=>kc,concat3d:()=>o0,concat4d:()=>Ii,conv1d:()=>qa,conv2d:()=>ff,conv2dTranspose:()=>rD,conv3d:()=>sD,conv3dTranspose:()=>Vm,cos:()=>oD,cosh:()=>uC,cosineWindow:()=>vg,cumprod:()=>hC,cumsum:()=>iD,denseBincount:()=>aD,depthToSpace:()=>d0,depthwiseConv2d:()=>Hd,diag:()=>cD,dilation2d:()=>dD,div:()=>Hn,divNoNan:()=>mD,dot:()=>zm,dropout:()=>Mb,einsum:()=>Rc,elu:()=>Wm,enclosingPowerOfTwo:()=>yg,ensureShape:()=>yC,equal:()=>mC,erf:()=>h0,euclideanNorm:()=>gD,exp:()=>Ll,expandDims:()=>ra,expm1:()=>xC,eye:()=>CC,fft:()=>ju,fill:()=>Rd,floor:()=>vf,floorDiv:()=>Ev,fused:()=>Oe,gather:()=>y0,gatherND:()=>$f,greater:()=>bf,greaterEqual:()=>b0,ifft:()=>Qd,imag:()=>_f,image:()=>nh,inTopKAsync:()=>Fb,irfft:()=>Rf,isFinite:()=>x0,isInf:()=>DC,isNaN:()=>Xm,leakyRelu:()=>C0,less:()=>xf,lessEqual:()=>Ym,linalg:()=>AS,linspace:()=>kC,localResponseNormalization:()=>AC,log:()=>Bl,log1p:()=>Wd,logSigmoid:()=>E0,logSoftmax:()=>eg,logSumExp:()=>jd,logicalAnd:()=>Vl,logicalNot:()=>Cf,logicalOr:()=>T0,logicalXor:()=>Gd,losses:()=>RS,lowerBound:()=>xD,matMul:()=>Yn,max:()=>Pl,maxPool:()=>N0,maxPool3d:()=>k0,maxPoolWithArgmax:()=>PC,maximum:()=>nf,mean:()=>Ef,meshgrid:()=>LC,min:()=>yf,minimum:()=>If,mirrorPad:()=>Fc,mod:()=>Kd,moments:()=>UC,movingAverage:()=>on,mul:()=>Nt,multiRNNCell:()=>zC,multinomial:()=>qd,neg:()=>si,norm:()=>Au,notEqual:()=>Ul,oneHot:()=>oi,ones:()=>Oc,onesLike:()=>Mu,op:()=>de,outerProduct:()=>Fu,pad:()=>ia,pad1d:()=>Lu,pad2d:()=>Vu,pad3d:()=>M0,pad4d:()=>F0,pool:()=>HC,pow:()=>Md,prelu:()=>V0,print:()=>rm,prod:()=>GC,raggedGather:()=>ag,raggedRange:()=>Nf,raggedTensorToTensor:()=>lg,rand:()=>cg,randomGamma:()=>W0,randomNormal:()=>j0,randomStandardNormal:()=>t1,randomUniform:()=>Yd,randomUniformInt:()=>q0,range:()=>zu,real:()=>Hu,reciprocal:()=>Z0,relu:()=>dg,relu6:()=>J0,reshape:()=>tt,reverse:()=>$c,reverse1d:()=>tb,reverse2d:()=>s1,reverse3d:()=>o1,reverse4d:()=>sb,rfft:()=>Mf,round:()=>ob,rsqrt:()=>ib,scalar:()=>xn,scatterND:()=>A1,searchSorted:()=>tg,selu:()=>ab,separableConv2d:()=>lb,setdiff1dAsync:()=>c1,sigmoid:()=>Ol,sign:()=>aa,signal:()=>kS,sin:()=>Ti,sinh:()=>db,slice:()=>Pn,slice1d:()=>h1,slice2d:()=>p1,slice3d:()=>Zd,slice4d:()=>hb,softmax:()=>fb,softplus:()=>Jm,spaceToBatchND:()=>og,sparse:()=>MS,sparseToDense:()=>M1,spectral:()=>NS,split:()=>Gu,sqrt:()=>ta,square:()=>Fo,squaredDifference:()=>pg,squeeze:()=>Ku,stack:()=>Ya,step:()=>_b,stridedSlice:()=>_1,string:()=>OS,sub:()=>fn,sum:()=>Zn,tan:()=>w1,tanh:()=>Ud,tensor:()=>Va,tensor1d:()=>ho,tensor2d:()=>qu,tensor3d:()=>mm,tensor4d:()=>C1,tensor5d:()=>S1,tensor6d:()=>E1,tensorScatterUpdate:()=>D1,tile:()=>Ru,topk:()=>wb,transpose:()=>Of,truncatedNormal:()=>Sb,unique:()=>Ib,unsortedSegmentSum:()=>Tb,unstack:()=>zl,upperBound:()=>kb,variable:()=>Ab,where:()=>Ac,whereAsync:()=>Lc,zeros:()=>Mc,zerosLike:()=>co});var X={};Y.r(X),Y.d(X,{addImpl:()=>OT,bincountImpl:()=>OE,bincountReduceImpl:()=>FT,bitwiseAndImpl:()=>$T,castImpl:()=>MT,ceilImpl:()=>PT,concatImpl:()=>LT,equalImpl:()=>BT,expImpl:()=>UT,expm1Impl:()=>HT,floorDivImpl:()=>jT,floorImpl:()=>WT,gatherNdImpl:()=>GT,gatherV2Impl:()=>KT,greaterEqualImpl:()=>XT,greaterImpl:()=>qT,lessEqualImpl:()=>ZT,lessImpl:()=>YT,linSpaceImpl:()=>QT,logImpl:()=>JT,maxImpl:()=>eN,maximumImpl:()=>tN,minimumImpl:()=>nN,multiplyImpl:()=>FE,negImpl:()=>rN,notEqualImpl:()=>sN,prodImpl:()=>oN,raggedGatherImpl:()=>aN,raggedRangeImpl:()=>cN,raggedTensorToTensorImpl:()=>hN,rangeImpl:()=>fN,rsqrtImpl:()=>pN,scatterImpl:()=>Sh,sigmoidImpl:()=>CM,simpleAbsImpl:()=>RT,sliceImpl:()=>gN,sparseFillEmptyRowsImpl:()=>yN,sparseReshapeImpl:()=>vN,sparseSegmentReductionImpl:()=>PE,sqrtImpl:()=>IM,squaredDifferenceImpl:()=>bN,staticRegexReplaceImpl:()=>_N,stridedSliceImpl:()=>xN,stringNGramsImpl:()=>wN,stringSplitImpl:()=>CN,stringToHashBucketFastImpl:()=>SN,subImpl:()=>EN,tileImpl:()=>IN,topKImpl:()=>TN,transposeImpl:()=>$E,uniqueImpl:()=>NN});var ze=Y(2313),K=Y(1223),_t=Y(6210);const Ot=[{path:"home",loadChildren:()=>Y.e(828).then(Y.bind(Y,3828)).then(n=>n.HomeModule)},{path:"about",loadChildren:()=>Y.e(10).then(Y.bind(Y,7010)).then(n=>n.AboutModule)},{path:"",pathMatch:"full",redirectTo:"home"}];let dt=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=K.oAB({type:n}),n.\u0275inj=K.cJS({imports:[_t.Bz.forRoot(Ot),_t.Bz]}),n})();function qe(n,t,e,r,s,o,l){try{var u=n[o](l),d=u.value}catch(h){return void e(h)}u.done?t(d):Promise.resolve(d).then(r,s)}function xe(n){return function(){var t=this,e=arguments;return new Promise(function(r,s){var o=n.apply(t,e);function l(d){qe(o,r,s,l,u,"next",d)}function u(d){qe(o,r,s,l,u,"throw",d)}l(void 0)})}}class ce{constructor(t,e){this.backend=t,this.dataMover=e,this.data=new WeakMap,this.dataIdsCount=0}get(t){return this.data.has(t)||this.dataMover.moveData(this.backend,t),this.data.get(t)}set(t,e){this.dataIdsCount++,this.data.set(t,e)}has(t){return this.data.has(t)}delete(t){return this.dataIdsCount--,this.data.delete(t)}numDataIds(){return this.dataIdsCount}}class ue{refCount(t){return me("refCount")}incRef(t){return me("incRef")}timerAvailable(){return!0}time(t){return me("time")}read(t){return me("read")}readSync(t){return me("readSync")}readToGPU(t,e){return me("readToGPU")}numDataIds(){return me("numDataIds")}disposeData(t,e){return me("disposeData")}write(t,e,r){return me("write")}move(t,e,r,s,o){return me("move")}createTensorFromGPUData(t,e,r){return me("createTensorFromGPUData")}memory(){return me("memory")}floatPrecision(){return me("floatPrecision")}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}dispose(){return me("dispose")}}function me(n){throw new Error(`'${n}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}function Ve(n,t,e){return Math.max(n,Math.min(t,e))}function xt(n){return n%2==0?n:n+1}function Pt(n,t,e){const r=n[t];n[t]=n[e],n[e]=r}function G(n,t){if(!n)throw new Error("string"==typeof t?t:t())}function bn(n,t,e=""){G(un(n,t),()=>e+` Shapes ${n} and ${t} must match`)}function Bt(n){G(null!=n,()=>"The input to the tensor constructor must be a non-null value.")}function Ee(n){if(0===n.length)return 1;let t=n[0];for(let e=1;e<n.length;e++)t*=n[e];return t}function un(n,t){if(n===t)return!0;if(null==n||null==t||n.length!==t.length)return!1;for(let e=0;e<n.length;e++)if(n[e]!==t[e])return!1;return!0}function kn(n){return n%1==0}function wr(n){const t=Math.ceil(Math.sqrt(n));return[t,Math.ceil(n/t)]}function vr(n,t){return t<=n.length?n:n+" ".repeat(t-n.length)}function $r(n,t=(s=>0),e,r){return new Promise((s,o)=>{let l=0;const u=()=>{if(n())return void s();l++;const d=t(l);null!=e&&l>=e?o():null!=r?r(u,d):setTimeout(u,d)};u()})}function Dr(n,t){let e=1,r=-1;for(let o=0;o<n.length;++o)if(n[o]>=0)e*=n[o];else if(-1===n[o]){if(-1!==r)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${r} and dim ${o}`);r=o}else if(n[o]<0)throw Error(`Shapes can not be < 0. Found ${n[o]} at dim ${o}`);if(-1===r){if(t>0&&t!==e)throw Error(`Size(${t}) must match the product of shape ${n}`);return n}if(0===e)throw Error(`Cannot infer the missing size in [${n}] when there are 0 elements`);if(t%e!=0)throw Error(`The implicit shape can't be a fractional number. Got ${t} / ${e}`);const s=n.slice();return s[r]=t/e,s}function Tt(n,t){const e=t.length;return G((n=null==n?t.map((r,s)=>s):[].concat(n)).every(r=>r>=-e&&r<e),()=>`All values in axis param must be in range [-${e}, ${e}) but got axis ${n}`),G(n.every(r=>kn(r)),()=>`All values in axis param must be integers but got axis ${n}`),n.map(r=>r<0?e+r:r)}function St(n,t){const e=[],r=[],s=null!=t&&Array.isArray(t)&&0===t.length,o=null==t||s?null:Tt(t,n).sort();let l=0;for(let u=0;u<n.length;++u){if(null!=o){if(o[l]===u&&1!==n[u])throw new Error(`Can't squeeze axis ${u} since its dim '${n[u]}' is not 1`);(null==o[l]||o[l]>u)&&1===n[u]&&(e.push(n[u]),r.push(u)),o[l]<=u&&l++}1!==n[u]&&(e.push(n[u]),r.push(u))}return{newShape:e,keptDims:r}}function Rt(n,t){return Ft(n,t)}function Ft(n,t){let e=null;if(null==n||"float32"===n)e=new Float32Array(t);else if("int32"===n)e=new Int32Array(t);else if("bool"===n)e=new Uint8Array(t);else{if("string"!==n)throw new Error(`Unknown data type ${n}`);e=new Array(t)}return e}function An(n,t){return!("complex64"===t||"float32"===t&&"complex64"!==n||"int32"===t&&"float32"!==n&&"complex64"!==n||"bool"===t&&"bool"===n)}function Cr(n){if("float32"===n||"int32"===n)return 4;if("complex64"===n)return 8;if("bool"===n)return 1;throw new Error(`Unknown dtype ${n}`)}function bo(n){return"string"==typeof n||n instanceof String}function Zt(n){return Array.isArray(n)?Zt(n[0]):n instanceof Float32Array?"float32":n instanceof Int32Array||n instanceof Uint8Array||n instanceof Uint8ClampedArray?"int32":function zn(n){return"number"==typeof n}(n)?"float32":bo(n)?"string":function dr(n){return"boolean"==typeof n}(n)?"bool":"float32"}function ga(n){return!!(n&&n.constructor&&n.call&&n.apply)}function di(n,t){for(let e=t;e<n;++e)if(n%e==0)return e;return n}function Wt(n){const t=n.length;if(t<2)return[];const e=new Array(t-1);e[t-2]=n[t-1];for(let r=t-3;r>=0;--r)e[r]=e[r+1]*n[r+1];return e}function Sn(n,t,e,r=!1){const s=new Array;if(1===t.length){const o=t[0]*(r?2:1);for(let l=0;l<o;l++)s[l]=e[n+l]}else{const o=t[0],l=t.slice(1),u=l.reduce((d,h)=>d*h)*(r?2:1);for(let d=0;d<o;d++)s[d]=Sn(n+d*u,l,e,r)}return s}function Pr(n,t,e=!1){if(0===n.length)return t[0];const r=n.reduce((s,o)=>s*o)*(e?2:1);if(0===r)return[];if(r!==t.length)throw new Error(`[${n}] does not match the input size ${t.length}${e?" for a complex tensor":""}.`);return Sn(0,n,t,e)}function _o(n,t){const e=er(n,t);for(let r=0;r<e.length;r++)e[r]=1;return e}function er(n,t){if(null==t||"float32"===t||"complex64"===t)return new Float32Array(n);if("int32"===t)return new Int32Array(n);if("bool"===t)return new Uint8Array(n);throw new Error(`Unknown data type ${t}`)}function ds(n,t){const e=n.reduce((r,s)=>r*s,1);if(null==t||"float32"===t)return Pr(n,new Float32Array(e));if("int32"===t)return Pr(n,new Int32Array(e));if("bool"===t)return Pr(n,new Uint8Array(e));throw new Error(`Unknown data type ${t}`)}function Sr(n){n.forEach(t=>{G(Number.isInteger(t)&&t>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${n}].`)})}function Qr(n,t,e){if(0===t)return 0;if(1===t)return n[0];let r=n[n.length-1];for(let s=0;s<n.length-1;++s)r+=e[s]*n[s];return r}function Jr(n,t,e){if(0===t)return[];if(1===t)return[n];const r=new Array(t);for(let s=0;s<r.length-1;++s)r[s]=Math.floor(n/e[s]),n-=r[s]*e[s];return r[r.length-1]=n,r}function dn(n){return n&&n.then&&"function"==typeof n.then}const Uo="tfjsflags";class Ql{constructor(t){this.global=t,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=Gs,this.populateURLFlags()}setPlatform(t,e){null!=this.platform&&(Q().getBool("IS_TEST")||Q().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${t}.`)),this.platformName=t,this.platform=e}registerFlag(t,e,r){if(this.flagRegistry[t]={evaluationFn:e,setHook:r},null!=this.urlFlags[t]){const s=this.urlFlags[t];Q().getBool("IS_TEST")||Q().getBool("PROD")||console.warn(`Setting feature override from URL ${t}: ${s}.`),this.set(t,s)}}getAsync(t){var e=this;return xe(function*(){return t in e.flags||(e.flags[t]=yield e.evaluateFlag(t)),e.flags[t]})()}get(t){if(t in this.flags)return this.flags[t];const e=this.evaluateFlag(t);if(dn(e))throw new Error(`Flag ${t} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[t]=e,this.flags[t]}getNumber(t){return this.get(t)}getBool(t){return this.get(t)}getString(t){return this.get(t)}getFlags(){return this.flags}get features(){return this.flags}set(t,e){if(null==this.flagRegistry[t])throw new Error(`Cannot set flag ${t} as it has not been registered.`);this.flags[t]=e,null!=this.flagRegistry[t].setHook&&this.flagRegistry[t].setHook(e)}evaluateFlag(t){if(null==this.flagRegistry[t])throw new Error(`Cannot evaluate flag '${t}': no evaluation function found.`);return this.flagRegistry[t].evaluationFn()}setFlags(t){this.flags=Object.assign({},t)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(void 0===this.global||void 0===this.global.location||void 0===this.global.location.search)return;const t=this.getQueryParams(this.global.location.search);Uo in t&&t[Uo].split(",").forEach(r=>{const[s,o]=r.split(":");this.urlFlags[s]=function va(n,t){const e=t.toLowerCase();return"true"===e||"false"===e?"true"===e:""+ +e===e?+e:t}(0,o)})}}function Gs(n){const t={};return n.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(e,...r)=>(function Jl(n,t,e){n[decodeURIComponent(t)]=decodeURIComponent(e||"")}(t,r[0],r[1]),r.join("="))),t}function Q(){return ge}let Re,ge=null;function Je(){if(null==Re){let n;if("undefined"!=typeof window)n=window;else if("undefined"!=typeof global)n=global;else if("undefined"!=typeof process)n=process;else{if("undefined"==typeof self)throw new Error("Could not find a global object");n=self}Re=n}return Re}function nn(n,t){const e=function Qt(){const n=Je();return null==n._tfGlobals&&(n._tfGlobals=new Map),n._tfGlobals}();if(e.has(n))return e.get(n);{const r=t();return e.set(n,r),e.get(n)}}const lr="Acos",As="Acosh",Rs="Add",Ks="AddN",Lr="ArgMax",kt="ArgMin",an="Asin",Bn="Asinh",Wr="Atan",xo="Atanh",tr="Atan2",Ms="AvgPool",nr="AvgPoolGrad",hs="AvgPool3D",wo="AvgPool3DGrad",mn="BatchMatMul",Fi="BatchToSpaceND",Co="Bincount",$i="BitwiseAnd",cr="BroadcastArgs",fs="Cast",Os="Ceil",Br="ClipByValue",So="Complex",Eo="ComplexAbs",Vn="Concat",sl="Conv2D",ol="Conv2DBackpropFilter",jr="Conv2DBackpropInput",es="Conv3D",hi="Conv3DBackpropFilterV2",Gr="Conv3DBackpropInputV2",Io="Cos",ps="Cosh",il="Cumprod",tc="Cumsum",qs="CropAndResize",ba="DenseBincount",zo="DepthToSpace",_a="DepthwiseConv2dNative",nc="DepthwiseConv2dNativeBackpropFilter",Xc="DepthwiseConv2dNativeBackpropInput",Yc="Diag",Zc="Dilation2D",fd="Dilation2DBackpropInput",pd="Dilation2DBackpropFilter",rc="RealDiv",Jc="Einsum",al="Elu",md="EluGrad",sc="Erf",Pi="Equal",Ho="Exp",xa="ExpandDims",wa="Expm1",Vr="Fill",Do="FlipLeftRight",fi="Floor",Li="FloorDiv",ic="FusedBatchNorm",To="GatherV2",ll="GatherNd",cl="Greater",Bi="GreaterEqual",Vi="Identity",Ca="IFFT",ts="Imag",No="IsFinite",Ui="IsInf",Sa="IsNan",pi="LeakyRelu",eu="Less",jn="LessEqual",ul="LinSpace",dl="Log",Wo="Log1p",Ur="LogicalAnd",jo="LogicalNot",zi="LogicalOr",tu="LRNGrad",Da="Maximum",hn="MaxPool",nu="MaxPoolGrad",yd="MaxPool3D",hl="MaxPool3DGrad",ac="MaxPoolWithArgmax",ru="Mean",Hi="Minimum",ms="MirrorPad",st="Mod",_n="Multinomial",pl="Multiply",ur="NotEqual",Wi="NonMaxSuppressionV3",ji="NonMaxSuppressionV4",Xs="NonMaxSuppressionV5",Ao="OnesLike",Go="OneHot",su="Pack",ou="PadV2",Ko="Pow",Nr="Prelu",Ys="Prod",ml="RaggedGather",so="RaggedRange",rs="RaggedTensorToTensor",au="Range",lu="Real",Ta="Reciprocal",mi="Relu",gi="Reshape",Ro="ResizeNearestNeighbor",lc="ResizeNearestNeighborGrad",Gi="ResizeBilinear",vd="ResizeBilinearGrad",gl="Relu6",yl="Reverse",vl="Round",bl="Rsqrt",cc="ScatterNd",uc="TensorScatterUpdate",Na="SearchSorted",cu="Select",ka="Selu",kr="Slice",$s="Sin",Fn="Sinh",Aa="Sign",dc="Sigmoid",_l="Softplus",hc="Sqrt",fc="SpaceToBatchND",Ki="SplitV",qo="Softmax",Xo="SparseFillEmptyRows",Ma="SparseReshape",yi="SparseSegmentMean",k="SparseSegmentSum",B="SparseToDense",M="SquaredDifference",H="Square",oe="StaticRegexReplace",Pe="StridedSlice",Ye="StringNGrams",Ht="StringSplit",Dn="StringToHashBucketFast",Tn="Sub",Rn="Tan",yn="Tanh",sr="Tile",$n="TopK",or="Transform",Ps="Transpose",gs="Unique",ss="Unpack",Zs="UnsortedSegmentSum",Yo="ZerosLike",Zo="Step",$h="FromPixels",uu="RotateWithOffset",pc="_FusedMatMul",du="FusedConv2D",Qs="FusedDepthwiseConv2D";function Js(...n){Q().getBool("IS_TEST")||Q().getBool("PROD")||console.warn(...n)}function Oa(...n){Q().getBool("IS_TEST")||Q().getBool("PROD")||console.log(...n)}const vi=nn("kernelRegistry",()=>new Map),qi=nn("gradRegistry",()=>new Map);function xl(n,t){const e=Xi(n,t);return vi.get(e)}function mc(n){return qi.get(n)}function bd(n){const t=vi.entries(),e=[];for(;;){const{done:r,value:s}=t.next();if(r)break;const[o,l]=s,[u]=o.split("_");u===n&&e.push(l)}return e}function hu(n){const{kernelName:t,backendName:e}=n,r=Xi(t,e);vi.has(r)&&Js(`The kernel '${t}' for backend '${e}' is already registered`),vi.set(r,n)}function Xi(n,t){return`${t}_${n}`}function wl(n){return n instanceof Float32Array||n instanceof Int32Array||n instanceof Uint8Array||n instanceof Uint8ClampedArray}var Bh=Y(2333);const Yi=Y.n(Bh)()||Bh;function bi(n){return Yi.fromString(n,!0,16)}const Vh=bi("c3a5c85c97cb3127"),Fa=bi("b492b66fbe98f273"),Kr=bi("9ae16a3b2f90404f");function pu(n){return n.xor(n.shru(47))}function Ar(n,t,e){const r=n.slice(t,t+e);return Yi.fromBytes(Array.from(r),!0,!0)}function Un(n,t){return Ar(n,t,8)}function Zi(n,t){return Ar(n,t,4)}function Xn(n,t){return 0===t?n:n.shru(t).or(n.shl(64-t))}function Is(n,t,e=bi("9ddfea08eb382d69")){let r=n.xor(t).mul(e);r=r.xor(r.shru(47));let s=t.xor(r).mul(e);return s=s.xor(s.shru(47)),s=s.mul(e),s}function Cl(n,t,e,r){return function Uh(n,t,e,r,s,o){s=s.add(n),o=Xn(o.add(s).add(r),21);const l=s;return s=(s=s.add(t)).add(e),o=o.add(Xn(s,44)),[s.add(r),o.add(l)]}(Un(n,t),Un(n,t+8),Un(n,t+16),Un(n,t+24),e,r)}function Gn(n,t=n.length){const e=Yi.fromNumber(81,!0);if(t<=32)return t<=16?function $a(n,t=n.length){if(t>=8){const e=Kr.add(2*t),r=Un(n,0).add(Kr),s=Un(n,t-8);return Is(Xn(s,37).mul(e).add(r),Xn(r,25).add(s).mul(e),e)}if(t>=4){const e=Kr.add(2*t);return Is(Zi(n,0).shl(3).add(t),Zi(n,t-4),e)}if(t>0){const l=t+(n[t-1]<<2);return pu(Kr.mul(n[0]+(n[t>>1]<<8)).xor(Vh.mul(l))).mul(Kr)}return Kr}(n,t):function $x(n,t=n.length){const e=Kr.add(2*t),r=Un(n,0).mul(Fa),s=Un(n,8),o=Un(n,t-8).mul(e),l=Un(n,t-16).mul(Kr);return Is(Xn(r.add(s),43).add(Xn(o,30)).add(l),r.add(Xn(s.add(Kr),18)).add(o),e)}(n,t);if(t<=64)return function Zy(n,t=n.length){const e=Kr.add(2*t),r=Un(n,0).mul(Kr),s=Un(n,8),o=Un(n,t-8).mul(e),l=Un(n,t-16).mul(Kr),u=Xn(r.add(s),43).add(Xn(o,30)).add(l),d=Is(u,r.add(Xn(s.add(Kr),18)).add(o),e),h=Un(n,16).mul(e),p=Un(n,24),g=u.add(Un(n,t-32)).mul(e),y=d.add(Un(n,t-24)).mul(e);return Is(Xn(h.add(p),43).add(Xn(g,30)).add(y),h.add(Xn(p.add(r),18)).add(g),e)}(n,t);let r=e,s=e.mul(Fa).add(113),o=pu(s.mul(Kr).add(113)).mul(Kr),l=[Yi.UZERO,Yi.UZERO],u=[Yi.UZERO,Yi.UZERO];r=r.mul(Kr).add(Un(n,0));let d=0;const h=64*(t-1>>6),p=h+(t-1&63)-63;do{r=Xn(r.add(s).add(l[0]).add(Un(n,d+8)),37).mul(Fa),s=Xn(s.add(l[1]).add(Un(n,d+48)),42).mul(Fa),r=r.xor(u[1]),s=s.add(l[0]).add(Un(n,d+40)),o=Xn(o.add(u[0]),33).mul(Fa),l=Cl(n,d,l[1].mul(Fa),r.add(u[0])),u=Cl(n,d+32,o.add(u[1]),s.add(Un(n,d+16))),[o,r]=[r,o],d+=64}while(d!==h);const g=Fa.add(o.and(255).shl(1));return d=p,u[0]=u[0].add(t-1&63),l[0]=l[0].add(u[0]),u[0]=u[0].add(l[0]),r=Xn(r.add(s).add(l[0]).add(Un(n,d+8)),37).mul(g),s=Xn(s.add(l[1]).add(Un(n,d+48)),42).mul(g),r=r.xor(u[1].mul(9)),s=s.add(l[0].mul(9).add(Un(n,d+40))),o=Xn(o.add(u[0]),33).mul(g),l=Cl(n,d,l[1].mul(g),r.add(u[0])),u=Cl(n,d+32,o.add(u[1]),s.add(Un(n,d+16))),[o,r]=[r,o],Is(Is(l[0],u[0],g).add(pu(s).mul(Vh)).add(o),Is(l[1],u[1],g).add(r),g)}function _i(n,t){return"string"===t?oo(n):xi([n],t)}function xi(n,t){if("string"===t)throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(n)&&(n=Pa(n)),Q().getBool("DEBUG")&&function Kn(n,t){for(let e=0;e<n.length;e++){const r=n[e];if(isNaN(r)||!isFinite(r))throw Error(`A tensor of type ${t} being uploaded contains ${r}.`)}}(n,t),function Lp(n,t){return n instanceof Float32Array&&"float32"===t||n instanceof Int32Array&&"int32"===t||n instanceof Uint8Array&&"bool"===t}(n,t))return n;if(null==t||"float32"===t||"complex64"===t)return new Float32Array(n);if("int32"===t)return new Int32Array(n);if("bool"===t){const e=new Uint8Array(n.length);for(let r=0;r<e.length;++r)0!==Math.round(n[r])&&(e[r]=1);return e}throw new Error(`Unknown data type ${t}`)}function Oo(){return Q().platform.now()}function Bp(n,t){return Q().platform.fetch(n,t)}function oo(n,t="utf-8"){return t=t||"utf-8",Q().platform.encode(n,t)}function wi(n,t="utf-8"){return t=t||"utf-8",Q().platform.decode(n,t)}function Ds(n){return null!=Q().platform.isTypedArray?Q().platform.isTypedArray(n):wl(n)}function Pa(n,t=[],e=!1){if(null==t&&(t=[]),"boolean"==typeof n||"number"==typeof n||"string"==typeof n||dn(n)||null==n||Ds(n)&&e)t.push(n);else if(Array.isArray(n)||Ds(n))for(let r=0;r<n.length;++r)Pa(n[r],t,e);else{let r=-1;for(const s of Object.keys(n))/^([1-9]+[0-9]*|0)$/.test(s)&&(r=Math.max(r,Number(s)));for(let s=0;s<=r;s++)Pa(n[s],t,e)}return t}class Vp{constructor(t,e){this.backendTimer=t,this.logger=e,null==e&&(this.logger=new _d)}profileKernel(t,e,r){let s;const o=()=>{s=r()};let l;const u=Oo();if(this.backendTimer.timerAvailable())l=this.backendTimer.time(o);else{o();for(const h of s)h.dataSync();l=Promise.resolve({kernelMs:Oo()-u})}if(Q().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let h=0;h<s.length;h++){const p=s[h];p.data().then(g=>{Er(g,p.dtype,t)})}return{kernelName:t,outputs:s,inputs:e,timeMs:l.then(h=>h.kernelMs),extraInfo:l.then(h=>null!=h.getExtraProfileInfo?h.getExtraProfileInfo():"")}}logKernelProfile(t){const{kernelName:e,outputs:r,timeMs:s,inputs:o,extraInfo:l}=t;r.forEach(u=>{Promise.all([u.data(),s,l]).then(d=>{this.logger.logKernelProfile(e,u,d[0],d[1],o,d[2])})})}}function Er(n,t,e){if("float32"!==t)return!1;for(let r=0;r<n.length;r++){const s=n[r];if(isNaN(s)||!isFinite(s))return console.warn(`Found ${s} in the result of '${e}'`),!0}return!1}class _d{logKernelProfile(t,e,r,s,o,l){const u="number"==typeof s?vr(`${s}ms`,9):s.error,d=vr(t,25),h=e.rank,p=e.size,g=vr(e.shape.toString(),14);let y="";for(const b in o){const _=o[b];if(null!=_){const I=_.shape||e.shape,S=I.length;y+=`${b}: ${S}D ${S>0?I:""} `}}console.log(`%c${d}\t%c${u}\t%c${h}D ${g}\t%c${p}\t%c${y}\t%c${l}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}function vc(n,t,e,r){const s=Wt(t),o=function wd(n,t,e,r){const s=Ee(t),o=r[r.length-1],l=new Array(o).fill(0),u=t.length,d="complex64"===e?bc(n):n;if(u>1)for(let h=0;h<s/o;h++){const p=h*o;for(let g=0;g<o;g++)l[g]=Math.max(l[g],Jo(d[p+g],0,e).length)}return l}(n,t,e,s),l=t.length,u=mu(n,t,e,s,o),d=["Tensor"];return r&&(d.push(`  dtype: ${e}`),d.push(`  rank: ${l}`),d.push(`  shape: [${t}]`),d.push("  values:")),d.push(u.map(h=>"    "+h).join("\n")),d.join("\n")}function Jo(n,t,e){let r;return r=Array.isArray(n)?`${parseFloat(n[0].toFixed(7))} + ${parseFloat(n[1].toFixed(7))}j`:bo(n)?`'${n}'`:"bool"===e?Cd(n):parseFloat(n.toFixed(7)).toString(),vr(r,t)}function Cd(n){return 0===n?"false":"true"}function mu(n,t,e,r,s,o=!0){const l="complex64"===e?2:1,u=t[0],d=t.length;if(0===d)return"complex64"===e?[Jo(bc(n)[0],0,e)]:"bool"===e?[Cd(n[0])]:[n[0].toString()];if(1===d){if(u>20){let T=Array.from(n.slice(0,3*l)),O=Array.from(n.slice((u-3)*l,u*l));return"complex64"===e&&(T=bc(T),O=bc(O)),["["+T.map((V,U)=>Jo(V,s[U],e)).join(", ")+", ..., "+O.map((V,U)=>Jo(V,s[u-3+U],e)).join(", ")+"]"]}return["["+("complex64"===e?bc(n):Array.from(n)).map((S,T)=>Jo(S,s[T],e)).join(", ")+"]"]}const h=t.slice(1),p=r.slice(1),g=r[0]*l,y=[];if(u>20){for(let I=0;I<3;I++){const S=I*g;y.push(...mu(n.slice(S,S+g),h,e,p,s,!1))}y.push("...");for(let I=u-3;I<u;I++){const S=I*g;y.push(...mu(n.slice(S,S+g),h,e,p,s,I===u-1))}}else for(let I=0;I<u;I++){const S=I*g;y.push(...mu(n.slice(S,S+g),h,e,p,s,I===u-1))}const b=2===d?",":"";y[0]="["+(u>0?y[0]+b:"");for(let I=1;I<y.length-1;I++)y[I]=" "+y[I]+b;let _=",\n";for(let I=2;I<d;I++)_+="\n";return y[y.length-1]=" "+y[y.length-1]+"]"+(o?"":_),y}function bc(n){const t=[];for(let e=0;e<n.length;e+=2)t.push([n[e],n[e+1]]);return t}class zr{constructor(t,e,r){if(this.dtype=e,this.shape=t.slice(),this.size=Ee(t),null!=r){const s=r.length;G(s===this.size,()=>`Length of values '${s}' does not match the size inferred by the shape '${this.size}'.`)}if("complex64"===e)throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=r||Ft(e,this.size),this.strides=Wt(t)}set(t,...e){0===e.length&&(e=[0]),G(e.length===this.rank,()=>`The number of provided coordinates (${e.length}) must match the rank (${this.rank})`);const r=this.locToIndex(e);this.values[r]=t}get(...t){0===t.length&&(t=[0]);let e=0;for(const s of t){if(s<0||s>=this.shape[e])throw new Error(`Requested out of range element at ${t}.   Buffer shape=${this.shape}`);e++}let r=t[t.length-1];for(let s=0;s<t.length-1;++s)r+=this.strides[s]*t[s];return this.values[r]}locToIndex(t){if(0===this.rank)return 0;if(1===this.rank)return t[0];let e=t[t.length-1];for(let r=0;r<t.length-1;++r)e+=this.strides[r]*t[r];return e}indexToLoc(t){if(0===this.rank)return[];if(1===this.rank)return[t];const e=new Array(this.shape.length);for(let r=0;r<e.length-1;++r)e[r]=Math.floor(t/this.strides[r]),t-=e[r]*this.strides[r];return e[e.length-1]=t,e}get rank(){return this.shape.length}toTensor(){return ei().makeTensor(this.values,this.shape,this.dtype)}}let ei=null,La=null,Ls=null;class Rr{constructor(t,e,r,s){this.kept=!1,this.isDisposedInternal=!1,this.shape=t.slice(),this.dtype=e||"float32",this.size=Ee(t),this.strides=Wt(t),this.dataId=r,this.id=s,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}buffer(){var t=this;return xe(function*(){const e=yield t.data();return La.buffer(t.shape,t.dtype,e)})()}bufferSync(){return La.buffer(this.shape,this.dtype,this.dataSync())}array(){var t=this;return xe(function*(){const e=yield t.data();return Pr(t.shape,e,"complex64"===t.dtype)})()}arraySync(){return Pr(this.shape,this.dataSync(),"complex64"===this.dtype)}data(){var t=this;return xe(function*(){t.throwIfDisposed();const e=ei().read(t.dataId);if("string"===t.dtype){const r=yield e;try{return r.map(s=>wi(s))}catch(s){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e})()}dataToGPU(t){return this.throwIfDisposed(),ei().readToGPU(this.dataId,t)}dataSync(){this.throwIfDisposed();const t=ei().readSync(this.dataId);if("string"===this.dtype)try{return t.map(e=>wi(e))}catch(e){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return t}bytes(){var t=this;return xe(function*(){t.throwIfDisposed();const e=yield ei().read(t.dataId);return"string"===t.dtype?e:new Uint8Array(e.buffer)})()}dispose(){this.isDisposed||(this.kerasMask&&this.kerasMask.dispose(),ei().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(t=!1){return La.print(this,t)}clone(){return this.throwIfDisposed(),La.clone(this)}toString(t=!1){return vc(this.dataSync(),this.shape,this.dtype,t)}cast(t){return this.throwIfDisposed(),La.cast(this,t)}variable(t=!0,e,r){return this.throwIfDisposed(),ei().makeVariable(this,t,e,r)}}function C(){return nn("Tensor",()=>Rr)}Object.defineProperty(Rr,Symbol.hasInstance,{value:n=>!!n&&null!=n.data&&null!=n.dataSync&&null!=n.throwIfDisposed}),C();class E extends Rr{constructor(t,e,r,s){super(t.shape,t.dtype,t.dataId,s),this.trainable=e,this.name=r}assign(t){if(t.dtype!==this.dtype)throw new Error(`dtype of the new value (${t.dtype}) and previous value (${this.dtype}) must match`);if(!un(t.shape,this.shape))throw new Error(`shape of the new value (${t.shape}) and previous value (${this.shape}) must match`);ei().disposeTensor(this),this.dataId=t.dataId,ei().incRef(this,null)}dispose(){ei().disposeVariable(this),this.isDisposedInternal=!0}}Object.defineProperty(E,Symbol.hasInstance,{value:n=>n instanceof Rr&&null!=n.assign&&n.assign instanceof Function});var N=(()=>{return(n=N||(N={})).float32="float32",n.int32="int32",n.bool="int32",n.complex64="complex64",N;var n})(),F=(()=>{return(n=F||(F={})).float32="float32",n.int32="int32",n.bool="bool",n.complex64="complex64",F;var n})(),z=(()=>{return(n=z||(z={})).float32="float32",n.int32="float32",n.bool="float32",n.complex64="complex64",z;var n})(),ee=(()=>{return(n=ee||(ee={})).float32="complex64",n.int32="complex64",n.bool="complex64",n.complex64="complex64",ee;var n})();const re={float32:z,int32:N,bool:F,complex64:ee};function ye(n,t){if("string"===n||"string"===t){if("string"===n&&"string"===t)return"string";throw new Error(`Can not upcast ${n} with ${t}`)}return re[n][t]}function lt(n){return ye(n,"int32")}function $t(n){return null!=n&&"object"==typeof n&&"texture"in n&&n.texture instanceof WebGLTexture}function Ct(n){return"undefined"!=typeof GPUBuffer&&null!=n&&"object"==typeof n&&"buffer"in n&&n.buffer instanceof GPUBuffer}function jt(n,t){if(n.dtype===t.dtype)return[n,t];const e=ye(n.dtype,t.dtype);return[n.cast(e),t.cast(e)]}function Bs(n){const t=[];return vs(n,t,new Set),t}function vs(n,t,e){if(null==n)return;if(n instanceof Rr)return void t.push(n);if(!function Vs(n){return Array.isArray(n)||"object"==typeof n}(n))return;const r=n;for(const s in r){const o=r[s];e.has(o)||(e.add(o),vs(o,t,e))}}function Ci(n){return null!=n.kernelName}class br{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(t=>t.name)))}}}dispose(){for(const t in this.registeredVariables)this.registeredVariables[t].dispose()}}let ao=(()=>{class n{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new br}ready(){var e=this;return xe(function*(){if(null!=e.pendingBackendInit)return e.pendingBackendInit.then(()=>{});if(null!=e.backendInstance)return;const r=e.getSortedBackends();for(let s=0;s<r.length;s++){const o=r[s];if(yield e.initializeBackend(o).success)return void(yield e.setBackend(o))}throw new Error("Could not initialize any backends, all backend initializations failed.")})()}get backend(){if(null!=this.pendingBackendInit)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(null==this.backendInstance){const{name:e,asyncInit:r}=this.initializeBackendsAndReturnBest();if(r)throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry)){if(!(e in this.registryFactory))return null;{const{asyncInit:r}=this.initializeBackend(e);if(r)return null}}return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,r,s=1){return e in this.registryFactory?(Js(`${e} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[e]={factory:r,priority:s},!0)}setBackend(e){var r=this;return xe(function*(){if(null==r.registryFactory[e])throw new Error(`Backend name '${e}' not found in registry`);if(r.backendName=e,null==r.registry[e]){r.backendInstance=null;const{success:s,asyncInit:o}=r.initializeBackend(e);if(!(o?yield s:s))return!1}return r.backendInstance=r.registry[e],r.setupRegisteredKernels(),r.profiler=new Vp(r.backendInstance),!0})()}setupRegisteredKernels(){bd(this.backendName).forEach(r=>{null!=r.setupFunc&&r.setupFunc(this.backendInstance)})}disposeRegisteredKernels(e){bd(e).forEach(s=>{null!=s.disposeFunc&&s.disposeFunc(this.registry[e])})}initializeBackend(e){const r=this.registryFactory[e];if(null==r)throw new Error(`Cannot initialize backend ${e}, no registration found.`);try{const s=r.factory();if(!s||s instanceof ue||"function"!=typeof s.then)return this.registry[e]=s,{success:!0,asyncInit:!1};{const o=++this.pendingBackendInitId,l=s.then(u=>!(o<this.pendingBackendInitId||(this.registry[e]=u,this.pendingBackendInit=null,0))).catch(u=>(o<this.pendingBackendInitId||(this.pendingBackendInit=null,Js(`Initialization of backend ${e} failed`),Js(u.stack||u.message)),!1));return this.pendingBackendInit=l,{success:l,asyncInit:!0}}}catch(s){return Js(`Initialization of backend ${e} failed`),Js(s.stack||s.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error(`${e} backend not found in registry`);this.backendName===e&&null!=this.pendingBackendInit&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(0===Object.keys(this.registryFactory).length)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((e,r)=>this.registryFactory[r].priority-this.registryFactory[e].priority)}initializeBackendsAndReturnBest(){const e=this.getSortedBackends();for(let r=0;r<e.length;r++){const s=e[r],{success:o,asyncInit:l}=this.initializeBackend(s);if(l||o)return{name:s,asyncInit:l}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,r){const s=this.state.tensorInfo.get(r),o=s.backend,l=this.readSync(r),u=o.refCount(r);o.disposeData(r,!0),s.backend=e,e.move(r,l,s.shape,s.dtype,u),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,r){let o,s=null;if(null==r){if("function"!=typeof e)throw new Error("Please provide a function to tidy()");r=e}else{if("string"!=typeof e&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if("function"!=typeof r)throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");s=e}return this.scopedRun(()=>this.startScope(s),()=>this.endScope(o),()=>(o=r(),o instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),o))}scopedRun(e,r,s){e();try{const o=s();return r(),o}catch(o){throw r(),o}}nextTensorId(){return n.nextTensorId++}nextVariableId(){return n.nextVariableId++}clone(e){const r=pe.runKernel(Vi,{x:e});return this.addTapeNode(this.state.activeScope.name,{x:e},[r],u=>({x:()=>pe.runKernel(fs,{x:u},{dtype:"float32"})}),[],{}),r}runKernel(e,r,s){if(null==xl(e,this.backendName))throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:r,attrs:s})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,r,s){const o=this.backend.numDataIds();let l=0;s.forEach(h=>{l+="complex64"===h.dtype?3:1});const d=o-r-l-this.state.numDataMovesStack[this.state.numDataMovesStack.length-1];if(d>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${d} data ids) after running '${e}'`)}runKernelFunc(e){let r,s=[];const o=this.isTapeOn(),l=this.state.numBytes,u=this.state.numTensors;let d,h;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);const p=Ci(e)?e.kernelName:null!=this.state.activeScope?this.state.activeScope.name:"";if(Ci(e)){const{kernelName:I,inputs:S,attrs:T}=e,O=xl(I,this.backendName);G(null!=O,()=>`Cannot find registered kernel '${I}' for backend '${this.backendName}'`),d=()=>{const V=this.backend.numDataIds();h=O.kernelFunc({inputs:S,attrs:T,backend:this.backend});const U=Array.isArray(h)?h:[h];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(I,V,U);const j=U.map(te=>null!=te.rank?te:this.makeTensorFromTensorInfo(te));if(o){const te=this.getTensorsForGradient(I,S,j);s=this.saveTensorsForBackwardMode(te)}return j}}else{const{forwardFunc:I}=e,S=T=>{!o||(s=T.map(O=>this.keep(this.clone(O))))};d=()=>{const T=this.backend.numDataIds();h=this.tidy(()=>I(this.backend,S));const O=Array.isArray(h)?h:[h];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(p,T,O),O}}const{inputs:g,attrs:y}=e,b=Ci(e)?null:e.backwardsFunc;let _;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{this.ENV.getBool("DEBUG")||this.state.profiling?(_=this.profiler.profileKernel(p,g,()=>d()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(_),r=_.outputs):r=d()}),o&&this.addTapeNode(p,g,r,b,s,y),this.state.profiling&&this.state.activeProfile.kernels.push({name:p,bytesAdded:this.state.numBytes-l,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-u,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(g).map(I=>null!=g[I]?g[I].shape:null),outputShapes:r.map(I=>I.shape),kernelTimeMs:_.timeMs,extraInfo:_.extraInfo}),Array.isArray(h)?r:r[0]}saveTensorsForBackwardMode(e){return e.map(s=>this.keep(this.clone(s)))}getTensorsForGradient(e,r,s){const o=mc(e);if(null!=o){const l=o.inputsToSave||[],u=o.outputsToSave||[];let d;o.saveAllInputs?(G(Array.isArray(r),()=>"saveAllInputs is true, expected inputs to be an array."),d=Object.keys(r).map(p=>r[p])):d=l.map(p=>r[p]);const h=s.filter((p,g)=>u[g]);return d.concat(h)}return[]}makeTensor(e,r,s,o){if(null==e)throw new Error("Values passed to engine.makeTensor() are null");o=o||this.backend;let l=e;"string"===(s=s||"float32")&&bo(e[0])&&(l=e.map(h=>oo(h)));const u=o.write(l,r,s),d=new Rr(r,s,u,this.nextTensorId());if(this.trackTensor(d,o),"string"===s){const h=this.state.tensorInfo.get(u),p=function qn(n){if(null==n)return 0;let t=0;return n.forEach(e=>t+=e.length),t}(l);this.state.numBytes+=p-h.bytes,h.bytes=p}return d}makeTensorFromDataId(e,r,s,o){return this.makeTensorFromTensorInfo({dataId:e,shape:r,dtype:s=s||"float32"},o)}makeTensorFromTensorInfo(e,r){const{dataId:s,shape:o,dtype:l}=e,u=new Rr(o,l,s,this.nextTensorId());return this.trackTensor(u,r),u}makeVariable(e,r=!0,s,o){s=s||this.nextVariableId().toString(),null!=o&&o!==e.dtype&&(e=e.cast(o));const l=new E(e,r,s,this.nextTensorId());if(null!=this.state.registeredVariables[l.name])throw new Error(`Variable with name ${l.name} was already registered`);return this.state.registeredVariables[l.name]=l,this.incRef(l,this.backend),l}trackTensor(e,r){this.state.numTensors++,"string"===e.dtype&&this.state.numStringTensors++;let s=0;"complex64"!==e.dtype&&"string"!==e.dtype&&(s=e.size*Cr(e.dtype)),this.state.numBytes+=s,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:r||this.backend,dtype:e.dtype,shape:e.shape,bytes:s})),e instanceof E||this.track(e)}incRef(e,r){this.trackTensor(e,r),this.backend.incRef(e.dataId)}removeDataId(e,r){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===r&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;const r=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,"string"===e.dtype&&(this.state.numStringTensors--,this.state.numBytes-=r.bytes),"complex64"!==e.dtype&&"string"!==e.dtype){const s=e.size*Cr(e.dtype);this.state.numBytes-=s}r.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,r.backend)}disposeVariables(){for(const e in this.state.registeredVariables)this.disposeVariable(this.state.registeredVariables[e])}disposeVariable(e){this.disposeTensor(e),null!=this.state.registeredVariables[e.name]&&delete this.state.registeredVariables[e.name]}memory(){const e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,null==e.reasons&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}profile(e){var r=this;return xe(function*(){r.state.profiling=!0;const s=r.state.numBytes,o=r.state.numTensors;r.state.activeProfile.kernels=[],r.state.activeProfile.result=yield e(),r.state.profiling=!1,r.state.activeProfile.peakBytes=Math.max(...r.state.activeProfile.kernels.map(l=>l.totalBytesSnapshot)),r.state.activeProfile.newBytes=r.state.numBytes-s,r.state.activeProfile.newTensors=r.state.numTensors-o;for(const l of r.state.activeProfile.kernels)l.kernelTimeMs=yield l.kernelTimeMs,l.extraInfo=yield l.extraInfo;return r.state.activeProfile})()}isTapeOn(){return this.state.gradientDepth>0&&0===this.state.kernelDepth}addTapeNode(e,r,s,o,l,u){const d={id:this.state.nextTapeNodeId++,kernelName:e,inputs:r,outputs:s,saved:l},h=mc(e);null!=h&&(o=h.gradFunc),null!=o&&(d.gradient=p=>(p=p.map((g,y)=>{if(null==g){const b=s[y],_=er(b.size,b.dtype);return this.makeTensor(_,b.shape,b.dtype)}return g}),o(p.length>1?p:p[0],l,u))),this.state.activeTape.push(d)}keep(e){return e.kept=!0,e}startTape(){0===this.state.gradientDepth&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){const r={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(r.name=e),this.state.scopeStack.push(r),this.state.activeScope=r}endScope(e){const r=Bs(e),s=new Set(r.map(l=>l.id));for(let l=0;l<this.state.activeScope.track.length;l++){const u=this.state.activeScope.track[l];!u.kept&&!s.has(u.id)&&u.dispose()}const o=this.state.scopeStack.pop();this.state.activeScope=0===this.state.scopeStack.length?null:this.state.scopeStack[this.state.scopeStack.length-1],r.forEach(l=>{!l.kept&&l.scopeId===o.id&&this.track(l)})}gradients(e,r,s,o=!1){if(G(r.length>0,()=>"gradients() received an empty list of xs."),null!=s&&"float32"!==s.dtype)throw new Error(`dy must have 'float32' dtype, but has '${s.dtype}'`);const l=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",e));G(l instanceof Rr,()=>"The result y returned by f() must be a tensor.");const u=function yc(n,t,e){const r={},s={};for(let d=0;d<t.length;d++)r[t[d].id]=!0;for(let d=0;d<n.length;d++){const h=n[d],p=h.inputs;for(const g in p){const y=p[g];let b=!1;for(let _=0;_<t.length;_++)if(r[y.id]){h.outputs.forEach(I=>r[I.id]=!0),b=!0,s[h.id]=!0;break}if(b)break}}const o={};o[e.id]=!0;const l={};for(let d=n.length-1;d>=0;d--){const h=n[d],p=h.inputs;for(let g=0;g<h.outputs.length;g++)if(o[h.outputs[g].id]){for(const y in p)o[p[y].id]=!0,l[h.id]=!0;break}}const u=[];for(let d=0;d<n.length;d++){const h=n[d];if(s[h.id]&&l[h.id]){const p={};for(const y in h.inputs){const b=h.inputs[y];r[b.id]&&(p[y]=b)}const g=Object.assign({},h);g.inputs=p,g.outputs=h.outputs,u.push(g)}}return u}(this.state.activeTape,r,l);if(!o&&0===u.length&&r.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const d={};d[l.id]=null==s?function zh(n){const t=_o(Ee(n),"float32");return pe.makeTensor(t,n,"float32")}(l.shape):s,function Qy(n,t,e,r){for(let s=t.length-1;s>=0;s--){const o=t[s],l=[];if(o.outputs.forEach(d=>{const h=n[d.id];l.push(null!=h?h:null)}),null==o.gradient)throw new Error(`Cannot compute gradient: gradient function not found for ${o.kernelName}.`);const u=o.gradient(l);for(const d in o.inputs){if(!(d in u))throw new Error(`Cannot backprop through input ${d}. Available gradients found: ${Object.keys(u)}.`);const h=e(()=>u[d]());if("float32"!==h.dtype)throw new Error(`Error in gradient for op ${o.kernelName}. The gradient of input ${d} must have 'float32' dtype, but has '${h.dtype}'`);const p=o.inputs[d];if(!un(h.shape,p.shape))throw new Error(`Error in gradient for op ${o.kernelName}. The gradient of input '${d}' has shape '${h.shape}', which does not match the shape of the input '${p.shape}'`);if(null==n[p.id])n[p.id]=h;else{const g=n[p.id];n[p.id]=r(g,h),g.dispose()}}}}(d,u,p=>this.tidy(p),Px);const h=r.map(p=>d[p.id]);return 0===this.state.gradientDepth&&(this.state.activeTape.forEach(p=>{for(const g of p.saved)g.dispose()}),this.state.activeTape=null),{value:l,grads:h}})}customGrad(e){return G(ga(e),()=>"The f passed in customGrad(f) must be a function."),(...r)=>{let s;G(r.every(d=>d instanceof Rr),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");const o={};return r.forEach((d,h)=>{o[h]=d}),this.runKernelFunc({forwardFunc:(d,h)=>(s=e(...r,h),G(s.value instanceof Rr,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),G(ga(s.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),s.value),backwardsFunc:(d,h)=>{const p=s.gradFunc(d,h),g=Array.isArray(p)?p:[p];G(g.length===r.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),G(g.every(b=>b instanceof Rr),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const y={};return g.forEach((b,_)=>{y[_]=()=>b}),y},inputs:o})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}readToGPU(e,r){return this.state.tensorInfo.get(e).backend.readToGPU(e,r)}time(e){var r=this;return xe(function*(){const s=Oo(),o=yield r.backend.time(e);return o.wallMs=Oo()-s,o})()}track(e){return null!=this.state.activeScope&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new br;for(const e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}return n.nextTensorId=0,n.nextVariableId=0,n})();function Hh(){const n=Je();if(null==n._tfengine){const t=new Ql(n);n._tfengine=new ao(t)}return function ne(n){ge=n}(n._tfengine.ENV),function Sd(n){ei=n}(()=>n._tfengine),n._tfengine}const pe=Hh();function Px(n,t){return pe.runKernel(Rs,{a:n,b:t})}function gu(n){if(n||function Lx(){return"undefined"!=typeof navigator&&null!=navigator}()){if(n||(n=navigator),"ReactNative"===n.product)return!0;const t=n.userAgent||n.vendor||("undefined"!=typeof window?window.opera:"");if(!t){const e=n;return e.userAgentData&&e.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0,4))}return!1}function zp(){return"undefined"!=typeof window&&null!=window.document||"undefined"!=typeof WorkerGlobalScope}const is=Q();function Sl(n,t){let e=n;if(Ds(n))return"string"===t?[]:[n.length];if($t(n))return[n.height,n.width*(n.channels||"RGBA").length];if(Ct(n))return[n.buffer.size/(null==t?4:Cr(t))];if(!Array.isArray(n))return[];const r=[];for(;Array.isArray(e)||Ds(e)&&"string"!==t;)r.push(e.length),e=e[0];return Array.isArray(n)&&Q().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&Hp(n,r,[]),r}function Hp(n,t,e){if(e=e||[],!Array.isArray(n)&&!Ds(n))return void G(0===t.length,()=>`Element arr[${e.join("][")}] is a primitive, but should be an array/TypedArray of ${t[0]} elements`);G(t.length>0,()=>`Element arr[${e.join("][")}] should be a primitive, but is an array of ${n.length} elements`),G(n.length===t[0],()=>`Element arr[${e.join("][")}] should have ${t[0]} elements, but has ${n.length} elements`);const r=t.slice(1);for(let s=0;s<n.length;++s)Hp(n[s],r,e.concat(s))}function yu(n,t,e,r){if("string_or_numeric"!==n){if(null==n)throw new Error("Expected dtype cannot be null.");if("numeric"!==n&&n!==t||"numeric"===n&&"string"===t)throw new Error(`Argument '${e}' passed to '${r}' must be ${n} tensor, but got ${t} tensor`)}}function q(n,t,e,r="numeric"){if(n instanceof C())return yu(r,n.dtype,t,e),n;let s=Zt(n);if("string"!==s&&["bool","int32","float32"].indexOf(r)>=0&&(s=r),yu(r,s,t,e),null==n||!Ds(n)&&!Array.isArray(n)&&"number"!=typeof n&&"boolean"!=typeof n&&"string"!=typeof n)throw new Error(`Argument '${t}' passed to '${e}' must be a Tensor or TensorLike, but got '${null==n?"null":n.constructor.name}'`);const o=Sl(n,s);!Ds(n)&&!Array.isArray(n)&&(n=[n]);const u="string"!==s?xi(n,s):Pa(n,[],!0);return pe.makeTensor(u,o,s)}function Ed(n,t,e,r="numeric"){if(!Array.isArray(n))throw new Error(`Argument ${t} passed to ${e} must be a \`Tensor[]\` or \`TensorLike[]\``);return n.map((o,l)=>q(o,`${t}[${l}]`,e,r))}is.registerFlag("DEBUG",()=>!1,n=>{n&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")}),is.registerFlag("IS_BROWSER",()=>zp()),is.registerFlag("IS_NODE",()=>"undefined"!=typeof process&&void 0!==process.versions&&void 0!==process.versions.node),is.registerFlag("IS_CHROME",()=>"undefined"!=typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor)),is.registerFlag("IS_SAFARI",()=>"undefined"!=typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor)),is.registerFlag("PROD",()=>!1),is.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>is.getBool("DEBUG")),is.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0),is.registerFlag("IS_TEST",()=>!1),is.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>is.getBool("DEBUG")),is.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1),is.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1),is.registerFlag("USE_SETTIMEOUTCUSTOM",()=>!1);const tv="__op";function de(n){const t=Object.keys(n);if(1!==t.length)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${t.length} keys.`);let e=t[0];const r=n[e];e.endsWith("_")&&(e=e.substring(0,e.length-1)),e+=tv;const s=(...o)=>{pe.startScope(e);try{const l=r(...o);return dn(l)&&console.error("Cannot return a Promise inside of tidy."),pe.endScope(l),l}catch(l){throw pe.endScope(null),l}};return Object.defineProperty(s,"name",{value:e,configurable:!0}),s}const ti=de({complex_:function vu(n,t){const e=q(n,"real","complex"),r=q(t,"imag","complex");return bn(e.shape,r.shape,`real and imag shapes, ${e.shape} and ${r.shape}, must match in call to tf.complex().`),pe.runKernel(So,{real:e,imag:r})}});function El(n,t,e,r){if(null==r)r=Zt(n);else if("complex64"===r)throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(Ct(n)||$t(n)){if("float32"!==r&&"int32"!==r)throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${r}.`);return pe.backend.createTensorFromGPUData(n,t||e,r)}if(!Ds(n)&&!Array.isArray(n)&&"number"!=typeof n&&"boolean"!=typeof n&&"string"!=typeof n)throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(null!=t){Sr(t);const s=Ee(t),o=Ee(e);G(s===o,()=>`Based on the provided shape, [${t}], the tensor should have ${s} values but has ${o}`);for(let l=0;l<e.length;++l){const u=e[l],d=l!==e.length-1||u!==Ee(t.slice(l));G(e[l]===t[l]||!d,()=>`Error creating a new Tensor. Inferred shape (${e}) does not match the provided shape (${t}). `)}}return!Ds(n)&&!Array.isArray(n)&&(n=[n]),t=t||e,n="string"!==r?xi(n,r):Pa(n,[],!0),pe.makeTensor(n,t,r)}function Va(n,t,e){return El(n,t,Sl(n,e),e)}const Il={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};class Si{static join(t){return new Si(t).slice()}constructor(t){if(this.shards=[],this.previousShardIndex=0,null==t||(t instanceof Array||(t=[t]),0===(t=t.map(r=>Ds(r)?r.buffer:r)).length))return;this.bufferUniformSize=t[0].byteLength;let e=0;for(let r=0;r<t.length;r++){const s=t[r];r!==t.length-1&&s.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);const o=e+s.byteLength;this.shards.push({buffer:s,start:e,end:o}),e=o}0===this.shards.length&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(t=0,e=this.byteLength){if(0===this.shards.length)return new ArrayBuffer(0);if(t=isNaN(Number(t))?0:t,e=isNaN(Number(e))?0:e,t=Math.max(0,t),(e=Math.min(this.byteLength,e))<=t)return new ArrayBuffer(0);const r=this.findShardForByte(t);if(-1===r)throw new Error(`Could not find start shard for byte ${t}`);const o=new ArrayBuffer(e-t),l=new Uint8Array(o);let u=0;for(let d=r;d<this.shards.length;d++){const h=this.shards[d],g=t+u-h.start,y=u,_=Math.min(e,h.end)-h.start,I=new Uint8Array(h.buffer,g,_-g);if(l.set(I,y),u+=I.length,e<h.end)break}return o}findShardForByte(t){if(0===this.shards.length||t<0||t>=this.byteLength)return-1;if(null!=this.bufferUniformSize)return this.previousShardIndex=Math.floor(t/this.bufferUniformSize),this.previousShardIndex;function e(s){return t<s.start?-1:t>=s.end?1:0}if(0===e(this.shards[this.previousShardIndex]))return this.previousShardIndex;const r=function MI(n,t){let e=0,r=n.length;for(;e<=r;){const s=Math.floor((r-e)/2)+e,o=t(n[s]);if(0===o)return s;o<0?r=s:e=s+1}return-1}(this.shards,e);return-1===r?-1:(this.previousShardIndex=r,this.previousShardIndex)}}function Qi(){return pe}function En(n,t){return pe.tidy(n,t)}function lo(n){Bs(n).forEach(e=>e.dispose())}function Ji(n){return pe.keep(n)}function rv(){return pe.backendName}function Ux(n,t,e=1){return pe.registerBackend(n,t,e)}function LI(){return pe.backend}function ov(n,t){return Id.apply(this,arguments)}function Id(){return Id=xe(function*(n,t){const e=[],r=[],s=Array.isArray(n)?n.map(l=>l.name):Object.keys(n);for(let l=0;l<s.length;++l){const u=s[l],d=Array.isArray(n)?n[l].tensor:n[u];if("float32"!==d.dtype&&"int32"!==d.dtype&&"bool"!==d.dtype&&"string"!==d.dtype&&"complex64"!==d.dtype)throw new Error(`Unsupported dtype in weight '${u}': ${d.dtype}`);const h={name:u,shape:d.shape,dtype:d.dtype};if("string"===d.dtype){const p=new Promise(function(){var g=xe(function*(y){const b=yield d.bytes(),_=b.reduce((T,O)=>T+O.length,0)+4*b.length,I=new Uint8Array(_);let S=0;for(let T=0;T<b.length;T++){const O=b[T],V=new Uint8Array(new Uint32Array([O.length]).buffer);I.set(V,S),S+=4,I.set(O,S),S+=O.length}y(I)});return function(y){return g.apply(this,arguments)}}());r.push(p)}else r.push(d.data());null!=t&&(h.group=t),e.push(h)}return{data:zx(yield Promise.all(r)),specs:e}}),Id.apply(this,arguments)}function Wp(n,t){const e=new Si(n),r={};let s=0;for(const o of t){const l=iv(o,(u,d)=>e.slice(s+u,s+d));r[o.name]=lv(o,e.slice(s,s+l)),s+=l}return r}function iv(n,t){const e=Ee(n.shape);let r;if("quantization"in n)r=Il[n.quantization.dtype];else{if("string"===n.dtype){let s=0;for(let o=0;o<e;o++)s+=4+new Uint32Array(t(s,s+4))[0];return s}r=Il[n.dtype]}return e*r}function av(n,t){return ni.apply(this,arguments)}function ni(){return(ni=xe(function*(n,t){const e=Ee(n.shape);let r;if("quantization"in n)r=Il[n.quantization.dtype];else{if("string"===n.dtype){let s=0;for(let o=0;o<e;o++)s+=4+new Uint32Array(yield t(s,s+4))[0];return s}r=Il[n.dtype]}return e*r})).apply(this,arguments)}function lv(n,t){const e=n.name,r=n.dtype,s=n.shape,o=Ee(s);let l,u=0;if("quantization"in n){const d=n.quantization;if("uint8"===d.dtype||"uint16"===d.dtype){if(!("min"in d)||!("scale"in d))throw new Error(`Weight ${n.name} with quantization ${d.dtype} doesn't have corresponding metadata min and scale.`)}else{if("float16"!==d.dtype)throw new Error(`Weight ${n.name} has unknown quantization dtype ${d.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);if("float32"!==r)throw new Error(`Weight ${n.name} is quantized with ${d.dtype} which only supports weights of type float32 not ${r}.`)}const h=Il[d.dtype],p="uint8"===d.dtype?new Uint8Array(t):new Uint16Array(t);if("float32"===r)if("uint8"===d.dtype||"uint16"===d.dtype){l=new Float32Array(p.length);for(let g=0;g<p.length;g++)l[g]=p[g]*d.scale+d.min}else{if("float16"!==d.dtype)throw new Error(`Unsupported quantization type ${d.dtype} for weight type float32.`);l=function Kx(){const n=function jx(){const n=e=>{let r=e<<13,s=0;for(;0==(8388608&r);)s-=8388608,r<<=1;return r&=-8388609,s+=947912704,r|s},t=new Uint32Array(2048);t[0]=0;for(let e=1;e<1024;e++)t[e]=n(e);for(let e=1024;e<2048;e++)t[e]=939524096+(e-1024<<13);return t}(),t=function Gx(){const n=new Uint32Array(64);n[0]=0,n[31]=1199570944,n[32]=2147483648,n[63]=3347054592;for(let t=1;t<31;t++)n[t]=t<<23;for(let t=33;t<63;t++)n[t]=2147483648+(t-32<<23);return n}(),e=function hv(){const n=new Uint32Array(64);for(let t=0;t<64;t++)n[t]=1024;return n[0]=n[32]=0,n}();return r=>{const s=new ArrayBuffer(4*r.length),o=new Uint32Array(s);for(let l=0;l<r.length;l++){const u=r[l];o[l]=n[e[u>>10]+(1023&u)]+t[u>>10]}return new Float32Array(s)}}()(p)}else{if("int32"!==r)throw new Error(`Unsupported dtype in weight '${e}': ${r}`);if("uint8"!==d.dtype&&"uint16"!==d.dtype)throw new Error(`Unsupported quantization type ${d.dtype} for weight type int32.`);l=new Int32Array(p.length);for(let g=0;g<p.length;g++)l[g]=Math.round(p[g]*d.scale+d.min)}u+=o*h}else if("string"===r){const d=Ee(n.shape);l=[];for(let h=0;h<d;h++){const p=new Uint32Array(t.slice(u,u+4))[0];u+=4;const g=new Uint8Array(t.slice(u,u+p));l.push(g),u+=p}}else{const d=Il[r];if("float32"===r)l=new Float32Array(t);else if("int32"===r)l=new Int32Array(t);else{if("bool"!==r){if("complex64"===r){l=new Float32Array(t);const h=new Float32Array(l.length/2),p=new Float32Array(l.length/2);for(let _=0;_<h.length;_++)h[_]=l[2*_],p[_]=l[2*_+1];const g=Va(h,s,"float32"),y=Va(p,s,"float32"),b=ti(g,y);return g.dispose(),y.dispose(),b}throw new Error(`Unsupported dtype in weight '${e}': ${r}`)}l=new Uint8Array(t)}u+=o*d}return Va(l,s,r)}function cv(n,t,e){return jp.apply(this,arguments)}function jp(){return(jp=xe(function*(n,t,e){let r=new Uint8Array(t);for(;r.byteLength<e;){const{done:s,value:o}=yield n.read();if(s&&null==o)throw new Error(`Reader is done but ${e-r.byteLength} bytes are still expected`);const l=new Uint8Array(r.length+o.byteLength);l.set(r,0),l.set(new Uint8Array(o),r.length),r=l}return r.buffer})).apply(this,arguments)}function Gp(n,t){return Dd.apply(this,arguments)}function Dd(){return Dd=xe(function*(n,t){const e={},r=n.getReader();let s=new ArrayBuffer(0);for(const o of t){const l=yield av(o,function(){var h=xe(function*(p,g){return s=yield cv(r,s,g),s.slice(p,g)});return function(p,g){return h.apply(this,arguments)}}());s=yield cv(r,s,l);const u=s.slice(0,l);s=s.slice(l);const d=lv(o,u);if(e[o.name]=d,"webgpu"===rv()){const h=LI();"uploadToGPU"in h&&Ee(d.shape)>=Q().get("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD")&&h.uploadToGPU(d.dataId)}}return e}),Dd.apply(this,arguments)}function zx(n){if(null===n)throw new Error(`Invalid input value: ${JSON.stringify(n)}`);let t=0;const e=[];n.forEach(o=>{if(t+=o.byteLength,e.push(o.byteLength===o.buffer.byteLength?o:new o.constructor(o)),!(o instanceof Float32Array||o instanceof Int32Array||o instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${o.constructor.name}`)});const r=new Uint8Array(t);let s=0;return e.forEach(o=>{r.set(new Uint8Array(o.buffer),s),s+=o.byteLength}),r.buffer}!function Jy(n){Ls=n}(function Wh(n){Q().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(n+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")});const Kp="undefined"!=typeof Buffer&&("undefined"==typeof Blob||"undefined"==typeof atob||"undefined"==typeof btoa);function uv(n){return Kp?Buffer.byteLength(n,"utf8"):new Blob([n]).size}function Wx(n){return Si.join(n)}function Us(n){for(n=n.trim();n.endsWith("/");)n=n.slice(0,n.length-1);const e=n.split("/");return e[e.length-1]}function jh(n,t){const e={modelTopology:n.modelTopology,format:n.format,generatedBy:n.generatedBy,convertedBy:n.convertedBy,weightsManifest:t};return null!=n.signature&&(e.signature=n.signature),null!=n.userDefinedMetadata&&(e.userDefinedMetadata=n.userDefinedMetadata),null!=n.modelInitializer&&(e.modelInitializer=n.modelInitializer),null!=n.initializerSignature&&(e.initializerSignature=n.initializerSignature),null!=n.trainingConfig&&(e.trainingConfig=n.trainingConfig),e}function qp(n,t,e){const r={modelTopology:n.modelTopology,format:n.format,generatedBy:n.generatedBy,convertedBy:n.convertedBy};if(null!=n.trainingConfig&&(r.trainingConfig=n.trainingConfig),null!=n.weightsManifest){if(!t)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!e)throw new Error("modelJSON has weightsManifest but weightData is null");r.weightSpecs=t,r.weightData=e}return null!=n.signature&&(r.signature=n.signature),null!=n.userDefinedMetadata&&(r.userDefinedMetadata=n.userDefinedMetadata),null!=n.modelInitializer&&(r.modelInitializer=n.modelInitializer),null!=n.initializerSignature&&(r.initializerSignature=n.initializerSignature),r}function Td(n,t){return bs.apply(this,arguments)}function bs(){return(bs=xe(function*(n,t){let e,r;return null!=n.weightsManifest&&([e,r]=yield t(n.weightsManifest)),qp(n,e,r)})).apply(this,arguments)}function Ua(n){if(n.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:null==n.modelTopology?0:uv(JSON.stringify(n.modelTopology)),weightSpecsBytes:null==n.weightSpecs?0:uv(JSON.stringify(n.weightSpecs)),weightDataBytes:null==n.weightData?0:new Si(n.weightData).byteLength}}function Gh(n){const t=[];for(const e of n)t.push(...e.weights);return t}class hr{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return null==hr.instance&&(hr.instance=new hr),hr.instance}static registerSaveRouter(t){hr.getInstance().saveRouters.push(t)}static registerLoadRouter(t){hr.getInstance().loadRouters.push(t)}static getSaveHandlers(t){return hr.getHandlers(t,"save")}static getLoadHandlers(t,e){return hr.getHandlers(t,"load",e)}static getHandlers(t,e,r){const s=[];return("load"===e?hr.getInstance().loadRouters:hr.getInstance().saveRouters).forEach(l=>{const u=l(t,r);null!==u&&s.push(u)}),s}}const qx=n=>hr.registerSaveRouter(n),fv=n=>hr.registerLoadRouter(n),Xx=n=>hr.getSaveHandlers(n),Yx=(n,t)=>hr.getLoadHandlers(n,t),bu="tensorflowjs",_c="models_store",za="model_info_store";function Xp(){if(!Q().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const n="undefined"==typeof window?self:window,t=n.indexedDB||n.mozIndexedDB||n.webkitIndexedDB||n.msIndexedDB||n.shimIndexedDB;if(null==t)throw new Error("The current browser does not appear to support IndexedDB.");return t}function Yp(n){const t=n.result;t.createObjectStore(_c,{keyPath:"modelPath"}),t.createObjectStore(za,{keyPath:"modelPath"})}let Tl=(()=>{class n{constructor(e){if(this.indexedDB=Xp(),null==e||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}save(e){var r=this;return xe(function*(){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return r.databaseAction(r.modelPath,e)})()}load(){var e=this;return xe(function*(){return e.databaseAction(e.modelPath)})()}databaseAction(e,r){return new Promise((s,o)=>{const l=this.indexedDB.open(bu,1);l.onupgradeneeded=()=>Yp(l),l.onsuccess=()=>{const u=l.result;if(null==r){const d=u.transaction(_c,"readonly"),p=d.objectStore(_c).get(this.modelPath);p.onsuccess=()=>{if(null==p.result)return u.close(),o(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));s(p.result.modelArtifacts)},p.onerror=g=>(u.close(),o(p.error)),d.oncomplete=()=>u.close()}else{r.weightData=Si.join(r.weightData);const d=Ua(r),h=u.transaction(za,"readwrite");let g,y,p=h.objectStore(za);try{g=p.put({modelPath:this.modelPath,modelArtifactsInfo:d})}catch(b){return o(b)}g.onsuccess=()=>{y=u.transaction(_c,"readwrite");const b=y.objectStore(_c);let _;try{_=b.put({modelPath:this.modelPath,modelArtifacts:r,modelArtifactsInfo:d})}catch(I){return o(I)}_.onsuccess=()=>s({modelArtifactsInfo:d}),_.onerror=I=>{p=h.objectStore(za);const S=p.delete(this.modelPath);S.onsuccess=()=>(u.close(),o(_.error)),S.onerror=T=>(u.close(),o(_.error))}},g.onerror=b=>(u.close(),o(g.error)),h.oncomplete=()=>{null==y?u.close():y.oncomplete=()=>u.close()}}},l.onerror=u=>o(l.error)})}}return n.URL_SCHEME="indexeddb://",n})();const Kh=n=>Q().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(Tl.URL_SCHEME)?function pv(n){return new Tl(n)}(n.slice(Tl.URL_SCHEME.length)):null;hr.registerSaveRouter(Kh),hr.registerLoadRouter(Kh);class _u{constructor(){this.indexedDB=Xp()}listModels(){var t=this;return xe(function*(){return new Promise((e,r)=>{const s=t.indexedDB.open(bu,1);s.onupgradeneeded=()=>Yp(s),s.onsuccess=()=>{const o=s.result,l=o.transaction(za,"readonly"),d=l.objectStore(za).getAll();d.onsuccess=()=>{const h={};for(const p of d.result)h[p.modelPath]=p.modelArtifactsInfo;e(h)},d.onerror=h=>(o.close(),r(d.error)),l.oncomplete=()=>o.close()},s.onerror=o=>r(s.error)})})()}removeModel(t){var e=this;return xe(function*(){return t=function VI(n){return n.startsWith(Tl.URL_SCHEME)?n.slice(Tl.URL_SCHEME.length):n}(t),new Promise((r,s)=>{const o=e.indexedDB.open(bu,1);o.onupgradeneeded=()=>Yp(o),o.onsuccess=()=>{const l=o.result,u=l.transaction(za,"readwrite"),d=u.objectStore(za),h=d.get(t);let p;h.onsuccess=()=>{if(null==h.result)return l.close(),s(new Error(`Cannot find model with path '${t}' in IndexedDB.`));{const g=d.delete(t),y=()=>{p=l.transaction(_c,"readwrite");const _=p.objectStore(_c).delete(t);_.onsuccess=()=>r(h.result.modelArtifactsInfo),_.onerror=I=>s(h.error)};g.onsuccess=y,g.onerror=b=>(y(),l.close(),s(h.error))}},h.onerror=g=>(l.close(),s(h.error)),u.oncomplete=()=>{null==p?l.close():p.oncomplete=()=>l.close()}},o.onerror=l=>s(o.error)})})()}}const ri="/",Nl="tensorflowjs_models",mv="info",Zp="model_topology",Zx="weight_specs",Qx="weight_data",Jx="model_metadata";function gv(n){return{info:[Nl,n,mv].join(ri),topology:[Nl,n,Zp].join(ri),weightSpecs:[Nl,n,Zx].join(ri),weightData:[Nl,n,Qx].join(ri),modelMetadata:[Nl,n,Jx].join(ri)}}function yv(n){for(const t of Object.values(n))window.localStorage.removeItem(t)}function Qp(n){const t=n.split(ri);if(t.length<3)throw new Error(`Invalid key format: ${n}`);return t.slice(1,t.length-1).join(ri)}let wc=(()=>{class n{constructor(e){if(!Q().getBool("IS_BROWSER")||"undefined"==typeof window||void 0===window.localStorage)throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,null==e||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=gv(this.modelPath)}save(e){var r=this;return xe(function*(){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const s=JSON.stringify(e.modelTopology),o=JSON.stringify(e.weightSpecs),l=Ua(e),u=Si.join(e.weightData);try{return r.LS.setItem(r.keys.info,JSON.stringify(l)),r.LS.setItem(r.keys.topology,s),r.LS.setItem(r.keys.weightSpecs,o),r.LS.setItem(r.keys.weightData,function dv(n){if(Kp)return Buffer.from(n).toString("base64");const t=new Uint8Array(n);let e="";for(let r=0,s=t.length;r<s;r++)e+=String.fromCharCode(t[r]);return btoa(e)}(u)),r.LS.setItem(r.keys.modelMetadata,JSON.stringify({format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:null!=e.signature?e.signature:void 0,userDefinedMetadata:null!=e.userDefinedMetadata?e.userDefinedMetadata:void 0,modelInitializer:null!=e.modelInitializer?e.modelInitializer:void 0,initializerSignature:null!=e.initializerSignature?e.initializerSignature:void 0,trainingConfig:null!=e.trainingConfig?e.trainingConfig:void 0})),{modelArtifactsInfo:l}}catch(d){throw yv(r.keys),new Error(`Failed to save model '${r.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${l.modelTopologyBytes}, weightSpecsBytes=${l.weightSpecsBytes}, weightDataBytes=${l.weightDataBytes}.`)}}})()}load(){var e=this;return xe(function*(){const r=JSON.parse(e.LS.getItem(e.keys.info));if(null==r)throw new Error(`In local storage, there is no model with name '${e.modelPath}'`);if("JSON"!==r.modelTopologyType)throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const s={},o=JSON.parse(e.LS.getItem(e.keys.topology));if(null==o)throw new Error(`In local storage, the topology of model '${e.modelPath}' is missing.`);s.modelTopology=o;const l=JSON.parse(e.LS.getItem(e.keys.weightSpecs));if(null==l)throw new Error(`In local storage, the weight specs of model '${e.modelPath}' are missing.`);s.weightSpecs=l;const u=e.LS.getItem(e.keys.modelMetadata);if(null!=u){const h=JSON.parse(u);s.format=h.format,s.generatedBy=h.generatedBy,s.convertedBy=h.convertedBy,null!=h.signature&&(s.signature=h.signature),null!=h.userDefinedMetadata&&(s.userDefinedMetadata=h.userDefinedMetadata),null!=h.modelInitializer&&(s.modelInitializer=h.modelInitializer),null!=h.initializerSignature&&(s.initializerSignature=h.initializerSignature),null!=h.trainingConfig&&(s.trainingConfig=h.trainingConfig)}const d=e.LS.getItem(e.keys.weightData);if(null==d)throw new Error(`In local storage, the binary weight values of model '${e.modelPath}' are missing.`);return s.weightData=function Hx(n){if(Kp){const r=Buffer.from(n,"base64");return r.buffer.slice(r.byteOffset,r.byteOffset+r.byteLength)}const t=atob(n),e=new Uint8Array(t.length);for(let r=0;r<t.length;++r)e.set([t.charCodeAt(r)],r);return e.buffer}(d),s})()}}return n.URL_SCHEME="localstorage://",n})();const qh=n=>Q().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(wc.URL_SCHEME)?function ew(n){return new wc(n)}(n.slice(wc.URL_SCHEME.length)):null;hr.registerSaveRouter(qh),hr.registerLoadRouter(qh);class tw{constructor(){G(Q().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),G("undefined"==typeof window||void 0!==window.localStorage,()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}listModels(){var t=this;return xe(function*(){const e={},r=Nl+ri,s=ri+mv;for(let o=0;o<t.LS.length;++o){const l=t.LS.key(o);l.startsWith(r)&&l.endsWith(s)&&(e[Qp(l)]=JSON.parse(t.LS.getItem(l)))}return e})()}removeModel(t){var e=this;return xe(function*(){const r=gv(t=function Jp(n){return n.startsWith(wc.URL_SCHEME)?n.slice(wc.URL_SCHEME.length):n}(t));if(null==e.LS.getItem(r.info))throw new Error(`Cannot find model at path '${t}'`);const s=JSON.parse(e.LS.getItem(r.info));return yv(r),s})()}}const Cc="://";class Ts{constructor(){this.managers={}}static getInstance(){return null==Ts.instance&&(Ts.instance=new Ts),Ts.instance}static registerManager(t,e){G(null!=t,()=>"scheme must not be undefined or null."),t.endsWith(Cc)&&(t=t.slice(0,t.indexOf(Cc))),G(t.length>0,()=>"scheme must not be an empty string.");const r=Ts.getInstance();G(null==r.managers[t],()=>`A model store manager is already registered for scheme '${t}'.`),r.managers[t]=e}static getManager(t){const e=Ts.getInstance().managers[t];if(null==e)throw new Error(`Cannot find model manager for scheme '${t}'`);return e}static getSchemes(){return Object.keys(Ts.getInstance().managers)}}function ea(n){if(-1===n.indexOf(Cc))throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${Ts.getSchemes().join(",")}`);return{scheme:n.split(Cc)[0],path:n.split(Cc)[1]}}function em(n,t){return Xh.apply(this,arguments)}function Xh(){return(Xh=xe(function*(n,t,e=!1){G(n!==t,()=>`Old path and new path are the same: '${n}'`);const r=hr.getLoadHandlers(n);G(r.length>0,()=>`Copying failed because no load handler is found for source URL ${n}.`),G(r.length<2,()=>`Copying failed because more than one (${r.length}) load handlers for source URL ${n}.`);const s=r[0],o=hr.getSaveHandlers(t);G(o.length>0,()=>`Copying failed because no save handler is found for destination URL ${t}.`),G(o.length<2,()=>`Copying failed because more than one (${r.length}) save handlers for destination URL ${t}.`);const l=o[0],u=ea(n).scheme,d=ea(n).path,h=u===ea(n).scheme,p=yield s.load();e&&h&&(yield Ts.getManager(u).removeModel(d));const g=yield l.save(p);return e&&!h&&(yield Ts.getManager(u).removeModel(d)),g.modelArtifactsInfo})).apply(this,arguments)}function nw(){return vv.apply(this,arguments)}function vv(){return(vv=xe(function*(){const n=Ts.getSchemes(),t={};for(const e of n){const r=yield Ts.getManager(e).listModels();for(const s in r)t[e+Cc+s]=r[s]}return t})).apply(this,arguments)}function Yh(n){return tm.apply(this,arguments)}function tm(){return(tm=xe(function*(n){const t=ea(n);return Ts.getManager(t.scheme).removeModel(t.path)})).apply(this,arguments)}function bv(n,t){return Zh.apply(this,arguments)}function Zh(){return(Zh=xe(function*(n,t){return em(n,t,!1)})).apply(this,arguments)}function _v(n,t){return kd.apply(this,arguments)}function kd(){return(kd=xe(function*(n,t){return em(n,t,!0)})).apply(this,arguments)}class xv{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(t,e){return fetch(t,e)}now(){return performance.now()}encode(t,e){if("utf-8"!==e&&"utf8"!==e)throw new Error(`Browser's encoder only supports utf-8, but got ${e}`);return null==this.textEncoder&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(t)}decode(t,e){return new TextDecoder(e).decode(t)}setTimeoutCustom(t,e){"undefined"!=typeof window&&Q().getBool("USE_SETTIMEOUTCUSTOM")?(this.functionRefs.push(t),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")},e),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",r=>{r.source===window&&r.data.name===this.messageName&&(r.stopPropagation(),(0,this.functionRefs[r.data.index])(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0))},!0))):setTimeout(t,e)}isTypedArray(t){return wl(t)}}if(Q().get("IS_BROWSER")){Q().setPlatform("browser",new xv);try{Ts.registerManager(wc.URL_SCHEME,new tw)}catch(n){}try{Ts.registerManager(Tl.URL_SCHEME,new _u)}catch(n){}}let Ha;function gn(n,t="float32",e){return t=t||"float32",Sr(n),new zr(n,t,e)}Q().get("IS_NODE")&&!Q().get("IS_BROWSER")&&Q().setPlatform("node",new class nm{constructor(){this.util=Y(8628),this.textEncoder=new this.util.TextEncoder}fetch(t,e){return null!=Q().global.fetch?Q().global.fetch(t,e):(null==Ha&&(Ha=Y(5410)),Ha(t,e))}now(){const t=process.hrtime();return 1e3*t[0]+t[1]/1e6}encode(t,e){if("utf-8"!==e&&"utf8"!==e)throw new Error(`Node built-in encoder only supports utf-8, but got ${e}`);return this.textEncoder.encode(t)}decode(t,e){return 0===t.length?"":new this.util.TextDecoder(e).decode(t)}isTypedArray(t){return this.util.types.isFloat32Array(t)||this.util.types.isInt32Array(t)||this.util.types.isUint8Array(t)||this.util.types.isUint8ClampedArray(t)}});const fr=de({cast_:function sw(n,t){const e=q(n,"x","cast");if(!function no(n){return"bool"===n||"complex64"===n||"float32"===n||"int32"===n||"string"===n}(t))throw new Error(`Failed to cast to unknown dtype ${t}`);if("string"===t&&"string"!==e.dtype||"string"!==t&&"string"===e.dtype)throw new Error("Only strings can be casted to strings");return pe.runKernel(fs,{x:e},{dtype:t})}}),kl=de({clone_:function ow(n){const e={x:q(n,"x","clone","string_or_numeric")};return pe.runKernel(Vi,e)}});function rm(n,t=!1){console.log(n.toString(t))}Hh(),function Ba(n){La=n}({buffer:gn,cast:fr,clone:kl,print:rm});const rn=de({add_:function Jh(n,t){let e=q(n,"a","add"),r=q(t,"b","add");return[e,r]=jt(e,r),pe.runKernel(Rs,{a:e,b:r})}}),Ev=de({floorDiv_:function Sc(n,t){let e=q(n,"a","floorDiv"),r=q(t,"b","floorDiv");return[e,r]=jt(e,r),pe.runKernel(Li,{a:e,b:r})}}),Hn=de({div_:function iw(n,t){let e=q(n,"a","div"),r=q(t,"b","div");return[e,r]=jt(e,r),"int32"===e.dtype&&"int32"===r.dtype?Ev(e,r):pe.runKernel(rc,{a:e,b:r},{})}}),Nt=de({mul_:function aw(n,t){let e=q(n,"a","mul"),r=q(t,"b","mul");return[e,r]=jt(e,r),pe.runKernel(pl,{a:e,b:r})}}),ta=de({sqrt_:function lw(n){const e={x:q(n,"x","sqrt","float32")};return pe.runKernel(hc,e)}}),Fo=de({square_:function ef(n){const t=q(n,"x","square");return pe.runKernel("Square",{x:t},{})}}),co=de({zerosLike_:function Iv(n){const e={x:q(n,"x","zerosLike")};return pe.runKernel(Yo,e)}});function Wa(n){return pe.customGrad(n)}function xn(n,t){if((Ds(n)&&"string"!==t||Array.isArray(n))&&"complex64"!==t)throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if("string"===t&&Ds(n)&&!(n instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return El(n,[],[],t)}const Ad=new Map,sm=new Map;class xu{constructor(){this.classNameMap={}}static getMap(){return null==xu.instance&&(xu.instance=new xu),xu.instance}static register(t){xu.getMap().classNameMap[t.className]=[t,t.fromConfig]}}function jI(n,t,e){G(null!=n.className,()=>"Class being registered does not have the static className property defined."),G("string"==typeof n.className,()=>"className is required to be a string, but got type "+typeof n.className),G(n.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),void 0===t&&(t="Custom"),void 0===e&&(e=n.className);const s=t+">"+e;return xu.register(n),Ad.set(s,n),sm.set(n,s),n}class wu extends class WI{getClassName(){return this.constructor.className}static fromConfig(t,e){return new t(e)}}{minimize(t,e=!1,r){const{value:s,grads:o}=this.computeGradients(t,r);if(null!=r){const l=r.map(u=>({name:u.name,tensor:o[u.name]}));this.applyGradients(l)}else this.applyGradients(o);return lo(o),e?s:(s.dispose(),null)}get iterations(){return null==this.iterations_&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(t,e){return function dw(n,t){G(ga(n),()=>"The f passed in variableGrads(f) must be a function"),G(null==t||Array.isArray(t)&&t.every(h=>h instanceof E),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");const e=null!=t;if(!e){t=[];for(const h in pe.registeredVariables)t.push(pe.registeredVariables[h])}const r=e?t.filter(h=>!h.trainable):null,s=t.length;G((t=t.filter(h=>h.trainable)).length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${s} variables is trainable.`);const{value:l,grads:u}=pe.gradients(n,t,null,!0);G(u.some(h=>null!=h),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),G(0===l.rank,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${l.rank} tensor`);const d={};return t.forEach((h,p)=>{null!=u[p]&&(d[h.name]=u[p])}),null!=r&&r.forEach(h=>d[h.name]=null),{value:l,grads:d}}(t,e)}dispose(){null!=this.iterations_&&lo(this.iterations_)}saveIterations(){var t=this;return xe(function*(){return null==t.iterations_&&(t.iterations_=0),{name:"iter",tensor:xn(t.iterations_,"int32")}})()}getWeights(){return xe(function*(){throw new Error("getWeights() is not implemented for this optimizer yet.")})()}setWeights(t){var e=this;return xe(function*(){throw new Error(`setWeights() is not implemented for this optimizer class ${e.getClassName()}`)})()}extractIterations(t){var e=this;return xe(function*(){return e.iterations_=(yield t[0].tensor.data())[0],t.slice(1)})()}}function Rd(n,t,e){return Sr(n),e=e||Zt(t),pe.runKernel(Vr,{},{shape:n,value:t,dtype:e})}Object.defineProperty(wu,Symbol.hasInstance,{value:n=>null!=n.minimize&&null!=n.computeGradients&&null!=n.applyGradients});const Md=de({pow_:function fw(n,t){let e=q(n,"base","pow"),r=q(t,"exp","pow");return[e,r]=jt(e,r),pe.runKernel(Ko,{a:e,b:r})}}),fn=de({sub_:function om(n,t){let e=q(n,"a","sub"),r=q(t,"b","sub");return[e,r]=jt(e,r),pe.runKernel(Tn,{a:e,b:r})}}),uo=de({abs_:function Tv(n){const t=q(n,"x","abs");return pe.runKernel("complex64"===t.dtype?Eo:"Abs",{x:t})}});function Ec(n,t){const e=n.length,r=[];for(let s=0;s<e;s++){const o=e-1-s,l=n[o]||1;(t[t.length-1-s]||1)>1&&1===l&&r.unshift(o)}return r}function pw(n,t){const e=[];for(let r=0;r<t.length;r++){const s=n[n.length-r-1],o=t.length-r-1,l=t[o];(null==s||1===s&&l>1)&&e.unshift(o)}return e}function Nn(n,t){const e=Math.max(n.length,t.length),r=new Array(e);for(let s=0;s<e;s++){let o=n[n.length-s-1];null==o&&(o=1);let l=t[t.length-s-1];if(null==l&&(l=1),1===o)r[e-s-1]=l;else if(1===l)r[e-s-1]=o;else{if(o!==l)throw Error(`Operands could not be broadcast together with shapes ${n} and ${t}.`);r[e-s-1]=o}}return r}const nf=de({maximum_:function GI(n,t){let e=q(n,"a","maximum"),r=q(t,"b","maximum");return[e,r]=jt(e,r),"bool"===e.dtype&&(e=fr(e,"int32"),r=fr(r,"int32")),Nn(e.shape,r.shape),pe.runKernel(Da,{a:e,b:r})}});class mw extends wu{static get className(){return"SGD"}constructor(t){super(),this.learningRate=t,this.setLearningRate(t)}applyGradients(t){(Array.isArray(t)?t.map(r=>r.name):Object.keys(t)).forEach((r,s)=>{const o=Array.isArray(t)?t[s].tensor:t[r];if(null==o)return;const l=pe.registeredVariables[r];En(()=>{const u=rn(Nt(this.c,o),l);l.assign(u)})}),this.incrementIterations()}setLearningRate(t){this.learningRate=t,null!=this.c&&this.c.dispose(),this.c=Ji(xn(-t))}dispose(){this.c.dispose()}getWeights(){var t=this;return xe(function*(){return[yield t.saveIterations()]})()}setWeights(t){var e=this;return xe(function*(){if(0!==(t=yield e.extractIterations(t)).length)throw new Error("SGD optimizer does not have settable weights.")})()}getConfig(){return{learningRate:this.learningRate}}static fromConfig(t,e){return new t(e.learningRate)}}const gw=[class Dv extends wu{static get className(){return"Adadelta"}constructor(t,e,r=null){super(),this.learningRate=t,this.rho=e,this.epsilon=r,this.accumulatedGrads=[],this.accumulatedUpdates=[],null==r&&(this.epsilon=pe.backend.epsilon())}applyGradients(t){(Array.isArray(t)?t.map(r=>r.name):Object.keys(t)).forEach((r,s)=>{const o=pe.registeredVariables[r];null==this.accumulatedGrads[s]&&(this.accumulatedGrads[s]={originalName:`${r}/accum_grad`,variable:En(()=>co(o).variable(!1))}),null==this.accumulatedUpdates[s]&&(this.accumulatedUpdates[s]={originalName:`${r}/accum_var`,variable:En(()=>co(o).variable(!1))});const u=Array.isArray(t)?t[s].tensor:t[r];if(null==u)return;const d=this.accumulatedGrads[s].variable,h=this.accumulatedUpdates[s].variable;En(()=>{const p=rn(Nt(d,this.rho),Nt(Fo(u),1-this.rho)),g=Nt(Hn(ta(rn(h,this.epsilon)),ta(rn(d,this.epsilon))),u),y=rn(Nt(h,this.rho),Nt(Fo(g),1-this.rho));d.assign(p),h.assign(y);const b=rn(Nt(g,-this.learningRate),o);o.assign(b)})}),this.incrementIterations()}dispose(){null!=this.accumulatedUpdates&&(lo(this.accumulatedGrads.map(t=>t.variable)),lo(this.accumulatedUpdates.map(t=>t.variable)))}getWeights(){var t=this;return xe(function*(){const e=[...t.accumulatedGrads,...t.accumulatedUpdates];return[yield t.saveIterations()].concat(e.map(r=>({name:r.originalName,tensor:r.variable})))})()}setWeights(t){var e=this;return xe(function*(){const r=(t=yield e.extractIterations(t)).length/2;e.accumulatedGrads=t.slice(0,r).map(o=>({originalName:o.name,variable:o.tensor.variable(!1)})),e.accumulatedUpdates=t.slice(r,2*r).map(o=>({originalName:o.name,variable:o.tensor.variable(!1)}))})()}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(t,e){return new t(e.learningRate,e.rho,e.epsilon)}},class hw extends wu{static get className(){return"Adagrad"}constructor(t,e=.1){super(),this.learningRate=t,this.initialAccumulatorValue=e,this.accumulatedGrads=[]}applyGradients(t){(Array.isArray(t)?t.map(r=>r.name):Object.keys(t)).forEach((r,s)=>{const o=pe.registeredVariables[r];null==this.accumulatedGrads[s]&&(this.accumulatedGrads[s]={originalName:`${r}/accumulator`,variable:En(()=>Rd(o.shape,this.initialAccumulatorValue).variable(!1))});const l=Array.isArray(t)?t[s].tensor:t[r];if(null==l)return;const u=this.accumulatedGrads[s].variable;En(()=>{const d=rn(u,Fo(l));u.assign(d);const h=rn(Nt(Hn(l,ta(rn(d,pe.backend.epsilon()))),-this.learningRate),o);o.assign(h)})}),this.incrementIterations()}dispose(){null!=this.accumulatedGrads&&lo(this.accumulatedGrads.map(t=>t.variable))}getWeights(){var t=this;return xe(function*(){return[yield t.saveIterations()].concat(t.accumulatedGrads.map(e=>({name:e.originalName,tensor:e.variable})))})()}setWeights(t){var e=this;return xe(function*(){t=yield e.extractIterations(t),e.accumulatedGrads=t.map(s=>({originalName:s.name,variable:s.tensor.variable(!1)}))})()}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(t,e){return new t(e.learningRate,e.initialAccumulatorValue)}},class Od extends wu{static get className(){return"Adam"}constructor(t,e,r,s=null){super(),this.learningRate=t,this.beta1=e,this.beta2=r,this.epsilon=s,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],En(()=>{this.accBeta1=xn(e).variable(),this.accBeta2=xn(r).variable()}),null==s&&(this.epsilon=pe.backend.epsilon())}applyGradients(t){const e=Array.isArray(t)?t.map(r=>r.name):Object.keys(t);En(()=>{const r=fn(1,this.accBeta1),s=fn(1,this.accBeta2);e.forEach((o,l)=>{const u=pe.registeredVariables[o];null==this.accumulatedFirstMoment[l]&&(this.accumulatedFirstMoment[l]={originalName:`${o}/m`,variable:En(()=>co(u).variable(!1))}),null==this.accumulatedSecondMoment[l]&&(this.accumulatedSecondMoment[l]={originalName:`${o}/v`,variable:En(()=>co(u).variable(!1))});const h=Array.isArray(t)?t[l].tensor:t[o];if(null==h)return;const p=this.accumulatedFirstMoment[l].variable,g=this.accumulatedSecondMoment[l].variable,y=rn(Nt(p,this.beta1),Nt(h,1-this.beta1)),b=rn(Nt(g,this.beta2),Nt(Fo(h),1-this.beta2)),_=Hn(y,r),I=Hn(b,s);p.assign(y),g.assign(b);const S=rn(Nt(Hn(_,rn(ta(I),this.epsilon)),-this.learningRate),u);u.assign(S)}),this.accBeta1.assign(Nt(this.accBeta1,this.beta1)),this.accBeta2.assign(Nt(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),null!=this.accumulatedFirstMoment&&lo(this.accumulatedFirstMoment.map(t=>t.variable)),null!=this.accumulatedSecondMoment&&lo(this.accumulatedSecondMoment.map(t=>t.variable))}getWeights(){var t=this;return xe(function*(){const e=[...t.accumulatedFirstMoment,...t.accumulatedSecondMoment];return[yield t.saveIterations()].concat(e.map(r=>({name:r.originalName,tensor:r.variable})))})()}setWeights(t){var e=this;return xe(function*(){t=yield e.extractIterations(t),En(()=>{e.accBeta1.assign(Md(e.beta1,e.iterations_+1)),e.accBeta2.assign(Md(e.beta2,e.iterations_+1))});const r=t.length/2;e.accumulatedFirstMoment=t.slice(0,r).map(o=>({originalName:o.name,variable:o.tensor.variable(!1)})),e.accumulatedSecondMoment=t.slice(r,2*r).map(o=>({originalName:o.name,variable:o.tensor.variable(!1)}))})()}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(t,e){return new t(e.learningRate,e.beta1,e.beta2,e.epsilon)}},class im extends wu{static get className(){return"Adamax"}constructor(t,e,r,s=null,o=0){super(),this.learningRate=t,this.beta1=e,this.beta2=r,this.epsilon=s,this.decay=o,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],En(()=>{this.iteration=xn(0).variable(),this.accBeta1=xn(e).variable()}),null==s&&(this.epsilon=pe.backend.epsilon())}applyGradients(t){const e=Array.isArray(t)?t.map(r=>r.name):Object.keys(t);En(()=>{const r=fn(1,this.accBeta1),s=Hn(-this.learningRate,rn(Nt(this.iteration,this.decay),1));e.forEach((o,l)=>{const u=pe.registeredVariables[o];null==this.accumulatedFirstMoment[l]&&(this.accumulatedFirstMoment[l]={originalName:`${o}/m`,variable:co(u).variable(!1)}),null==this.accumulatedWeightedInfNorm[l]&&(this.accumulatedWeightedInfNorm[l]={originalName:`${o}/v`,variable:co(u).variable(!1)});const h=Array.isArray(t)?t[l].tensor:t[o];if(null==h)return;const p=this.accumulatedFirstMoment[l].variable,g=this.accumulatedWeightedInfNorm[l].variable,y=rn(Nt(p,this.beta1),Nt(h,1-this.beta1)),b=Nt(g,this.beta2),_=uo(h),I=nf(b,_);p.assign(y),g.assign(I);const S=rn(Nt(Hn(s,r),Hn(y,rn(I,this.epsilon))),u);u.assign(S)}),this.iteration.assign(rn(this.iteration,1)),this.accBeta1.assign(Nt(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),null!=this.accumulatedFirstMoment&&lo(this.accumulatedFirstMoment.map(t=>t.variable)),null!=this.accumulatedWeightedInfNorm&&lo(this.accumulatedWeightedInfNorm.map(t=>t.variable))}getWeights(){return xe(function*(){throw new Error("getWeights() is not implemented for Adamax yet.")})()}setWeights(t){return xe(function*(){throw new Error("setWeights() is not implemented for Adamax yet.")})()}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(t,e){return new t(e.learningRate,e.beta1,e.beta2,e.epsilon,e.decay)}},class KI extends mw{static get className(){return"Momentum"}constructor(t,e,r=!1){super(t),this.learningRate=t,this.momentum=e,this.useNesterov=r,this.accumulations=[],this.m=xn(this.momentum)}applyGradients(t){(Array.isArray(t)?t.map(r=>r.name):Object.keys(t)).forEach((r,s)=>{const o=pe.registeredVariables[r];null==this.accumulations[s]&&(this.accumulations[s]={originalName:`${r}/momentum`,variable:En(()=>co(o).variable(!1))});const l=this.accumulations[s].variable,u=Array.isArray(t)?t[s].tensor:t[r];null!=u&&En(()=>{let d;const h=rn(Nt(this.m,l),u);d=rn(Nt(this.c,this.useNesterov?rn(u,Nt(h,this.m)):h),o),l.assign(h),o.assign(d)})}),this.incrementIterations()}dispose(){this.m.dispose(),null!=this.accumulations&&lo(this.accumulations.map(t=>t.variable))}setMomentum(t){this.momentum=t}getWeights(){var t=this;return xe(function*(){return[yield t.saveIterations()].concat(t.accumulations.map(e=>({name:e.originalName,tensor:e.variable})))})()}setWeights(t){var e=this;return xe(function*(){t=yield e.extractIterations(t),e.accumulations=t.map(s=>({originalName:s.name,variable:s.tensor.variable(!1)}))})()}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(t,e){return new t(e.learningRate,e.momentum,e.useNesterov)}},class Nv extends wu{static get className(){return"RMSProp"}constructor(t,e=.9,r=0,s=null,o=!1){if(super(),this.learningRate=t,this.decay=e,this.momentum=r,this.epsilon=s,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=o,null==s&&(this.epsilon=pe.backend.epsilon()),null==t)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(t){(Array.isArray(t)?t.map(r=>r.name):Object.keys(t)).forEach((r,s)=>{const o=pe.registeredVariables[r],l=!1;null==this.accumulatedMeanSquares[s]&&(this.accumulatedMeanSquares[s]={originalName:`${r}/rms`,variable:En(()=>co(o).variable(l))}),null==this.accumulatedMoments[s]&&(this.accumulatedMoments[s]={originalName:`${r}/momentum`,variable:En(()=>co(o).variable(l))}),null==this.accumulatedMeanGrads[s]&&this.centered&&(this.accumulatedMeanGrads[s]={originalName:`${r}/mg`,variable:En(()=>co(o).variable(l))});const u=Array.isArray(t)?t[s].tensor:t[r];if(null==u)return;const d=this.accumulatedMeanSquares[s].variable,h=this.accumulatedMoments[s].variable;En(()=>{const p=rn(Nt(d,this.decay),Nt(Fo(u),1-this.decay));if(this.centered){const g=this.accumulatedMeanGrads[s].variable,y=rn(Nt(g,this.decay),Nt(u,1-this.decay)),b=Hn(Nt(u,this.learningRate),ta(fn(p,rn(Fo(y),this.epsilon)))),_=rn(Nt(h,this.momentum),b);d.assign(p),g.assign(y),h.assign(_);const I=fn(o,_);o.assign(I)}else{const g=rn(Nt(d,this.decay),Nt(Fo(u),1-this.decay)),y=rn(Nt(h,this.momentum),Hn(Nt(u,this.learningRate),ta(rn(g,this.epsilon))));d.assign(g),h.assign(y);const b=fn(o,y);o.assign(b)}})}),this.incrementIterations()}dispose(){null!=this.accumulatedMeanSquares&&lo(this.accumulatedMeanSquares.map(t=>t.variable)),null!=this.accumulatedMeanGrads&&this.centered&&lo(this.accumulatedMeanGrads.map(t=>t.variable)),null!=this.accumulatedMoments&&lo(this.accumulatedMoments.map(t=>t.variable))}getWeights(){var t=this;return xe(function*(){const e=[...t.accumulatedMeanSquares,...t.accumulatedMoments];return t.centered&&e.push(...t.accumulatedMeanGrads),[yield t.saveIterations()].concat(e.map(r=>({name:r.originalName,tensor:r.variable})))})()}setWeights(t){var e=this;return xe(function*(){t=yield e.extractIterations(t);const r=e.centered?t.length/3:t.length/2,s=!1;e.accumulatedMeanSquares=t.slice(0,r).map(o=>({originalName:o.name,variable:o.tensor.variable(s)})),e.accumulatedMoments=t.slice(r,2*r).map(o=>({originalName:o.name,variable:o.tensor.variable(s)})),e.centered&&(e.accumulatedMeanGrads=t.slice(2*r,3*r).map(o=>({originalName:o.name,variable:o.tensor.variable(s)})))})()}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(t,e){return new t(e.learningRate,e.decay,e.momentum,e.epsilon,e.centered)}},mw];function Fd(n){return new Promise(t=>setTimeout(t)).then(n)}let am=(()=>{class n{constructor(e){if(!Q().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(n.URL_SCHEME)&&(e=e.slice(n.URL_SCHEME.length)),(null==e||0===e.length)&&(e="model"),this.modelJsonFileName=e+".json",this.weightDataFileName=e+".weights.bin"}save(e){var r=this;return xe(function*(){if("undefined"==typeof document)throw new Error("Browser downloads are not supported in this environment since `document` is not present");const s=Si.join(e.weightData),o=window.URL.createObjectURL(new Blob([s],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const u=jh(e,[{paths:["./"+r.weightDataFileName],weights:e.weightSpecs}]),d=window.URL.createObjectURL(new Blob([JSON.stringify(u)],{type:"application/json"})),h=null==r.modelJsonAnchor?document.createElement("a"):r.modelJsonAnchor;if(h.download=r.modelJsonFileName,h.href=d,yield Fd(()=>h.dispatchEvent(new MouseEvent("click"))),null!=e.weightData){const p=null==r.weightDataAnchor?document.createElement("a"):r.weightDataAnchor;p.download=r.weightDataFileName,p.href=o,yield Fd(()=>p.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:Ua(e)}}})()}}return n.URL_SCHEME="downloads://",n})();class lm{constructor(t){if(null==t||t.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${t}`);this.jsonFile=t[0],this.weightsFiles=t.slice(1)}load(){var t=this;return xe(function*(){return new Promise((e,r)=>{const s=new FileReader;s.onload=o=>{const l=JSON.parse(o.target.result),u=l.modelTopology;if(null==u)return void r(new Error(`modelTopology field is missing from file ${t.jsonFile.name}`));if(null==l.weightsManifest)return void r(new Error(`weightManifest field is missing from file ${t.jsonFile.name}`));if(0===t.weightsFiles.length)return void e({modelTopology:u});const h=Td(l,p=>t.loadWeights(p));e(h)},s.onerror=o=>r(`Failed to read model topology and weights manifest JSON from file '${t.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),s.readAsText(t.jsonFile)})})()}loadWeights(t){const e=[],r=[];for(const l of t)e.push(...l.weights),r.push(...l.paths);const s=this.checkManifestAndWeightFiles(t),o=r.map(l=>this.loadWeightsFile(l,s[l]));return Promise.all(o).then(l=>[e,l])}loadWeightsFile(t,e){return new Promise((r,s)=>{const o=new FileReader;o.onload=l=>{r(l.target.result)},o.onerror=l=>s(`Failed to weights data from file of path '${t}'.`),o.readAsArrayBuffer(e)})}checkManifestAndWeightFiles(t){const e=[],r=this.weightsFiles.map(o=>Us(o.name)),s={};for(const o of t)o.paths.forEach(l=>{const u=Us(l);if(-1!==e.indexOf(u))throw new Error(`Duplicate file basename found in weights manifest: '${u}'`);if(e.push(u),-1===r.indexOf(u))throw new Error(`Weight file with basename '${u}' is not provided.`);s[l]=this.weightsFiles[r.indexOf(u)]});if(e.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${e.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return s}}function xw(n){return new lm(n)}function Av(n,t,e,r){(function l(d){G(null!=d&&Array.isArray(d)&&d.length>0,()=>"promises must be a none empty array")})(n),function u(d,h){G(d>=0&&d<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${d}`),G(h>=0&&h<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${h}`),G(h>=d,()=>`startFraction must be no more than endFraction, but got startFraction ${d} and endFraction ${h}`)}(e=null==e?0:e,r=null==r?1:r);let s=0;return Promise.all(n.map(d=>(d.then(h=>{const p=e+ ++s/n.length*(r-e);return t(p),h}),d)))}function rf(n,t){return sf.apply(this,arguments)}function sf(){return(sf=xe(function*(n,t){null==t&&(t={});const e=null==t.fetchFunc?Q().platform.fetch:t.fetchFunc,r=n.map(g=>e(g,t.requestInit,{isBinary:!0})),u=(null==t.onProgress?yield Promise.all(r):yield Av(r,t.onProgress,0,.5)).map(g=>g.arrayBuffer());return null==t.onProgress?yield Promise.all(u):yield Av(u,t.onProgress,.5,1)})).apply(this,arguments)}function Cw(n){return cm.apply(this,arguments)}function cm(){return(cm=xe(function*(n,t="",e,r){return Rv(l=>rf(l,{requestInit:r}))(n,t,e)})).apply(this,arguments)}function Rv(n){return function(){var t=xe(function*(e,r="",s){const o=e.map(()=>!1),l={},u=null!=s?s.map(()=>!1):[],d=[];if(e.forEach((_,I)=>{let S=0;_.weights.forEach(T=>{const V=Il["quantization"in T?T.quantization.dtype:T.dtype]*Ee(T.shape),U=()=>{o[I]=!0,null==l[I]&&(l[I]=[]),l[I].push({manifestEntry:T,groupOffset:S,sizeBytes:V})};null!=s?s.forEach((j,te)=>{j===T.name&&(U(),u[te]=!0)}):U(),d.push(T.name),S+=V})}),!u.every(_=>_)){const _=s.filter((I,S)=>!u[S]);throw new Error(`Could not find weights in manifest with names: ${_.join(", ")}. \nManifest JSON has weights with names: ${d.join(", ")}.`)}const h=o.reduce((_,I,S)=>(I&&_.push(S),_),[]),p=[];h.forEach(_=>{e[_].paths.forEach(I=>{const S=r+(r.endsWith("/")?"":"/")+I;p.push(S)})});const g=yield n(p),y={};let b=0;return h.forEach(_=>{const I=e[_].paths.length,S=new Si(g.slice(b,b+I));l[_].forEach(O=>{const U=Wp(S.slice(O.groupOffset,O.groupOffset+O.sizeBytes),[O.manifestEntry]);for(const j in U)y[j]=U[j]}),b+=I}),y});return function(e){return t.apply(this,arguments)}}()}hr.registerSaveRouter(n=>Q().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(am.URL_SCHEME)?function qr(n="model"){return new am(n)}(n.slice(am.URL_SCHEME.length)):null);let Ew=(()=>{class n{constructor(e,r){if(this.DEFAULT_METHOD="POST",null==r&&(r={}),this.weightPathPrefix=r.weightPathPrefix,this.weightUrlConverter=r.weightUrlConverter,null!=r.fetchFunc?(G("function"==typeof r.fetchFunc,()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=r.fetchFunc):this.fetch=Q().platform.fetch,G(null!=e&&e.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(e)&&G(2===e.length,()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`),this.path=e,null!=r.requestInit&&null!=r.requestInit.body)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=r.requestInit||{},this.loadOptions=r}save(e){var r=this;return xe(function*(){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const s=Object.assign({method:r.DEFAULT_METHOD},r.requestInit);s.body=new FormData;const l=jh(e,[{paths:["./model.weights.bin"],weights:e.weightSpecs}]);if(s.body.append("model.json",new Blob([JSON.stringify(l)],{type:"application/json"}),"model.json"),null!=e.weightData){const d=Si.join(e.weightData);s.body.append("model.weights.bin",new Blob([d],{type:"application/octet-stream"}),"model.weights.bin")}const u=yield r.fetch(r.path,s);if(u.ok)return{modelArtifactsInfo:Ua(e),responses:[u]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${u.status}.`)})()}loadModelJSON(){var e=this;return xe(function*(){const r=yield e.fetch(e.path,e.requestInit);if(!r.ok)throw new Error(`Request to ${e.path} failed with status code ${r.status}. Please verify this URL points to the model JSON of the model to load.`);let s;try{s=yield r.json()}catch(u){let d=`Failed to parse model JSON of response from ${e.path}.`;throw e.path.endsWith(".pb")?d+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":d+=" Please make sure the server is serving valid JSON for this request.",new Error(d)}if(null==s.modelTopology&&null==s.weightsManifest)throw new Error(`The JSON from HTTP path ${e.path} contains neither model topology or manifest for weights.`);return s})()}load(){var e=this;return xe(function*(){return e.loadOptions.streamWeights?e.loadStream():Td(yield e.loadModelJSON(),s=>e.loadWeights(s))})()}loadStream(){var e=this;return xe(function*(){const r=yield e.loadModelJSON(),s=yield e.getWeightUrls(r.weightsManifest),o=Gh(r.weightsManifest);return Object.assign(Object.assign({},r),{weightSpecs:o,getWeightStream:()=>function ww(n,t){var e;const r=null==t.fetchFunc?Q().platform.fetch:t.fetchFunc;let o,s=0;return null===(e=t.onProgress)||void 0===e||e.call(t,0),new ReadableStream({pull:(l=xe(function*(u){for(var d;s<n.length;){o||(o=(yield r(n[s],t.requestInit,{isBinary:!0})).body.getReader());const{done:h,value:p}=yield o.read();if(!h)return void u.enqueue(p);s++,o=void 0,null===(d=t.onProgress)||void 0===d||d.call(t,s/n.length)}u.close()}),function(d){return l.apply(this,arguments)})});var l}(s,e.loadOptions)})})()}getWeightUrls(e){var r=this;return xe(function*(){const s=Array.isArray(r.path)?r.path[1]:r.path,[o,l]=function $d(n){const t=n.lastIndexOf("/"),e=n.lastIndexOf("?");return[n.substring(0,t)+"/",e>t?n.substring(e):""]}(s),u=r.weightPathPrefix||o,d=[],h=[];for(const p of e)for(const g of p.paths)null!=r.weightUrlConverter?h.push(r.weightUrlConverter(g)):d.push(u+g+l);return r.weightUrlConverter&&d.push(...yield Promise.all(h)),d})()}loadWeights(e){var r=this;return xe(function*(){const s=yield r.getWeightUrls(e);return[Gh(e),yield rf(s,r.loadOptions)]})()}}return n.URL_SCHEME_REGEX=/^https?:\/\//,n})();function Pd(n){return null!=n.match(Ew.URL_SCHEME_REGEX)}const um=(n,t)=>{if("undefined"==typeof fetch&&(null==t||null==t.fetchFunc))return null;{let e=!0;if(e=Array.isArray(n)?n.every(r=>Pd(r)):Pd(n),e)return af(n,t)}return null};function af(n,t){return new Ew(n,t)}function Mv(n,t){return af(n,t)}hr.registerSaveRouter(um),hr.registerLoadRouter(um);class dm{constructor(t){this.modelArtifacts=t}load(){return this.modelArtifacts}}class hm{constructor(t){this.saveHandler=t}save(t){return this.saveHandler(t)}}class Ov{constructor(t){t.load&&(this.load=()=>Promise.resolve(t.load())),t.save&&(this.save=e=>Promise.resolve(t.save(e)))}}function fm(n,t,e,r){const s=arguments;return new Ov(Iw(...s))}function Iw(n,t,e,r){return 1===arguments.length?null!=n.modelTopology||null!=n.weightSpecs?new dm(n):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new dm({modelTopology:n})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new dm({modelTopology:n,weightSpecs:t,weightData:e,trainingConfig:r}))}function Dw(n){return new hm(n)}function pm(n){return new hm(n)}function mm(n,t,e){if(Bt(n),null!=t&&3!==t.length)throw new Error("tensor3d() requires shape to have three numbers");const r=Sl(n,e);if(3!==r.length&&1!==r.length)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return El(n,t,r,e)}let Al;const Cu=de({fromPixels_:function Fv(n,t=3){if(t>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(null==n)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let e=!1,r=!1,s=!1,o=!1,l=!1,u=!1;if(n.data instanceof Uint8Array)e=!0;else if("undefined"!=typeof ImageData&&n instanceof ImageData)r=!0;else if("undefined"!=typeof HTMLVideoElement&&n instanceof HTMLVideoElement)s=!0;else if("undefined"!=typeof HTMLImageElement&&n instanceof HTMLImageElement)o=!0;else if(null!=n.getContext)l=!0;else{if(!("undefined"!=typeof ImageBitmap&&n instanceof ImageBitmap))throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${n.constructor.name}`);u=!0}if(null!=xl($h,pe.backendName))return pe.runKernel($h,{pixels:n},{numChannels:t});const[h,p]=s?[n.videoWidth,n.videoHeight]:[n.width,n.height];let g,y;if(l)g=n.getContext("2d").getImageData(0,0,h,p).data;else if(r||e)g=n.data;else if(o||s||u){if(null==Al)if("undefined"==typeof document){if("undefined"==typeof OffscreenCanvas||"undefined"==typeof OffscreenCanvasRenderingContext2D)throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");Al=new OffscreenCanvas(1,1).getContext("2d")}else Al=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});Al.canvas.width=h,Al.canvas.height=p,Al.drawImage(n,0,0,h,p),g=Al.getImageData(0,0,h,p).data}if(4===t)y=new Int32Array(g);else{const _=h*p;y=new Int32Array(_*t);for(let I=0;I<_;I++)for(let S=0;S<t;++S)y[I*t+S]=g[4*I+S]}return mm(y,[p,h,t],"int32")}});function Cm(n,t,e){const r=n.shape.length;G(r===t.length,()=>`Error in slice${r}D: Length of begin ${t} must match the rank of the array (${r}).`),G(r===e.length,()=>`Error in slice${r}D: Length of size ${e} must match the rank of the array (${r}).`);for(let s=0;s<r;++s)G(t[s]+e[s]<=n.shape[s],()=>`Error in slice${r}D: begin[${s}] + size[${s}] (${t[s]+e[s]}) would overflow input.shape[${s}] (${n.shape[s]})`)}function Aw(n){const t=[];let e=0;for(;n>0;)1&n&&t.push(e),n/=2,e++;return t}function Ld(n,t,e){const r=[];for(let s=0;s<n.length;s++)r[s]=Math.ceil((t[s]-n[s])/e[s]);return r}function $v(n,t,e,r){const s=[...n];for(let o=s.length;o<r.length;o++)s.push(1);for(let o=0;o<e;o++)0===o?s[t]=1:(s.splice(t,0,1),s.pop());return s}function Sm(n,t,e){return e<=n?e:e-(t-1)}function Pv(n,t){const e=[];for(let r=0;r<n;r++)e.push(t+r);return e}function Lv(n,t,e,r,s,o,l,u,d){const h=n.length;let p=new Array(h),g=new Array(h),y=new Array(h);if(t.length&&e>0){const b=t[0],_=e+1;p=Rw(l,b,_,r,n),g=Bv(u,b,_,s,n),y=$v(o,b,_,n)}else for(let b=0;b<h;b++)p[b]=Vv(l,r,o,n,b,d),g[b]=Ic(u,s,o,n,b,d),y[b]=Su(o,b,d);return{begin:p,end:g,strides:y}}function Rw(n,t,e,r,s){const o=[...s],l=Pv(e,t);for(let u=0;u<o.length;u++)if(l.indexOf(u)>-1)o[u]=0;else{const d=Sm(t,e,u);let h=r[d];n&1<<d&&(h=0),o[u]=h}return o}function Bv(n,t,e,r,s){const o=[...s],l=Pv(e,t);for(let u=0;u<o.length;u++)if(l.indexOf(u)>-1)o[u]=Number.MAX_SAFE_INTEGER;else{const d=Sm(t,e,u);let h=r[d];n&1<<d&&(h=Number.MAX_SAFE_INTEGER),o[u]=h}for(let u=0;u<o.length;u++){const d=s[u];o[u]<0&&(o[u]+=d),o[u]=Ve(0,o[u],s[u])}return o}function Su(n,t,e){let r=n[t];return(e&1<<t||null==r)&&(r=1),r}function Vv(n,t,e,r,s,o){let l=t[s];(n&1<<s||o&1<<s||null==l)&&(l=(e[s]||1)>0?Number.MIN_SAFE_INTEGER:Number.MAX_SAFE_INTEGER);const d=r[s];return l<0&&(l+=d),l=Ve(0,l,d-1),l}function Ic(n,t,e,r,s,o){let l=t[s];const u=e[s]||1;(n&1<<s||o&1<<s||null==l)&&(l=u>0?Number.MAX_SAFE_INTEGER:Number.MIN_SAFE_INTEGER);const d=r[s];return l<0&&(l+=d),l=u>0?Ve(0,l,d):Ve(-1,l,d-1),l}function Dc(n,t,e){let r=e.length;for(let s=0;s<e.length;s++)if(e[s]>1){r=s;break}for(let s=r+1;s<e.length;s++)if(t[s]>0||e[s]!==n[s])return!1;return!0}function Em(n,t){let e=n.length>0?n[n.length-1]:1;for(let r=0;r<n.length-1;r++)e+=n[r]*t[r];return e}function Uv(n,t,e){let r;const s=n.shape.length;let o;return r="number"==typeof t?[t,...new Array(s-1).fill(0)]:t.length<s?t.concat(new Array(s-t.length).fill(0)):t.slice(),r.forEach(l=>{G(-1!==l,()=>"slice() does not support negative begin indexing.")}),o=null==e?new Array(s).fill(-1):"number"==typeof e?[e,...new Array(s-1).fill(-1)]:e.length<s?e.concat(new Array(s-e.length).fill(-1)):e,o=o.map((l,u)=>l>=0?l:(G(-1===l,()=>`Negative size values should be exactly -1 but got ${l} for the slice() size at index ${u}.`),n.shape[u]-r[u])),[r,o]}function cf(n,t,e,r,s,o,l,u,d){let h;if(null==r?(h=new Array(t.length),h.fill(1)):h=r,null!=l&&0!=(l&l-1))throw new Error("Multiple ellipses in slice is not allowed.");let p=!1;const g={dims:h.length,numAddAxisAfterEllipsis:0,begin:t.slice(),end:e.slice(),strides:h.slice(),beginMask:s,endMask:o,ellipsisMask:l,newAxisMask:u,shrinkAxisMask:d};for(let V=0;V<g.dims;V++)p&&0!=(1<<V&u)&&g.numAddAxisAfterEllipsis++,1<<V&l&&(p=!0);p||(g.ellipsisMask|=1<<g.dims,g.dims++);const y={dims:n.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};!function Mw(n,t){t.beginMask=0,t.endMask=0,t.shrinkAxisMask=0;let e=0;t.beginValid=null!=n.begin,t.endValid=null!=n.end,t.begin=new Array(t.dims),t.end=new Array(t.dims),t.strides=new Array(t.dims),t.finalShapeGatherIndices=[],t.finalShapeGatherIndicesSparse=[],t.inputShapeGatherIndicesSparse=new Array(t.dims);for(let r=0;r<n.dims;r++)if(1<<r&n.ellipsisMask){const s=Math.min(t.dims-(n.dims-r)+1+n.numAddAxisAfterEllipsis,t.dims);for(;e<s;e++)t.begin[e]=0,t.end[e]=0,t.strides[e]=1,t.beginMask|=1<<e,t.endMask|=1<<e,t.finalShapeGatherIndices.push(e),t.finalShapeGatherIndicesSparse.push(-1),t.inputShapeGatherIndicesSparse[e]=r}else if(1<<r&n.newAxisMask)t.finalShapeGatherIndices.push(-2),t.finalShapeGatherIndicesSparse.push(-1);else{if(e===t.begin.length)throw Error(`Index out of range using input dim ${e}; input has only ${t.dims} dims, ${t.begin.length}.`);null!=n.begin&&(t.begin[e]=n.begin[r]),null!=n.end&&(t.end[e]=n.end[r]),t.strides[e]=n.strides[r],n.beginMask&1<<r&&(t.beginMask|=1<<e),n.endMask&1<<r&&(t.endMask|=1<<e),n.shrinkAxisMask&1<<r?(t.finalShapeGatherIndices.push(-1),t.finalShapeGatherIndicesSparse.push(-1),t.shrinkAxisMask|=1<<e):(t.finalShapeGatherIndices.push(e),t.finalShapeGatherIndicesSparse.push(r)),t.inputShapeGatherIndicesSparse[e]=r,e++}}(g,y);let b=!0,_=!0,I=!0;const S=[],T=[];for(let V=0;V<n.length;++V){if(0===y.strides[V])throw Error(`strides[${V}] must be non-zero`);const U=!!(y.shrinkAxisMask&1<<V),j=n[V];if(-1===j){S.push(U?1:-1);continue}const te=[y.beginMask&1<<V,y.endMask&1<<V],se=[y.strides[V]>0?0:-1,y.strides[V]>0?j:j-1];if(U&&y.strides[V]<=0)throw Error("only stride 1 allowed on non-range indexing.");I=I&&1===y.strides[V];const le=!!(y.beginMask&1<<V&&y.endMask&1<<V);if(y.beginValid&&y.endValid){if(U){const He=y.begin[V]<0?j+y.begin[V]:y.begin[V];if(y.begin[V]=He,y.end[V]=y.begin[V]+1,He<0||He>=j)throw Error(`slice index ${y.begin[V]} of dimension ${V} out of bounds.`)}else y.begin[V]=zv(y.begin[V],0,y.strides[V],j,te,se),y.end[V]=zv(y.end[V],1,y.strides[V],j,te,se);const Me=1===y.strides[V]&&0===y.begin[V]&&y.end[V]===j;b=b&&Me,_=_&&(0===V&&1===y.strides[V]||Me)}else b=b&&1===y.strides[V]&&le,_=_&&(0===V&&1===y.strides[V]||le);let Ce,be=!1;if(y.beginValid&&y.endValid?(Ce=y.end[V]-y.begin[V],be=!0):U?(Ce=1,be=!0):le&&j>=0&&(Ce=y.strides[V]<0?-j:j,be=!0),be){let Me;Me=0===Ce||Ce<0!=y.strides[V]<0?0:Math.trunc(Ce/y.strides[V])+(Ce%y.strides[V]!=0?1:0),S.push(Me)}else S.push(-1)}for(let V=0;V<y.finalShapeGatherIndices.length;++V){const U=y.finalShapeGatherIndices[V];U>=0?T.push(S[U]):-2===U&&T.push(1)}return{finalShapeSparse:T.filter((V,U)=>-2!==y.finalShapeGatherIndices[U]),finalShape:T,isIdentity:b,sliceDim0:_,isSimpleSlice:I,begin:y.begin,end:y.end,strides:y.strides}}function zv(n,t,e,r,s,o){if(s[t])return e>0?o[t]:o[t+1&1];{const l=n<0?r+n:n;return l<o[0]?o[0]:l>o[1]?o[1]:l}}const Hv=de({acos_:function Ow(n){const e={x:q(n,"x","acos")};return pe.runKernel(lr,e)}}),Im=de({acosh_:function Fw(n){const e={x:q(n,"x","acosh")};return pe.runKernel(As,e)}}),$w=de({addN_:function Dm(n){G(Array.isArray(n),()=>"The argument passed to tf.addN() must be a list of tensors"),G(n.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${n.length}`);const t=n.map((s,o)=>q(s,`tensors${o}`,"addN")),e=t[0];return t.forEach(s=>{if(s.dtype!==e.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),t.forEach(s=>{if(!un(s.shape,e.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")}),pe.runKernel(Ks,t)}}),Bd=de({all_:function Tm(n,t=null,e=!1){const s={x:q(n,"x","all","bool")};return pe.runKernel("All",s,{axis:t,keepDims:e})}}),Lw=de({any_:function Pw(n,t=null,e=!1){const s={x:q(n,"x","any","bool")};return pe.runKernel("Any",s,{axis:t,keepDims:e})}}),Vw=de({argMax_:function Bw(n,t=0){const r={x:q(n,"x","argMax")};return pe.runKernel(Lr,r,{axis:t})}}),zw=de({argMin_:function Uw(n,t=0){const r={x:q(n,"x","argMin")};return pe.runKernel(kt,r,{axis:t})}}),Eu=de({asin_:function Hw(n){const e={x:q(n,"x","asin")};return pe.runKernel(an,e)}}),Ww=de({asinh_:function Ga(n){const e={x:q(n,"x","asinh")};return pe.runKernel(Bn,e)}}),YI=de({atan_:function jw(n){const e={x:q(n,"x","atan")};return pe.runKernel(Wr,e)}}),Wv=de({atan2_:function ZI(n,t){let e=q(n,"a","atan2"),r=q(t,"b","atan2");return[e,r]=jt(e,r),pe.runKernel(tr,{a:e,b:r})}}),jv=de({atanh_:function QI(n){const e={x:q(n,"x","atanh")};return pe.runKernel(xo,e)}});function uf(n,t,e,r,s="NHWC",o){return Xr(n,[...t,n[3]],e,o,r,null,null,sn(s))}function $o(n,t,e,r,s,o,l="channelsLast"){const[u,d]=Iu(t);let h;if("channelsLast"===l)h=[u,d,n[3],n[3]];else{if("channelsFirst"!==l)throw new Error(`Unknown dataFormat ${l}`);h=[u,d,n[1],n[1]]}return Xr(n,h,e,r,s,o,!1,l)}function Ka(n,t,e,r,s,o,l="NDHWC"){const[u,d,h]=km(t);let p,g;if("NDHWC"===l)g="channelsLast",p=[u,d,h,n[4],n[4]];else{if("NCDHW"!==l)throw new Error(`Unknown dataFormat ${l}`);g="channelsFirst",p=[u,d,h,n[1],n[1]]}return Ml(n,p,e,r,s,!1,g,o)}function Xr(n,t,e,r,s,o,l=!1,u="channelsLast"){let[d,h,p,g]=[-1,-1,-1,-1];if("channelsLast"===u)[d,h,p,g]=n;else{if("channelsFirst"!==u)throw new Error(`Unknown dataFormat ${u}`);[d,g,h,p]=n}const[y,b,,_]=t,[I,S]=Iu(e),[T,O]=Iu(r),V=Du(y,T),U=Du(b,O),{padInfo:j,outHeight:te,outWidth:se}=function Kw(n,t,e,r,s,o,l,u,d){let h,p,g;if("number"==typeof n){h={top:n,bottom:n,left:n,right:n,type:0===n?"VALID":"NUMBER"};const b=function Gw(n,t,e,r,s){null==r&&(r=Nm(n,t,e));const l=n[1];return[Tu((n[0]-t+2*r)/e+1,s),Tu((l-t+2*r)/e+1,s)]}([t,e],o,r,n,u);p=b[0],g=b[1]}else if("same"===n){p=Math.ceil(t/r),g=Math.ceil(e/s);const y=Math.max(0,(p-1)*r+o-t),b=Math.max(0,(g-1)*s+l-e),_=Math.floor(y/2),I=y-_,S=Math.floor(b/2);h={top:_,bottom:I,left:S,right:b-S,type:"SAME"}}else if("valid"===n)h={top:0,bottom:0,left:0,right:0,type:"VALID"},p=Math.ceil((t-o+1)/r),g=Math.ceil((e-l+1)/s);else{if("object"!=typeof n)throw Error(`Unknown padding parameter: ${n}`);{const y="channelsLast"===d?n[1][0]:n[2][0],b="channelsLast"===d?n[1][1]:n[2][1],_="channelsLast"===d?n[2][0]:n[3][0],I="channelsLast"===d?n[2][1]:n[3][1];h={top:y,bottom:b,left:_,right:I,type:0===y&&0===b&&0===_&&0===I?"VALID":"EXPLICIT"},p=Tu((t-o+y+b)/r+1,u),g=Tu((e-l+_+I)/s+1,u)}}return{padInfo:h,outHeight:p,outWidth:g}}(s,h,p,I,S,V,U,o,u),le=l?_*g:_;let Ce;return"channelsFirst"===u?Ce=[d,le,te,se]:"channelsLast"===u&&(Ce=[d,te,se,le]),{batchSize:d,dataFormat:u,inHeight:h,inWidth:p,inChannels:g,outHeight:te,outWidth:se,outChannels:le,padInfo:j,strideHeight:I,strideWidth:S,filterHeight:y,filterWidth:b,effectiveFilterHeight:V,effectiveFilterWidth:U,dilationHeight:T,dilationWidth:O,inShape:n,outShape:Ce,filterShape:t}}function Ml(n,t,e,r,s,o=!1,l="channelsLast",u){let[d,h,p,g,y]=[-1,-1,-1,-1,-1];if("channelsLast"===l)[d,h,p,g,y]=n;else{if("channelsFirst"!==l)throw new Error(`Unknown dataFormat ${l}`);[d,y,h,p,g]=n}const[b,_,I,,S]=t,[T,O,V]=km(e),[U,j,te]=km(r),se=Du(b,U),le=Du(_,j),Ce=Du(I,te),{padInfo:be,outDepth:Me,outHeight:He,outWidth:We}=function qw(n,t,e,r,s,o,l,u,d,h,p){let g,y,b,_;if("valid"===n&&(n=0),"number"==typeof n){g={top:n,bottom:n,left:n,right:n,front:n,back:n,type:0===n?"VALID":"NUMBER"};const S=function Ei(n,t,e,r,s,o){null==s&&(s=Nm(n,t[0],r[0]));const l=[0,0,0,e];for(let u=0;u<3;u++)n[u]+2*s>=t[u]&&(l[u]=Tu((n[u]-t[u]+2*s)/r[u]+1,o));return l}([t,e,r,1],[u,d,h],1,[s,o,l],n,p);y=S[0],b=S[1],_=S[2]}else{if("same"!==n)throw Error(`Unknown padding parameter: ${n}`);{y=Math.ceil(t/s),b=Math.ceil(e/o),_=Math.ceil(r/l);const I=(y-1)*s+u-t,S=(b-1)*o+d-e,T=(_-1)*l+h-r,O=Math.floor(I/2),V=I-O,U=Math.floor(S/2),j=S-U,te=Math.floor(T/2);g={top:U,bottom:j,left:te,right:T-te,front:O,back:V,type:"SAME"}}}return{padInfo:g,outDepth:y,outHeight:b,outWidth:_}}(s,h,p,g,T,O,V,se,le,Ce,u),je=o?S*y:S;let Ke;return"channelsFirst"===l?Ke=[d,je,Me,He,We]:"channelsLast"===l&&(Ke=[d,Me,He,We,je]),{batchSize:d,dataFormat:l,inDepth:h,inHeight:p,inWidth:g,inChannels:y,outDepth:Me,outHeight:He,outWidth:We,outChannels:je,padInfo:be,strideDepth:T,strideHeight:O,strideWidth:V,filterDepth:b,filterHeight:_,filterWidth:I,effectiveFilterDepth:se,effectiveFilterHeight:le,effectiveFilterWidth:Ce,dilationDepth:U,dilationHeight:j,dilationWidth:te,inShape:n,outShape:Ke,filterShape:t}}function Nm(n,t,e,r=1){const s=Du(t,r);return Math.floor((n[0]*(e-1)-e+s)/2)}function Iu(n){return"number"==typeof n?[n,n,n]:2===n.length?[n[0],n[1],1]:n}function km(n){return"number"==typeof n?[n,n,n]:n}function Du(n,t){return t<=1?n:n+(n-1)*(t-1)}function Tu(n,t){if(!t)return Math.trunc(n);switch(t){case"round":return Math.round(n);case"ceil":return Math.ceil(n);case"floor":return Math.floor(n);default:throw new Error(`Unknown roundingMode ${t}`)}}function Vd(n){const[t,e,r]=Iu(n);return 1===t&&1===e&&1===r}function Ns(n,t){return Vd(n)||Vd(t)}function Tc(n){return Iu(n).every(t=>t>0)}function sn(n){if("NHWC"===n)return"channelsLast";if("NCHW"===n)return"channelsFirst";throw new Error(`Unknown dataFormat ${n}`)}function Po(n,t,e){if(null!=e){if("string"==typeof t)throw Error(`Error in ${n}: pad must be an integer when using dimRoundingMode ${e} but got pad ${t}.`);if("number"==typeof t)G(kn(t),()=>`Error in ${n}: pad must be an integer when using dimRoundingMode ${e} but got pad ${t}.`);else{if("object"!=typeof t)throw Error(`Error in ${n}: Unknown padding parameter: ${t}`);t.forEach(r=>{r.forEach(s=>{G(kn(s),()=>`Error in ${n}: pad must be an integer when using dimRoundingMode ${e} but got pad ${s}.`)})})}}}const tt=de({reshape_:function Gv(n,t){const r={x:q(n,"x","reshape","string_or_numeric")};return pe.runKernel(gi,r,{shape:t})}}),Kv=de({avgPool_:function Xw(n,t,e,r,s){const o=q(n,"x","avgPool","float32");G(Ns(e,1),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${e} and dilations '1'`);let u=o,d=!1;3===o.rank&&(d=!0,u=tt(o,[1,o.shape[0],o.shape[1],o.shape[2]])),G(4===u.rank,()=>`Error in avgPool: x must be rank 4 but got rank ${u.rank}.`),Po("avgPool",r,s);let g=pe.runKernel(Ms,{x:u},{filterSize:t,strides:e,pad:r,dimRoundingMode:s});return g=fr(g,o.dtype),d?tt(g,[g.shape[1],g.shape[2],g.shape[3]]):g}}),Yw=de({avgPool3d_:function qv(n,t,e,r,s,o="NDHWC"){const l=q(n,"x","avgPool3d","float32");let u=l,d=!1;4===l.rank&&(d=!0,u=tt(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]])),G(5===u.rank,()=>`Error in avgPool3d: x must be rank 5 but got rank ${u.rank}.`),G("NDHWC"===o,()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${o}`),G("number"==typeof e&&e>0||Array.isArray(e)&&e[0]>0&&e[1]>0&&e[2]>0,()=>`Error in avgPool3d: Stride must be > 0, but got '${e}'`),Po("avgPool3d",r,s);let g=pe.runKernel(hs,{x:u},{filterSize:t,strides:e,pad:r,dimRoundingMode:s,dataFormat:o});return g=fr(g,u.dtype),d?tt(g,[g.shape[1],g.shape[2],g.shape[3],g.shape[4]]):g}}),zs=de({concat_:function Xv(n,t=0){G(n.length>=1,()=>"Pass at least one tensor to concat");const e=Ed(n,"tensors","concat","string_or_numeric");return"complex64"===e[0].dtype&&e.forEach(o=>{if("complex64"!==o.dtype)throw new Error(`Cannot concatenate complex64 tensors with a tensor\n          with dtype ${o.dtype}. `)}),1===e.length?kl(e[0]):pe.runKernel(Vn,e,{axis:t})}}),Yn=de({matMul_:function Zw(n,t,e=!1,r=!1){let s=q(n,"a","matMul"),o=q(t,"b","matMul");return[s,o]=jt(s,o),pe.runKernel(mn,{a:s,b:o},{transposeA:e,transposeB:r})}}),Ol=de({sigmoid_:function Yv(n){const e={x:q(n,"x","sigmoid","float32")};return pe.runKernel(dc,e)}}),Pn=de({slice_:function Nc(n,t,e){const r=q(n,"x","slice","string_or_numeric");if(0===r.rank)throw new Error("Slicing scalar is not possible");return pe.runKernel(kr,{x:r},{begin:t,size:e})}}),Ud=de({tanh_:function Am(n){const e={x:q(n,"x","tanh","float32")};return pe.runKernel(yn,e)}}),JI=de({basicLSTMCell_:function Qw(n,t,e,r,s,o){const l=q(n,"forgetBias","basicLSTMCell"),u=q(t,"lstmKernel","basicLSTMCell"),d=q(e,"lstmBias","basicLSTMCell"),h=q(r,"data","basicLSTMCell"),p=q(s,"c","basicLSTMCell"),g=q(o,"h","basicLSTMCell"),y=zs([h,g],1),b=Yn(y,u),_=rn(b,d),S=_.shape[1]/4,T=[_.shape[0],S],O=Pn(_,[0,0],T),V=Pn(_,[0,S],T),U=Pn(_,[0,2*S],T),j=Pn(_,[0,3*S],T),te=rn(Nt(Ol(O),Ud(V)),Nt(p,Ol(rn(l,U))));return[te,Nt(Ud(te),Ol(j))]}}),Jw=de({batchToSpaceND_:function eD(n,t,e){const r=q(n,"x","batchToSpaceND"),s=t.reduce((u,d)=>u*d);return G(r.rank>=1+t.length,()=>`input rank is ${r.rank} but should be > than blockShape.length ${t.length}`),G(e.length===t.length,()=>`crops.length is ${e.length} but should be equal to blockShape.length  ${t.length}`),G(r.shape[0]%s==0,()=>`input tensor batch is ${r.shape[0]} but is not divisible by the product of the elements of blockShape ${t.join(" * ")} === ${s}`),pe.runKernel(Fi,{x:r},{blockShape:t,crops:e})}});function eC(n){let t;return t=0===n.rank||1===n.rank?tt(n,[1,1,1,n.size]):2===n.rank?tt(n,[1,1,n.shape[0],n.shape[1]]):3===n.rank?tt(n,[1,n.shape[0],n.shape[1],n.shape[2]]):n,t}const Rm=de({batchNorm_:function Zv(n,t,e,r,s,o){null==o&&(o=.001);const l=q(n,"x","batchNorm"),u=q(t,"mean","batchNorm"),d=q(e,"variance","batchNorm");let h,p;null!=s&&(h=q(s,"scale","batchNorm")),null!=r&&(p=q(r,"offset","batchNorm")),G(u.rank===d.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),G(null==p||u.rank===p.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),G(null==h||u.rank===h.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");const y={x:eC(l),scale:h,offset:p,mean:u,variance:d},_=pe.runKernel(ic,y,{varianceEpsilon:o});return tt(_,l.shape)}}),Nu=de({batchNorm2d_:function tC(n,t,e,r,s,o){const l=q(n,"x","batchNorm"),u=q(t,"mean","batchNorm"),d=q(e,"variance","batchNorm");let h,p;return null!=s&&(h=q(s,"scale","batchNorm")),null!=r&&(p=q(r,"offset","batchNorm")),G(2===l.rank,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${l.rank}.`),G(2===u.rank||1===u.rank,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${u.rank}.`),G(2===d.rank||1===d.rank,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${d.rank}.`),null!=h&&G(2===h.rank||1===h.rank,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${h.rank}.`),null!=p&&G(2===p.rank||1===p.rank,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${p.rank}.`),Rm(l,u,d,p,h,o)}}),Qv=de({batchNorm3d_:function nC(n,t,e,r,s,o){const l=q(n,"x","batchNorm"),u=q(t,"mean","batchNorm"),d=q(e,"variance","batchNorm");let h,p;return null!=s&&(h=q(s,"scale","batchNorm")),null!=r&&(p=q(r,"offset","batchNorm")),G(3===l.rank,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${l.rank}.`),G(3===u.rank||1===u.rank,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${u.rank}.`),G(3===d.rank||1===d.rank,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${d.rank}.`),null!=h&&G(3===h.rank||1===h.rank,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${h.rank}.`),null!=p&&G(3===p.rank||1===p.rank,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${p.rank}.`),Rm(l,u,d,p,h,o)}}),rC=de({batchNorm4d_:function df(n,t,e,r,s,o){const l=q(n,"x","batchNorm"),u=q(t,"mean","batchNorm"),d=q(e,"variance","batchNorm");let h,p;return null!=s&&(h=q(s,"scale","batchNorm")),null!=r&&(p=q(r,"offset","batchNorm")),G(4===l.rank,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${l.rank}.`),G(4===u.rank||1===u.rank,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${u.rank}.`),G(4===d.rank||1===d.rank,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${d.rank}.`),null!=h&&G(4===h.rank||1===h.rank,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${h.rank}.`),null!=p&&G(4===p.rank||1===p.rank,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${p.rank}.`),Rm(l,u,d,p,h,o)}}),e0=de({bincount_:function Jv(n,t,e){const r=q(n,"x","bincount"),s=q(t,"weights","bincount");return G("int32"===r.dtype,()=>`Error in bincount: input dtype must be int32, but got ${r.dtype}`),G(e>=0,()=>`size must be non-negative, but got ${e}.`),G(s.size===r.size||0===s.size,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${r.shape}, weights shape: ${s.shape}.`),pe.runKernel(Co,{x:r,weights:s},{size:e})}}),oC=de({bitwiseAnd_:function sC(n,t){const e=q(n,"x","bitwiseAnd"),r=q(t,"y","bitwiseAnd");if(!un(e.shape,r.shape))throw new Error(`BitwiseAnd: Tensors must have the same shape. x: ${e.shape}, y: ${r.shape}`);if("int32"!==e.dtype||"int32"!==r.dtype)throw new Error(`BitwiseAnd: Only supports 'int32' values in tensor, found type of x: ${e.dtype} and type of y: ${r.dtype}`);return pe.runKernel($i,{a:e,b:r})}}),aC=de({broadcastArgs_:function iC(n,t){const e=q(n,"s0","broadcastArgs","int32"),r=q(t,"s1","broadcastArgs","int32");if(1!==e.rank)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${e.rank}`);if(1!==r.rank)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${r.rank}`);return pe.runKernel(cr,{s0:e,s1:r})}}),zd=de({broadcastTo_:function t0(n,t){let e=q(n,"broadcastTo","x");const r=e.shape;if(Sr(t),t.length<e.rank)throw new Error(`broadcastTo(): shape.length=${t.length} < input.rank=${e.rank}.`);if(t.length>e.rank){const h=e.shape.slice();for(;h.length<t.length;)h.unshift(1);e=tt(e,h)}const s=e.shape,o=Array.from(t);for(let h=t.length-1;h>=0;h--)if(s[h]===t[h])o[h]=1;else if(1!==e.shape[h])throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${t}].`);return 0===o.map((h,p)=>h>1?p:-1).filter(h=>h>=0).length?kl(e):pe.runKernel(sr,{x:e},{reps:o})}}),r0=de({ceil_:function n0(n){const e={x:q(n,"x","ceil","float32")};return pe.runKernel(Os,e)}}),tD=de({clipByValue_:function Mm(n,t,e){const r=q(n,"x","clipByValue");return G(t<=e,()=>`Error in clip: min (${t}) must be less than or equal to max (${e}).`),t===e?Rd(r.shape,t,r.dtype):pe.runKernel(Br,{x:r},{clipValueMin:t,clipValueMax:e})}}),lC=de({concat1d_:function Om(n){return zs(n,0)}}),kc=de({concat2d_:function nD(n,t){return zs(n,t)}}),o0=de({concat3d_:function s0(n,t){return zs(n,t)}}),Ii=de({concat4d_:function hf(n,t){return zs(n,t)}}),ff=de({conv2d_:function a0(n,t,e,r,s="NHWC",o=[1,1],l){const u=q(n,"x","conv2d","float32"),d=q(t,"filter","conv2d","float32");let h=u,p=!1;3===u.rank&&(p=!0,h=tt(u,[1,u.shape[0],u.shape[1],u.shape[2]])),G(4===h.rank,()=>`Error in conv2d: input must be rank 4, but got rank ${h.rank}.`),G(4===d.rank,()=>`Error in conv2d: filter must be rank 4, but got rank ${d.rank}.`),Po("conv2d",r,l);const g="NHWC"===s?h.shape[3]:h.shape[1];G(g===d.shape[2],()=>`Error in conv2d: depth of input (${g}) must match input depth for filter ${d.shape[2]}.`),G(Ns(e,o),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${e} and dilations '${o}'`),G(Tc(o),()=>"Error in conv2D: Dilated rates should be larger than 0."),G(Tc(e),()=>"Error in conv2D: Strides should be larger than 0.");const _=pe.runKernel(sl,{x:h,filter:d},{strides:e,pad:r,dataFormat:s,dilations:o,dimRoundingMode:l});return p?tt(_,[_.shape[1],_.shape[2],_.shape[3]]):_}}),qa=de({conv1d_:function Fm(n,t,e,r,s="NWC",o=1,l){const u=q(n,"x","conv1d"),d=q(t,"filter","conv1d");let h=u,p=!1;2===u.rank&&(p=!0,h=tt(u,[1,u.shape[0],u.shape[1]])),G(3===h.rank,()=>`Error in conv1d: input must be rank 3, but got rank ${h.rank}.`),G(3===d.rank,()=>`Error in conv1d: filter must be rank 3, but got rank ${d.rank}.`),Po("conv1d",r,l),G(h.shape[2]===d.shape[1],()=>`Error in conv1d: depth of input (${h.shape[2]}) must match input depth for filter ${d.shape[1]}.`),G(Ns(e,o),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${e} and dilation '${o}'`),G(Tc(o),()=>"Error in conv1D: Dilated rates should be larger than 0."),G(Tc(e),()=>"Error in conv1D: Stride should be larger than 0."),G("NWC"===s,()=>`Error in conv1d: got dataFormat of ${s} but only NWC is currently supported.`);const g=tt(d,[1,d.shape[0],d.shape[1],d.shape[2]]),y=tt(h,[h.shape[0],1,h.shape[1],h.shape[2]]),S=ff(y,g,[1,e],r,"NHWC",[1,o],l);return tt(S,p?[S.shape[2],S.shape[3]]:[S.shape[0],S.shape[2],S.shape[3]])}}),Pm=de({conv2DBackpropInput_:function $m(n,t,e,r,s,o="NHWC",l){G(n.length===t.rank,()=>`Length of inShape (${n.length}) and rank of dy (${t.rank}) must match`);let u=n,d=t,h=!1;3===t.rank&&(h=!0,d=tt(t,[1,t.shape[0],t.shape[1],t.shape[2]]),u=[1,n[0],n[1],n[2]]),G(4===u.length,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${u.length}.`),G(4===d.rank,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${d.rank}`),G(4===e.rank,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${e.rank}`);const p="NHWC"===o?u[3]:u[1],g="NHWC"===o?d.shape[3]:d.shape[1];G(p===e.shape[2],()=>`Error in conv2dDerInput: depth of input (${p}) must match input depth for filter ${e.shape[2]}.`),G(g===e.shape[3],()=>`Error in conv2dDerInput: depth of output (${g}) must match output depth for filter ${e.shape[3]}.`),Po("conv2dDerInput",s,l);const _=pe.runKernel(jr,{dy:d,filter:e},{strides:r,pad:s,dataFormat:o,dimRoundingMode:l,inputShape:u});return h?tt(_,[_.shape[1],_.shape[2],_.shape[3]]):_}}),rD=de({conv2dTranspose_:function Lm(n,t,e,r,s,o){const l=q(n,"x","conv2dTranspose"),u=q(t,"filter","conv2dTranspose");return Pm(e,l,u,r,s,"NHWC",o)}}),sD=de({conv3d_:function l0(n,t,e,r,s="NDHWC",o=[1,1,1]){const l=q(n,"x","conv3d"),u=q(t,"filter","conv3d");let d=l,h=!1;4===l.rank&&(h=!0,d=tt(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]])),G(5===d.rank,()=>`Error in conv3d: input must be rank 5, but got rank ${d.rank}.`),G(5===u.rank,()=>`Error in conv3d: filter must be rank 5, but got rank ${u.rank}.`),G(d.shape[4]===u.shape[3],()=>`Error in conv3d: depth of input (${d.shape[4]}) must match input depth for filter ${u.shape[3]}.`),G(Ns(e,o),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${e} and dilations '${o}'`),G("NDHWC"===s,()=>`Error in conv3d: got dataFormat of ${s} but only NDHWC is currently supported.`),G(Tc(o),()=>"Error in conv3D: Dilated rates should be larger than 0."),G(Tc(e),()=>"Error in conv3D: Strides should be larger than 0.");const y=pe.runKernel(es,{x:d,filter:u},{strides:e,pad:r,dataFormat:s,dilations:o});return h?tt(y,[y.shape[1],y.shape[2],y.shape[3],y.shape[4]]):y}}),mf=de({conv3DBackpropInput_:function pf(n,t,e,r,s){G(n.length===t.rank,()=>`Length of inShape (${n.length}) and rank of dy (${t.rank}) must match`);let o=n,l=t,u=!1;4===t.rank&&(u=!0,l=tt(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]),o=[1,n[0],n[1],n[2],n[3]]);const d=o[4],h=l.shape[4];G(5===o.length,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${o.length}.`),G(5===l.rank,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${l.rank}`),G(5===e.rank,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${e.rank}`),G(d===e.shape[3],()=>`Error in conv3dDerInput: depth of input (${d}) must match input depth for filter ${e.shape[3]}.`),G(h===e.shape[4],()=>`Error in conv3dDerInput: depth of output (${h}) must match output depth for filter ${e.shape[4]}.`);const y=pe.runKernel(Gr,{dy:l,filter:e},{pad:s,strides:r,inputShape:o});return u?tt(y,[y.shape[1],y.shape[2],y.shape[3],y.shape[4]]):y}}),Vm=de({conv3dTranspose_:function Bm(n,t,e,r,s){const o=q(n,"x","conv3dTranspose"),l=q(t,"filter","conv3dTranspose");return mf(e,o,l,r,s)}}),oD=de({cos_:function Um(n){const e={x:q(n,"x","cos","float32")};return pe.runKernel(Io,e)}}),uC=de({cosh_:function cC(n){const e={x:q(n,"x","cosh","float32")};return pe.runKernel(ps,e)}}),hC=de({cumprod_:function dC(n,t=0,e=!1,r=!1){const o={x:q(n,"x","cumprod")};return pe.runKernel(il,o,{axis:t,exclusive:e,reverse:r})}}),iD=de({cumsum_:function c0(n,t=0,e=!1,r=!1){const o={x:q(n,"x","cumsum")};return pe.runKernel(tc,o,{axis:t,exclusive:e,reverse:r})}}),aD=de({denseBincount_:function fC(n,t,e,r=!1){const s=q(n,"x","denseBincount"),o=q(t,"weights","denseBincount");return G("int32"===s.dtype,()=>`Error in denseBincount: input dtype must be int32, but got ${s.dtype}`),G(s.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${s.rank}.`),G(e>=0,()=>`size must be non-negative, but got ${e}.`),G(o.size===s.size||0===o.size,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${s.shape}, weights shape: ${o.shape}.`),pe.runKernel(ba,{x:s,weights:o},{size:e,binaryOutput:r})}}),d0=de({depthToSpace_:function u0(n,t,e="NHWC"){const r=q(n,"x","depthToSpace","float32"),s="NHWC"===e?r.shape[1]:r.shape[2],o="NHWC"===e?r.shape[2]:r.shape[3],l="NHWC"===e?r.shape[3]:r.shape[1];return G(t>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${t}`),G(s*t>=0,()=>`Negative dimension size caused by overflow when multiplying\n    ${s} and ${t}  for depthToSpace with input shape\n    ${r.shape}`),G(o*t>=0,()=>`Negative dimension size caused by overflow when multiplying\n    ${o} and ${t} for depthToSpace with input shape\n        ${r.shape}`),G(l%(t*t)==0,()=>`Dimension size must be evenly divisible by ${t*t} but is ${l} for depthToSpace with input shape ${r.shape}`),pe.runKernel(zo,{x:r},{blockSize:t,dataFormat:e})}}),Hd=de({depthwiseConv2d_:function pC(n,t,e,r,s="NHWC",o=[1,1],l){const u=q(n,"x","depthwiseConv2d","float32"),d=q(t,"filter","depthwiseConv2d","float32");let h=u,p=!1;3===u.rank&&(p=!0,h=tt(u,[1,u.shape[0],u.shape[1],u.shape[2]])),G(4===h.rank,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${h.rank}.`),G(4===d.rank,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${d.rank}.`);const g="NHWC"===s?h.shape[3]:h.shape[1];G(g===d.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${g}) must match the inChannels dimension in filter ${d.shape[2]}.`),Po("depthwiseConv2d",r,l);const _=pe.runKernel(_a,{x:h,filter:d},{strides:e,pad:r,dataFormat:s,dilations:o,dimRoundingMode:l});return p?tt(_,[_.shape[1],_.shape[2],_.shape[3]]):_}}),cD=de({diag_:function lD(n){const e={x:q(n,"x","diag")};return pe.runKernel(Yc,e)}}),dD=de({dilation2d_:function uD(n,t,e,r,s=[1,1],o="NHWC"){const l=q(n,"x","dilation2d"),u=q(t,"filter","dilation2d");G(3===l.rank||4===l.rank,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${l.rank}.`),G(3===u.rank,()=>`Error in dilation2d: filter must be rank 3, but got rank ${u.rank}.`),G("NHWC"===o,()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${o}`);let d=l,h=!1;3===l.rank&&(d=tt(l,[1,l.shape[0],l.shape[1],l.shape[2]]),h=!0),G(d.shape[3]===u.shape[2],()=>`Error in dilation2d:  input and filter must have the same depth: ${d.shape[3]} vs ${u.shape[2]}`);const y=pe.runKernel(Zc,{x:d,filter:u},{strides:e,pad:r,dilations:s});return h?tt(y,[y.shape[1],y.shape[2],y.shape[3]]):y}}),mC=de({equal_:function hD(n,t){let e=q(n,"a","equal","string_or_numeric"),r=q(t,"b","equal","string_or_numeric");return[e,r]=jt(e,r),Nn(e.shape,r.shape),pe.runKernel(Pi,{a:e,b:r})}}),Ac=de({where_:function fD(n,t,e){const r=q(t,"a","where"),s=q(e,"b","where"),o=q(n,"condition","where","bool"),l=Nn(Nn(o.shape,r.shape),s.shape),u=zd(o,l),d=zd(r,l),h=zd(s,l);return pe.runKernel(cu,{condition:u,t:d,e:h})}}),mD=de({divNoNan_:function pD(n,t){let e=q(n,"a","div"),r=q(t,"b","div");[e,r]=jt(e,r);const s=Hn(e,r),o=co(s),l=mC(r,o);return Ac(l,o,s)}}),zm=de({dot_:function Fl(n,t){const e=q(n,"t1","dot"),r=q(t,"t2","dot");G(!(1!==e.rank&&2!==e.rank||1!==r.rank&&2!==r.rank),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${e.rank} and ${r.rank}.`);const s=1===e.rank?e.size:e.shape[1],o=1===r.rank?r.size:r.shape[0];if(G(s===o,()=>`Error in dot: inner dimensions of inputs must match, but got ${s} and ${o}.`),1===e.rank&&1===r.rank){const l=tt(e,[1,-1]),u=tt(r,[-1,1]),d=Yn(l,u);return tt(d,[])}if(1===e.rank&&2===r.rank){const l=tt(e,[1,-1]),u=tt(r,[r.shape[0],r.shape[1]]),d=Yn(l,u);return tt(d,[d.size])}if(2===e.rank&&1===r.rank){const l=tt(r,[-1,1]),u=Yn(e,l);return tt(u,[u.size])}{const l=tt(r,[r.shape[0],r.shape[1]]);return Yn(e,l)}}}),Rc=de({einsum_:function gC(n,...t){const e=t.map((s,o)=>q(s,`tensors${o}`,"einsum"));return pe.runKernel(Jc,e,{equation:n})}}),Wm=de({elu_:function Hm(n){const e={x:q(n,"x","elu","float32")};return pe.runKernel(al,e)}}),yC=de({ensureShape_:function jm(n,t){const e=q(n,"x","ensureShape","string_or_numeric");if(!function In(n,t){if(n===t)return!0;if(null==n||null==t||n.length!==t.length)return!1;for(let e=0;e<n.length;e++)if(null!==n[e]&&null!==t[e]&&n[e]!==t[e])return!1;return!0}(e.shape,t))throw new Error(`EnsureShape: Shape of tensor ${e.shape} is not compatible with expected shape ${t}`);return n}}),h0=de({erf_:function $l(n){let t=q(n,"x","erf");return G("int32"===t.dtype||"float32"===t.dtype,()=>"Input dtype must be `int32` or `float32`."),"int32"===t.dtype&&(t=fr(t,"float32")),pe.runKernel(sc,{x:t})}});function Gm(n,t){for(let e=0;e<n.length;++e)if(n[n.length-e-1]!==t-1-e)return!1;return!0}function f0(n,t,e){const r=n.length+t.length,s=[];let o=0,l=0;for(let u=0;u<r;u++)-1===e.indexOf(u)?s.push(n[o++]):s.push(t[l++]);return s}function as(n,t){const e=[],r=n.length;for(let o=0;o<r;o++)-1===t.indexOf(o)&&e.push(n[o]);return[e,t.map(o=>n[o])]}function Yr(n,t){return f0(n,t.map(r=>1),t)}function _s(n,t,e){G(Gm(t,e),()=>`${n} supports only inner-most axes for now. Got axes ${t} and rank-${e} input.`)}function pr(n,t){if(Gm(n,t))return null;const e=[];for(let r=0;r<t;++r)-1===n.indexOf(r)&&e.push(r);return n.forEach(r=>e.push(r)),e}function na(n){return n.map((t,e)=>[e,t]).sort((t,e)=>t[1]-e[1]).map(t=>t[0])}function _r(n,t){const e=[];for(let r=t-n;r<t;++r)e.push(r);return e}const Pl=de({max_:function ku(n,t=null,e=!1){const s={x:q(n,"x","max")};return pe.runKernel("Max",s,{reductionIndices:t,keepDims:e})}}),yf=de({min_:function gf(n,t=null,e=!1){const s={x:q(n,"x","min")};return pe.runKernel("Min",s,{axis:t,keepDims:e})}}),Zn=de({sum_:function p0(n,t=null,e=!1){let r=q(n,"x","sum");return"bool"===r.dtype&&(r=fr(r,"int32")),pe.runKernel("Sum",{x:r},{axis:t,keepDims:e})}});function qm(n,t,e=null){if(0===n.rank)return uo(n);if(1!==n.rank&&null===e)return qm(tt(n,[-1]),t,e);if(1===n.rank||"number"==typeof e||Array.isArray(e)&&1===e.length){if(1===t)return Zn(uo(n),e);if(t===1/0)return Pl(uo(n),e);if(t===-1/0)return yf(uo(n),e);if("euclidean"===t||2===t)return ta(Zn(Md(uo(n),xn(2,"int32")),e));throw new Error(`Error in norm: invalid ord value: ${t}`)}if(Array.isArray(e)&&2===e.length){if(1===t)return Pl(Zn(uo(n),e[0]),e[1]-1);if(t===1/0)return Pl(Zn(uo(n),e[1]),e[0]);if(t===-1/0)return yf(Zn(uo(n),e[1]),e[0]);if("fro"===t||"euclidean"===t)return ta(Zn(Fo(n),e));throw new Error(`Error in norm: invalid ord value: ${t}`)}throw new Error(`Error in norm: invalid axis: ${e}`)}const Au=de({norm_:function Km(n,t="euclidean",e=null,r=!1){const s=qm(n=q(n,"x","norm"),t,e);let o=s.shape;if(r){const l=Tt(e,n.shape);o=Yr(s.shape,l)}return tt(s,o)}}),gD=de({euclideanNorm_:function vC(n,t=null,e=!1){return Au(n,"euclidean",t,e)}}),Ll=de({exp_:function bC(n){const e={x:q(n,"x","exp")};return pe.runKernel(Ho,e)}}),ra=de({expandDims_:function _C(n,t=0){const e=q(n,"x","expandDims","string_or_numeric");return G(t<=e.rank,()=>"Axis must be <= rank of the tensor"),pe.runKernel(xa,{input:e},{dim:t})}}),xC=de({expm1_:function m0(n){const e={x:q(n,"x","expm1")};return pe.runKernel(wa,e)}}),Ru=de({tile_:function Lo(n,t){const e=q(n,"x","tile","string_or_numeric");return G(e.rank===t.length,()=>`Error in transpose: rank of input ${e.rank} must match length of reps ${t}.`),pe.runKernel(sr,{x:e},{reps:t})}}),CC=de({eye_:function wC(n,t,e,r="float32"){null==t&&(t=n);const s=gn([n,t],r),o=n<=t?n:t;for(let u=0;u<o;++u)s.set(1,u,u);const l=tt(s.toTensor(),[n,t]);if(null==e)return l;if(1===e.length)return Ru(ra(l,0),[e[0],1,1]);if(2===e.length)return Ru(ra(ra(l,0),0),[e[0],e[1],1,1]);if(3===e.length)return Ru(ra(ra(ra(l,0),0),0),[e[0],e[1],e[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${e.length}D.`)}}),vf=de({floor_:function SC(n){const e={x:q(n,"x","floor","float32")};return pe.runKernel(fi,e)}}),y0=de({gather_:function g0(n,t,e=0,r=0){const s=q(n,"x","gather"),o=q(t,"indices","gather","int32");return pe.runKernel(To,{x:s,indices:o},{axis:e,batchDims:r})}}),bf=de({greater_:function EC(n,t){let e=q(n,"a","greater","string_or_numeric"),r=q(t,"b","greater","string_or_numeric");return[e,r]=jt(e,r),Nn(e.shape,r.shape),pe.runKernel(cl,{a:e,b:r})}}),b0=de({greaterEqual_:function v0(n,t){let e=q(n,"a","greaterEqual","string_or_numeric"),r=q(t,"b","greaterEqual","string_or_numeric");return[e,r]=jt(e,r),Nn(e.shape,r.shape),pe.runKernel(Bi,{a:e,b:r})}}),_f=de({imag_:function _0(n){const e={input:q(n,"input","imag")};return pe.runKernel(ts,e)}}),x0=de({isFinite_:function IC(n){const e={x:q(n,"x","isFinite")};return pe.runKernel(No,e)}}),DC=de({isInf_:function w0(n){const e={x:q(n,"x","isInf")};return pe.runKernel(Ui,e)}}),Xm=de({isNaN_:function sa(n){const e={x:q(n,"x","isNaN")};return pe.runKernel(Sa,e)}}),C0=de({leakyRelu_:function TC(n,t=.2){const r={x:q(n,"x","leakyRelu")};return pe.runKernel(pi,r,{alpha:t})}}),xf=de({less_:function yD(n,t){let e=q(n,"a","less","string_or_numeric"),r=q(t,"b","less","string_or_numeric");return[e,r]=jt(e,r),Nn(e.shape,r.shape),pe.runKernel(eu,{a:e,b:r})}}),Ym=de({lessEqual_:function NC(n,t){let e=q(n,"a","lessEqual","string_or_numeric"),r=q(t,"b","lessEqual","string_or_numeric");return[e,r]=jt(e,r),Nn(e.shape,r.shape),pe.runKernel(jn,{a:e,b:r})}});function kC(n,t,e){if(e<=0)throw new Error("The number of values should be positive.");return pe.runKernel(ul,{},{start:n,stop:t,num:e})}const AC=de({localResponseNormalization_:function Zm(n,t=5,e=1,r=1,s=.5){const o=q(n,"x","localResponseNormalization");G(4===o.rank||3===o.rank,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank ${o.rank}.`),G(kn(t),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${t}.`);let l=o,u=!1;3===o.rank&&(u=!0,l=tt(o,[1,o.shape[0],o.shape[1],o.shape[2]]));const p=pe.runKernel("LRN",{x:l},{depthRadius:t,bias:e,alpha:r,beta:s});return u?tt(p,[p.shape[1],p.shape[2],p.shape[3]]):p}}),Bl=de({log_:function RC(n){const e={x:q(n,"x","log","float32")};return pe.runKernel(dl,e)}}),Wd=de({log1p_:function Qm(n){const e={x:q(n,"x","log1p")};return pe.runKernel(Wo,e)}}),si=de({neg_:function vD(n){const e={x:q(n,"x","neg")};return pe.runKernel("Neg",e)}}),Jm=de({softplus_:function bD(n){const e={x:q(n,"x","softplus")};return pe.runKernel(_l,e)}}),E0=de({logSigmoid_:function S0(n){const t=q(n,"x","logSigmoid");return Wa(r=>({value:si(Jm(si(r))),gradFunc:l=>Nt(l,Ol(si(r)))}))(t)}}),eg=de({logSoftmax_:function I0(n,t=-1){const e=q(n,"logits","logSoftmax");if(-1===t&&(t=e.rank-1),t!==e.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${e.rank} and axis was ${t}`);return Wa((s,o)=>{const u=Pl(s,t,!0),d=fn(s,u),h=fn(fr(d,"float32"),Bl(Zn(Ll(d),t,!0)));return o([h]),{value:h,gradFunc:(g,y)=>{const[b]=y,I=Ll(b);return fn(g,Nt(Zn(g,t,!0),I))}}})(e)}}),jd=de({logSumExp_:function Xa(n,t=null,e=!1){const r=q(n,"x","logSumExp"),s=Tt(t,r.shape),o=Pl(r,s,!0),l=fn(r,o),u=Ll(l),d=Zn(u,s),h=Bl(d),p=rn(tt(o,h.shape),h);if(e){const g=Yr(p.shape,s);return tt(p,g)}return p}}),Vl=de({logicalAnd_:function wf(n,t){const e=q(n,"a","logicalAnd","bool"),r=q(t,"b","logicalAnd","bool");return Nn(e.shape,r.shape),pe.runKernel(Ur,{a:e,b:r})}}),Cf=de({logicalNot_:function MC(n){const e={x:q(n,"x","logicalNot","bool")};return pe.runKernel(jo,e)}}),T0=de({logicalOr_:function D0(n,t){const e=q(n,"a","logicalOr","bool"),r=q(t,"b","logicalOr","bool");return Nn(e.shape,r.shape),pe.runKernel(zi,{a:e,b:r})}}),Gd=de({logicalXor_:function OC(n,t){const e=q(n,"a","logicalXor","bool"),r=q(t,"b","logicalXor","bool");return Nn(e.shape,r.shape),Vl(T0(n,t),Cf(Vl(n,t)))}}),Sf=2147483648,tg=de({searchSorted_:function _D(n,t,e="left"){const r=q(n,"sortedSequence","searchSorted"),s=q(t,"values","searchSorted"),l=s.shape[s.shape.length-1],u=tt(r,[-1,r.shape[r.shape.length-1]]),d=tt(s,[-1,l]);if(u.rank<2)throw new Error("Sorted input argument must be at least 2-dimensional");if(u.shape[0]!==d.shape[0])throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");if(Ee(d.shape)>=Sf)throw new Error(`values tensor size must less than ${Sf}`);if(u.shape[1]>=Sf)throw new Error(`trailing dim_size must less than ${Sf} for int32 output type, was ${u.shape[1]}`);return pe.runKernel(Na,{sortedSequence:u,values:d},{side:e})}});function xD(n,t){return tg(n,t,"left")}const N0=de({maxPool_:function FC(n,t,e,r,s){const o=q(n,"x","maxPool");let u=o,d=!1;3===o.rank&&(d=!0,u=tt(o,[1,o.shape[0],o.shape[1],o.shape[2]])),G(4===u.rank,()=>`Error in maxPool: input must be rank 4 but got rank ${u.rank}.`),G(Ns(e,1),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${e} and dilations '1'`),Po("maxPool",r,s);const g=pe.runKernel(hn,{x:u},{filterSize:t,strides:e,pad:r,dimRoundingMode:s});return d?tt(g,[g.shape[1],g.shape[2],g.shape[3]]):g}}),k0=de({maxPool3d_:function $C(n,t=[1,1,1],e,r,s,o="NDHWC"){const l=q(n,"x","maxPool3d");let u=l,d=!1;4===l.rank&&(d=!0,u=tt(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]])),G(5===u.rank,()=>`Error in maxPool3d: x must be rank 5 but got rank ${u.rank}.`),G("NDHWC"===o,()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${o}`),Po("maxPool3d",r,s);const g=pe.runKernel(yd,{x:u},{filterSize:t,strides:e,pad:r,dimRoundingMode:s,dataFormat:o});return d?tt(g,[g.shape[1],g.shape[2],g.shape[3],g.shape[4]]):g}}),PC=de({maxPoolWithArgmax_:function A0(n,t,e,r,s=!1){const l={x:q(n,"x","maxPoolWithArgmax")},d=pe.runKernel(ac,l,{filterSize:t,strides:e,pad:r,includeBatchInIndex:s});return{result:d[0],indexes:d[1]}}}),Ef=de({mean_:function ng(n,t=null,e=!1){const s={x:q(n,"x","mean")};return pe.runKernel(ru,s,{axis:t,keepDims:e})}});function Mc(n,t="float32"){if(Sr(n),"complex64"===t){const r=Mc(n,"float32"),s=Mc(n,"float32");return ti(r,s)}const e=er(Ee(n),t);return pe.makeTensor(e,n,t)}function Oc(n,t="float32"){if(Sr(n),"complex64"===t){const r=Oc(n,"float32"),s=Mc(n,"float32");return ti(r,s)}const e=_o(Ee(n),t);return pe.makeTensor(e,n,t)}function LC(n,t,{indexing:e="xy"}={}){if("xy"!==e&&"ij"!==e)throw new TypeError(`${e} is not a valid third argument to meshgrid`);if(void 0===n)return[];let r=q(n,"x","meshgrid",n instanceof Rr?n.dtype:"float32");if(void 0===t)return[r];let s=q(t,"y","meshgrid",t instanceof Rr?t.dtype:"float32");const o=Ee(r.shape),l=Ee(s.shape);return"xy"===e?(r=tt(r,[1,-1]),s=tt(s,[-1,1]),[Yn(Oc([l,1],r.dtype),r),Yn(s,Oc([1,o],s.dtype))]):(r=tt(r,[-1,1]),s=tt(s,[1,-1]),[Yn(r,Oc([1,l],r.dtype)),Yn(Oc([o,1],s.dtype),s)])}const If=de({minimum_:function BC(n,t){let e=q(n,"a","minimum"),r=q(t,"b","minimum");return[e,r]=jt(e,r),"bool"===e.dtype&&(e=fr(e,"int32"),r=fr(r,"int32")),Nn(e.shape,r.shape),pe.runKernel(Hi,{a:e,b:r})}}),Fc=de({mirrorPad_:function Df(n,t,e){G("reflect"===e||"symmetric"===e,()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${e}.`);const r=q(n,"x","mirrorPad");if(0===r.rank)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");G(t.length===r.rank,()=>`Padding doesn't match input. Must be ${r.rank}. Got ${t.length}.`);const s="reflect"===e?1:0;for(let u=0;u<r.rank;u++)G(2===t[u].length,()=>"Invalid number of paddings. Must be length of 2 each."),G(t[u][0]>=0&&t[u][0]<=r.shape[u]-s&&t[u][1]>=0&&t[u][1]<=r.shape[u]-s,()=>`Padding in dimension ${u} cannot be greater than or equal to ${r.shape[u]-s} or less than 0 for input of shape ${r.shape}`);return pe.runKernel(ms,{x:r},{paddings:t,mode:e})}}),Kd=de({mod_:function wD(n,t){let e=q(n,"a","mod"),r=q(t,"b","mod");return[e,r]=jt(e,r),pe.runKernel(st,{a:e,b:r})}}),UC=de({moments_:function VC(n,t=null,e=!1){const r=Tt(t,(n=q(n,"x","moments")).shape),s=Ef(n,r,e);let o=s.shape;e||(o=Yr(s.shape,r));const l=Fo(fn(fr(n,"float32"),tt(s,o)));return{mean:s,variance:Ef(l,r,e)}}}),zC=de({multiRNNCell_:function rg(n,t,e,r){const s=q(t,"data","multiRNNCell"),o=Ed(e,"c","multiRNNCell"),l=Ed(r,"h","multiRNNCell");let u=s;const d=[];for(let g=0;g<n.length;g++){const y=n[g](u,o[g],l[g]);d.push(y[0]),d.push(y[1]),u=y[1]}const h=[],p=[];for(let g=0;g<d.length;g+=2)h.push(d[g]),p.push(d[g+1]);return[h,p]}}),qd=de({multinomial_:function oa(n,t,e,r=!1){const s=q(n,"logits","multinomial"),o=s.size,l=s.rank;if(o<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${o}.`);if(l>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${l}`);e=e||Math.random();const d={logits:1===l?tt(s,[1,-1]):s},p=pe.runKernel(_n,d,{numSamples:t,seed:e,normalized:r});return 1===l?tt(p,[p.size]):p}}),Ul=de({notEqual_:function Hs(n,t){let e=q(n,"a","notEqual","string_or_numeric"),r=q(t,"b","notEqual","string_or_numeric");return[e,r]=jt(e,r),Nn(e.shape,r.shape),pe.runKernel(ur,{a:e,b:r})}}),oi=de({oneHot_:function Tf(n,t,e=1,r=0,s="int32"){if(t<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${t}`);const l={indices:q(n,"indices","oneHot","int32")};return pe.runKernel(Go,l,{dtype:s,depth:t,onValue:e,offValue:r})}}),Mu=de({onesLike_:function sg(n){const e={x:q(n,"x","onesLike")};return pe.runKernel(Ao,e)}}),Fu=de({outerProduct_:function Ou(n,t){const e=q(n,"v1","outerProduct"),r=q(t,"v2","outerProduct");G(1===e.rank&&1===r.rank,()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${e.rank} and ${r.rank}.`);const s=tt(e,[-1,1]),o=tt(r,[1,-1]);return Yn(s,o)}}),ia=de({pad_:function $u(n,t,e=0){const r=q(n,"x","pad");if(0===r.rank)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");return pe.runKernel(ou,{x:r},{paddings:t,constantValue:e})}}),Lu=de({pad1d_:function Pu(n,t,e=0){return G(2===t.length,()=>"Invalid number of paddings. Must be length of 2."),ia(n,[t],e)}}),Vu=de({pad2d_:function Bu(n,t,e=0){return G(2===t.length&&2===t[0].length&&2===t[1].length,()=>"Invalid number of paddings. Must be length of 2 each."),ia(n,t,e)}}),M0=de({pad3d_:function R0(n,t,e=0){return G(3===t.length&&2===t[0].length&&2===t[1].length&&2===t[2].length,()=>"Invalid number of paddings. Must be length of 2 each."),ia(n,t,e)}}),F0=de({pad4d_:function O0(n,t,e=0){return G(4===t.length&&2===t[0].length&&2===t[1].length&&2===t[2].length&&2===t[3].length,()=>"Invalid number of paddings. Must be length of 2 each."),ia(n,t,e)}}),og=de({spaceToBatchND_:function $0(n,t,e){const r=q(n,"x","spaceToBatchND");return G(r.rank>=1+t.length,()=>`input rank ${r.rank} should be > than [blockShape] ${t.length}`),G(e.length===t.length,()=>`paddings.shape[0] ${e.length} must be equal to [blockShape] ${t.length}`),G(r.shape.reduce((l,u,d)=>d>0&&d<=t.length?l&&(u+e[d-1][0]+e[d-1][1])%t[d-1]==0:l,!0),()=>`input spatial dimensions ${r.shape.slice(1)} with paddings ${e.toString()} must be divisible by blockShapes ${t.toString()}`),pe.runKernel(fc,{x:r},{blockShape:t,paddings:e})}}),HC=de({pool_:function P0(n,t,e,r,s,o,l){null==s&&(s=[1,1]),null==o&&(o=1),0===r&&(r="valid");const u=q(n,"x","maxPool");let d=u,h=!1;3===u.rank&&(h=!0,d=tt(u,[1,u.shape[0],u.shape[1],u.shape[2]])),G(Ns(o,s),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${o} and dilations '${s}'`);const p=$o(d.shape,t,o,s,r),g=[p.dilationHeight,p.dilationWidth];let y;y="same"===r?function B0(n,t){const r=n.map((l,u)=>l+(l-1)*(t[u]-1)).map(l=>l-1),s=r.map(l=>Math.floor(l/2)),o=r.map((l,u)=>l-s[u]);return r.map((l,u)=>[s[u],o[u]])}([p.filterHeight,p.filterWidth],g):[[0,0],[0,0]];const b=1===g[0]&&1===g[1],[_,I]=function L0(n,t,e){const r=e.map(p=>p[0]),s=e.map(p=>p[1]),o=n.concat(r,s),l=t.map((p,g)=>(p-o[g]%p)%p),u=s.map((p,g)=>p+l[g]),d=t.map((p,g)=>[r[g],u[g]]),h=t.map((p,g)=>[0,l[g]]);return[d,h]}([p.inHeight,p.inWidth],g,y),S=b?r:"valid",T=b?d:og(d,g,_),V=("avg"===e?()=>Kv(T,t,o,S,l):()=>N0(T,t,o,S,l))(),U=b?V:Jw(V,g,I);return h?tt(U,[U.shape[1],U.shape[2],U.shape[3]]):U}}),V0=de({prelu_:function WC(n,t){const e=q(n,"x","prelu"),r=q(t,"alpha","prelu");return pe.runKernel(Nr,{x:e,alpha:r})}}),GC=de({prod_:function jC(n,t=null,e=!1){let r=q(n,"x","prod");return"bool"===r.dtype&&(r=fr(r,"int32")),pe.runKernel(Ys,{x:r},{axis:t,keepDims:e})}}),ag=de({raggedGather_:function ig(n,t,e,r){const s=n.map((p,g)=>q(p,`tensors${g}`,"raggedGather","int32")),o=q(t,"paramsDenseValues","raggedGather"),l=q(e,"indices","raggedGather","int32"),h=pe.runKernel(ml,{paramsNestedSplits:s,paramsDenseValues:o,indices:l},{outputRaggedRank:r});return{outputNestedSplits:h.slice(0,h.length-1),outputDenseValues:h[h.length-1]}}}),Nf=de({raggedRange_:function KC(n,t,e){const r=q(n,"starts","raggedRange"),s=q(t,"limits","raggedRange",r.dtype),o=q(e,"deltas","raggedRange",r.dtype),u=pe.runKernel(so,{starts:r,limits:s,deltas:o});return{rtNestedSplits:u[0],rtDenseValues:u[1]}}}),lg=de({raggedTensorToTensor_:function kf(n,t,e,r,s){const o=q(n,"shape","raggedTensorToTensor","int32"),l=q(t,"values","raggedTensorToTensor"),u=q(e,"defaultValue","raggedTensorToTensor",l.dtype),d=r.map((g,y)=>q(g,`tensors${y}`,"raggedTensorToTensor","int32"));return pe.runKernel(rs,{shape:o,values:l,defaultValue:u,rowPartitionTensors:d},{rowPartitionTypes:s})}}),cg=de({rand_:function qC(n,t,e){Sr(n);const r=Ee(n);let s=null;if(null==e||"float32"===e)s=new Float32Array(r);else if("int32"===e)s=new Int32Array(r);else{if("bool"!==e)throw new Error(`Unknown data type ${e}`);s=new Uint8Array(r)}for(let o=0;o<r;o++)s[o]=t();return pe.makeTensor(s,n,e)}});var Uu=Y(340);class Af{constructor(t,e,r,s,o){this.mean=t,this.stdDev=e,this.dtype=r,this.nextVal=NaN,this.truncated=s,this.truncated&&(this.upper=this.mean+2*this.stdDev,this.lower=this.mean-2*this.stdDev);const l=o||Math.random();this.random=Uu.alea(l.toString())}nextValue(){if(!isNaN(this.nextVal)){const s=this.nextVal;return this.nextVal=NaN,s}let t,e,r=!1;for(;!r;){let s,o,l;do{s=2*this.random()-1,o=2*this.random()-1,l=s*s+o*o}while(l>=1||0===l);const u=Math.sqrt(-2*Math.log(l)/l);t=this.mean+this.stdDev*s*u,e=this.mean+this.stdDev*o*u,(!this.truncated||this.isValidTruncated(t))&&(r=!0)}return(!this.truncated||this.isValidTruncated(e))&&(this.nextVal=this.convertValue(e)),this.convertValue(t)}convertValue(t){return null==this.dtype||"float32"===this.dtype?t:Math.round(t)}isValidTruncated(t){return t<=this.upper&&t>=this.lower}}class XC{constructor(t,e,r,s){this.alpha=t,this.beta=1/e,this.dtype=r;const o=s||Math.random();this.randu=Uu.alea(o.toString()),this.randn=new Af(0,1,r,!1,this.randu()),this.d=t<1?t+2/3:t-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let t,e,r,s,o,l;for(;;){do{s=this.randn.nextValue(),l=1+this.c*s}while(l<=0);if(l*=l*l,t=s*s,e=1-.331*t*t,r=.5*t+this.d*(1-l+Math.log(l)),o=this.randu(),o<e||Math.log(o)<r)break}return l*=1/this.beta*this.d,this.alpha<1&&(l*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(l)}convertValue(t){return"float32"===this.dtype?t:Math.round(t)}}class ug{constructor(t=0,e=1,r,s){if(this.canReturnFloat=()=>null==this.dtype||"float32"===this.dtype,this.min=t,this.range=e-t,this.dtype=r,null==s&&(s=Math.random()),"number"==typeof s&&(s=s.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${t} - ${e} <= 1 and dtype is not float`);this.random=Uu.alea(s)}convertValue(t){return this.canReturnFloat()?t:Math.round(t)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}const W0=de({randomGamma_:function H0(n,t,e=1,r="float32",s){if(Sr(n),null==e&&(e=1),null==r&&(r="float32"),"float32"!==r&&"int32"!==r)throw new Error(`Unsupported data type ${r}`);const o=new XC(t,e,r,s),l=gn(n,r);for(let u=0;u<l.values.length;u++)l.values[u]=o.nextValue();return l.toTensor()}}),j0=de({randomNormal_:function JC(n,t=0,e=1,r,s){if(Sr(n),null!=r&&"bool"===r)throw new Error(`Unsupported data type ${r}`);const o=new Af(t,e,r,!1,s),l=gn(n,r);for(let u=0;u<l.values.length;u++)l.values[u]=o.nextValue();return l.toTensor()}}),t1=de({randomStandardNormal_:function e1(n,t,e){if(null!=t&&"bool"===t)throw new Error(`Unsupported data type ${t}`);return j0(n,0,1,t,e)}}),Yd=de({randomUniform_:function G0(n,t=0,e=1,r="float32",s){Sr(n);const o=gn(n,r),l=new ug(t,e,null,s);for(let u=0;u<o.values.length;u++)o.values[u]=l.nextValue();return o.toTensor()}}),q0=de({randomUniformInt_:function K0(n,t,e,r){return Yd(n,t,e,"int32",r)}});function zu(n,t,e=1,r="float32"){if(0===e)throw new Error("Cannot have a step of zero");return pe.runKernel(au,{},{start:n,stop:t,step:e,dtype:r})}const Hu=de({real_:function X0(n){const e={input:q(n,"input","real")};return pe.runKernel(lu,e)}}),Z0=de({reciprocal_:function Y0(n){const e={x:q(n,"x","reciprocal")};return pe.runKernel(Ta,e)}}),dg=de({relu_:function Q0(n){const e={x:q(n,"x","relu")};return pe.runKernel(mi,e)}}),J0=de({relu6_:function n1(n){const e={x:q(n,"x","relu6")};return pe.runKernel(gl,e)}}),$c=de({reverse_:function eb(n,t){const r={x:q(n,"x","reverse")};return pe.runKernel(yl,r,{dims:t})}}),tb=de({reverse1d_:function ls(n){const t=q(n,"x","reverse");return G(1===t.rank,()=>`Error in reverse1D: x must be rank 1 but got rank ${t.rank}.`),$c(t,0)}}),s1=de({reverse2d_:function r1(n,t){const e=q(n,"x","reverse");return G(2===e.rank,()=>`Error in reverse2D: x must be rank 2 but got rank ${e.rank}.`),$c(e,t)}}),o1=de({reverse3d_:function nb(n,t){const e=q(n,"x","reverse");return G(3===e.rank,()=>`Error in reverse3D: x must be rank 3 but got rank ${e.rank}.`),$c(e,t)}}),sb=de({reverse4d_:function rb(n,t){const e=q(n,"x","reverse");return G(4===e.rank,()=>`Error in reverse4D: x must be rank 4 but got rank ${e.rank}.`),$c(e,t)}}),ob=de({round_:function Wu(n){const e={x:q(n,"x","round")};return pe.runKernel(vl,e)}}),ib=de({rsqrt_:function a1(n){const e={x:q(n,"x","rsqrt","float32")};return pe.runKernel(bl,e)}}),ab=de({selu_:function l1(n){const e={x:q(n,"x","selu")};return pe.runKernel(ka,e)}}),lb=de({separableConv2d_:function CD(n,t,e,r,s,o=[1,1],l="NHWC"){const u=q(n,"x","separableConv2d"),d=q(t,"depthwiseFilter","separableConv2d"),h=q(e,"pointwiseFilter","separableConv2d");let p=u,g=!1;if(3===u.rank&&(g=!0,p=tt(u,[1,u.shape[0],u.shape[1],u.shape[2]])),"NCHW"===l)throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");G(4===p.rank,()=>`Error in separableConv2d: input must be rank 4, but got rank ${p.rank}.`),G(4===d.rank,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${d.rank}.`),G(4===h.rank,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${d.rank}.`),G(1===h.shape[0],()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${h.shape[0]}.`),G(1===h.shape[1],()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${h.shape[1]}.`);const y=d.shape[2],b=d.shape[3];G(h.shape[2]===y*b,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${y*b}, but got ${h.shape[2]}.`);const _=Hd(p,d,r,s,l,o),S=ff(_,h,1,"valid",l);return g?tt(S,[S.shape[1],S.shape[2],S.shape[3]]):S}});function ii(){return(ii=xe(function*(n,t){const e=q(n,"x","setdiff1d"),r=q(t,"y","setdiff1d");G(e.dtype===r.dtype,()=>`x and y should have the same dtype, but got x (${e.dtype}) and y (${r.dtype}).`),G(1===e.rank,()=>`x should be 1D tensor, but got x (${e.shape}).`),G(1===r.rank,()=>`y should be 1D tensor, but got y (${r.shape}).`);const s=yield e.data(),o=yield r.data(),l=new Set(o);let u=0;for(let p=0;p<s.length;p++)l.has(s[p])||u++;const d=new zr([u],e.dtype),h=new zr([u],"int32");for(let p=0,g=0;p<s.length;p++)l.has(s[p])||(d.values[g]=s[p],h.values[g]=p,g++);return[d.toTensor(),h.toTensor()]})).apply(this,arguments)}const c1=function cb(n,t){return ii.apply(this,arguments)},aa=de({sign_:function u1(n){const e={x:q(n,"x","sign")};return pe.runKernel(Aa,e)}}),Ti=de({sin_:function Di(n){const e={x:q(n,"x","sin","float32")};return pe.runKernel($s,e)}}),db=de({sinh_:function ub(n){const e={x:q(n,"x","sinh")};return pe.runKernel(Fn,e)}}),h1=de({slice1d_:function d1(n,t,e){const r=q(n,"x","slice1d");return G(1===r.rank,()=>`slice1d expects a rank-1 tensor, but got a rank-${r.rank} tensor`),Pn(r,[t],[e])}}),p1=de({slice2d_:function f1(n,t,e){const r=q(n,"x","slice2d");return G(2===r.rank,()=>`slice2d expects a rank-2 tensor, but got a rank-${r.rank} tensor`),Pn(r,t,e)}}),Zd=de({slice3d_:function hg(n,t,e){const r=q(n,"x","slice3d");return G(3===r.rank,()=>`slice3d expects a rank-3 tensor, but got a rank-${r.rank} tensor`),Pn(r,t,e)}}),hb=de({slice4d_:function m1(n,t,e){const r=q(n,"x","slice4d");return G(4===r.rank,()=>`slice4d expects a rank-4 tensor, but got a rank-${r.rank} tensor`),Pn(r,t,e)}}),fb=de({softmax_:function g1(n,t=-1){const e=q(n,"logits","softmax","float32");if(-1===t&&(t=e.rank-1),t!==e.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${e.rank} and dim was ${t}`);return pe.runKernel(qo,{logits:e},{dim:t})}}),ju=de({fft_:function pb(n){return G("complex64"===n.dtype,()=>`The dtype for tf.spectral.fft() must be complex64 but got ${n.dtype}.`),pe.runKernel("FFT",{input:n})}}),Qd=de({ifft_:function y1(n){return G("complex64"===n.dtype,()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${n.dtype}.`),pe.runKernel(Ca,{input:n})}}),Rf=de({irfft_:function mb(n){const t=n.shape[n.shape.length-1],e=n.size/t;let r;if(t<=2){const s=tt(n,[e,t]);r=Qd(s)}else{const s=[e,2*(t-1)],o=tt(Hu(n),[e,t]),l=tt(_f(n),[e,t]),u=$c(Pn(o,[0,1],[e,t-2]),1),d=Nt($c(Pn(l,[0,1],[e,t-2]),1),xn(-1)),h=zs([o,u],1),p=zs([l,d],1),g=tt(ti(h,p),[s[0],s[1]]);r=Qd(g)}if(r=Hu(r),3===n.rank&&0!==n.shape[0]){const s=r,o=n.shape[0];r=tt(r,[o,r.shape[0]/o,r.shape[1]]),s.dispose()}return r}}),Gu=de({split_:function fg(n,t,e=0){const s={x:q(n,"x","split")};return pe.runKernel(Ki,s,{numOrSizeSplits:t,axis:e})}}),Mf=de({rfft_:function gb(n,t){G("float32"===n.dtype,()=>`The dtype for rfft() must be real value but got ${n.dtype}`);let e=n.shape[n.shape.length-1];const r=n.size/e;let s;if(null!=t&&t<e){const _=n.shape.map(S=>0),I=n.shape.map(S=>S);I[n.shape.length-1]=t,s=Pn(n,_,I),e=t}else if(null!=t&&t>e){const _=n.shape.map(I=>I);_[n.shape.length-1]=t-e,s=zs([n,Mc(_)],n.shape.length-1),e=t}else s=n;const o=co(s),l=tt(ti(s,o),[r,e]),u=ju(l),d=Math.floor(e/2)+1,h=Hu(u),p=_f(u),g=Gu(h,[d,e-d],h.shape.length-1),y=Gu(p,[d,e-d],p.shape.length-1),b=s.shape.slice();return b[s.shape.length-1]=d,tt(ti(g[0],y[0]),b)}}),pg=de({squaredDifference_:function yb(n,t){let e=q(n,"a","squaredDifference"),r=q(t,"b","squaredDifference");return[e,r]=jt(e,r),Nn(e.shape,r.shape),pe.runKernel(M,{a:e,b:r},{})}}),Ku=de({squeeze_:function vb(n,t){const e=q(n,"x","squeeze","string_or_numeric");return tt(e,St(e.shape,t).newShape)}}),Ya=de({stack_:function bb(n,t=0){const e=Ed(n,"tensors","stack","string_or_numeric");return G(e.length>=1,()=>"Pass at least one tensor to tf.stack"),e.length>0&&G(t<=e[0].rank,()=>"Axis must be <= rank of the tensor"),pe.runKernel(su,e,{axis:t})}}),_b=de({step_:function v1(n,t=0){const r={x:q(n,"x","step")};return pe.runKernel(Zo,r,{alpha:t})}}),_1=de({stridedSlice_:function b1(n,t,e,r,s=0,o=0,l=0,u=0,d=0){const p={x:q(n,"x","stridedSlice","string_or_numeric")};return pe.runKernel(Pe,p,{begin:t,end:e,strides:r,beginMask:s,endMask:o,ellipsisMask:l,newAxisMask:u,shrinkAxisMask:d})}}),w1=de({tan_:function x1(n){const e={x:q(n,"x","tan","float32")};return pe.runKernel(Rn,e)}});function ho(n,t){Bt(n);const e=Sl(n,t);if(1!==e.length)throw new Error("tensor1d() requires values to be a flat/TypedArray");return El(n,null,e,t)}function qu(n,t,e){if(Bt(n),null!=t&&2!==t.length)throw new Error("tensor2d() requires shape to have two numbers");const r=Sl(n,e);if(2!==r.length&&1!==r.length)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return El(n,t,r,e)}function C1(n,t,e){if(Bt(n),null!=t&&4!==t.length)throw new Error("tensor4d() requires shape to have four numbers");const r=Sl(n,e);if(4!==r.length&&1!==r.length)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return El(n,t,r,e)}function S1(n,t,e){if(Bt(n),null!=t&&5!==t.length)throw new Error("tensor5d() requires shape to have five numbers");const r=Sl(n,e);if(5!==r.length&&1!==r.length)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return El(n,t,r,e)}function E1(n,t,e){if(Bt(n),null!=t&&6!==t.length)throw new Error("tensor6d() requires shape to have six numbers");const r=Sl(n,e);if(6!==r.length&&1!==r.length)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return El(n,t=t||r,r,e)}function xb(n,t,e){const r=t.rank>1?t.shape[t.rank-1]:1,s=t.rank>1?t.rank-1:1,o=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${e.shape}, indices.shape: ${t.shape}, shape: ${n}, sliceDim: ${r}, and batchDim: ${s}.`;if(e.rank<s)throw new Error(o+` update.rank < ${s}. `);if(n.length<r+(e.rank-s))throw new Error(o+` Output shape length < ${r+(e.rank-s)}`);if(e.rank!==s+n.length-r)throw new Error(o+" update.rank != "+(s+n.length-r));for(let l=0;l<s;++l)if(e.shape[l]!==t.shape[l])throw new Error(o+` updates.shape[${l}] (${e.shape[l]}) != indices.shape[${l}] (${t.shape[l]}).`);for(let l=0;l<e.rank-s;++l)if(e.shape[l+s]!==n[l+r])throw new Error(o+` updates.shape[${l+s}] (${e.shape[l+s]}) != shape[${l+s}] (${n[l+s]})`)}function mg(n,t,e){if(t.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${t.rank}.`);if(n.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${n.rank}.`);if("int32"!==t.dtype)throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${t.dtype}`);if(e.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${e}`);if(0===e.length){if(0===t.size)throw new Error(`Indices specified for empty output. indices shape: ${t.shape}`);if(0===n.size)throw new Error(`Updates specified for empty output. updates shape: ${n.shape}`)}xb(e,t,n)}function Pc(n,t,e){const r=t.shape.length,s=r>1?t.shape[r-1]:1,o=e.length;let l=1;for(let g=s;g<o;++g)l*=e[g];const u=s<1?1:s;return{sliceRank:s,numUpdates:Ee(t.shape)/u,sliceSize:l,strides:[...Wt(e.slice(0,s)),1],outputSize:Ee(e)}}const D1=de({tensorScatterUpdate_:function I1(n,t,e){const r=q(n,"tensor","tensorScatterupdate"),s=q(t,"indices","tensorScatterupdate","int32"),o=q(e,"updates","tensorScatterupdate");if(mg(o,s,r.shape),r.dtype!==o.dtype)throw new Error(`tensor and updates must have the same dtype, instead they are ${r.dtype} and ${o.dtype}.`);return pe.runKernel(uc,{tensor:r,indices:s,updates:o},{})}}),wb=de({topk_:function T1(n,t=1,e=!0){const r=q(n,"x","topk");if(0===r.rank)throw new Error("topk() expects the input to be of rank 1 or higher");const s=r.shape[r.shape.length-1];if(t<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${t}`);if(t>s)throw new Error(`'k' passed to topk() must be <= the last dimension (${s}) but got ${t}`);const o={x:r},l={k:t,sorted:e},[u,d]=pe.runKernel($n,o,l);return{values:u,indices:d}}}),Sb=de({truncatedNormal_:function Cb(n,t=0,e=1,r,s){if(Sr(n),null!=r&&"bool"===r)throw new Error("Unsupported data type $ { dtype }");const o=new Af(t,e,r,!0,s),l=gn(n,r);for(let u=0;u<l.values.length;u++)l.values[u]=o.nextValue();return l.toTensor()}}),Ib=de({unique_:function Eb(n,t=0){const e=q(n,"x","unique","string_or_numeric");G(e.rank>0,()=>"The input tensor must be at least 1D");const r={x:e},s={axis:t},[o,l]=pe.runKernel(gs,r,s);return{values:o,indices:l}}}),Tb=de({unsortedSegmentSum_:function Db(n,t,e){const r=q(n,"x","unsortedSegmentSum"),s=q(t,"segmentIds","unsortedSegmentSum","int32");return G(kn(e),()=>"numSegments must be of dtype int"),pe.runKernel(Zs,{x:r,segmentIds:s},{numSegments:e})}}),zl=de({unstack_:function Nb(n,t=0){const e=q(n,"x","unstack","string_or_numeric");return G(t>=-e.shape.length&&t<e.shape.length,()=>`Axis = ${t} is not in [-${e.shape.length}, ${e.shape.length})`),pe.runKernel(ss,{value:e},{axis:t})}});function kb(n,t){return tg(n,t,"right")}function Ab(n,t=!0,e,r){return pe.makeVariable(n,t,e,r)}function Za(n,t){const e=[];for(let o=0;o<t.length;o++)t[o]&&e.push(o);const r=gn(n,"int32"),s=gn([e.length,n.length],"int32");for(let o=0;o<e.length;o++){const l=r.indexToLoc(e[o]);s.values.set(l,o*n.length)}return s.toTensor()}function gg(){return(gg=xe(function*(n){const t=q(n,"condition","whereAsync","bool"),e=yield t.data(),r=Za(t.shape,e);return n!==t&&t.dispose(),r})).apply(this,arguments)}const Lc=function N1(n){return gg.apply(this,arguments)};function Jd(){return(Jd=xe(function*(n,t,e){const r=q(n,"tensor","boolMask"),s=q(t,"mask","boolMask","bool"),o=null==e?0:e,l=s.rank,u=r.shape;G(l>0,()=>"mask cannot be scalar"),bn(u.slice(o,o+l),s.shape,"mask's shape must match the first K dimensions of tensor's shape,");let d=1;for(let I=o;I<o+l;I++)d*=u[I];const h=u.slice(0,o).concat([d],u.slice(o+l)),p=tt(r,h),g=tt(s,[-1]),y=yield Lc(g),b=Ku(y,[1]),_=y0(p,b,o);return n!==r&&r.dispose(),t!==s&&s.dispose(),b.dispose(),p.dispose(),g.dispose(),y.dispose(),_})).apply(this,arguments)}const ED=function SD(n,t,e){return Jd.apply(this,arguments)},Of=de({transpose_:function Rb(n,t,e){const r=q(n,"x","transpose");if(null==t&&(t=r.shape.map((l,u)=>u).reverse()),G(r.rank===t.length,()=>`Error in transpose: rank of input ${r.rank} must match length of perm ${t}.`),t.forEach(l=>{G(l>=0&&l<r.rank,()=>`All entries in 'perm' must be between 0 and ${r.rank-1} but got ${t}`)}),r.rank<=1)return r.clone();const s={x:r},o={perm:t};return"complex64"===r.dtype?En(()=>{let l=Hu(r),u=_f(r);return l=pe.runKernel(Ps,{x:l},o),u=pe.runKernel(Ps,{x:u},o),e&&(u=si(u)),ti(l,u)}):pe.runKernel(Ps,s,o)}}),on=de({movingAverage_:function ID(n,t,e,r,s=!0){const o=q(n,"v","movingAverage"),l=q(t,"x","movingAverage"),u=q(e,"decay","movingAverage");(function Mn(n,t){G(n.dtype===t.dtype,()=>`The dtypes of the first(${n.dtype}) and second(${t.dtype}) input must match`)})(o,l),G(un(o.shape,l.shape),()=>"Shape mismatch in v and x");const d=xn(1),h=fn(d,u);let p=Nt(fn(l,o),h);if(s){G(null!=r,()=>"When using zeroDebias: true, step is required.");const g=q(r,"step","movingAverage");p=Hn(p,fn(d,Md(u,g)))}return rn(o,p)}}),A1=de({scatterND_:function k1(n,t,e){Sr(e);const r=q(n,"indices","scatterND","int32"),s=q(t,"updates","scatterND");return mg(s,r,e),pe.runKernel(cc,{indices:r,updates:s},{shape:e})}}),M1=de({sparseToDense_:function Xu(n,t,e,r=0){Sr(e);const s=q(n,"sparseIndices","sparseToDense","int32"),o=q(t,"sparseValues","sparseToDense","string_or_numeric"),l=q(r,"defaultValue","sparseToDense",o.dtype);return function R1(n,t,e,r){if("int32"!==n.dtype)throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${n.dtype}.`);if(n.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${n.shape}.`);const s=n.rank>0?n.shape[0]:1,o=n.rank>1?n.shape[1]:1;if(e.length!==o)throw new Error(`outputShape has incorrect number of elements:, ${e.length}, should be: ${o}.`);if(0!==t.rank&&(1!==t.rank||t.size!==s))throw new Error(`sparseValues has incorrect shape ${t.shape}, should be [] or [${s}]`);if(t.dtype!==r.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}(s,o,e,l),pe.runKernel(B,{sparseIndices:s,sparseValues:o,defaultValue:l},{outputShape:e})}}),$f=de({gatherND_:function Ff(n,t){const e=q(t,"indices","gatherND","int32"),s={params:q(n,"x","gatherND","string_or_numeric"),indices:e};return pe.runKernel(ll,s)}}),Mb=de({dropout_:function DD(n,t,e,r){const s=q(n,"x","dropout");if(G("float32"===s.dtype,()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${s.dtype} tensor instead.`),G(t>=0&&t<1,()=>`rate must be a float in the range [0, 1), but got ${t}.`),0===t)return n instanceof Rr?s.clone():s;const o=function Mr(n,t){if(null==t)return n.shape.slice();if(un(n.shape,t))return t;if(n.shape.length===t.length){const e=[];for(let r=0;r<n.shape.length;r++)e.push(null==t[r]&&null!=n.shape[r]?n.shape[r]:t[r]);return e}return t}(s,e),l=1-t,u=Hn(vf(rn(Yd(o,0,1,"float32",r),l)),l);return Nt(s,u)}});function yg(n){return Math.floor(Math.pow(2,Math.ceil(Math.log(n)/Math.log(2))))}function vg(n,t,e){const r=1-n%2,s=new Float32Array(n);for(let o=0;o<n;++o){const l=2*Math.PI*o/(n+r-1);s[o]=t-e*Math.cos(l)}return ho(s,"float32")}function Pf(){return(Pf=xe(function*(n,t,e=1){const r=q(n,"predictions","inTopK"),s=q(t,"targets","inTopK");G(r.rank>1,()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${r.rank}`),G(r.rank-1===s.rank,()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${r.rank} and targets rank ${s.rank}`),bn(r.shape.slice(0,r.shape.length-1),s.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");const o=r.shape[r.shape.length-1];G(e>0&&e<=o,()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${o}), but got ${e}`);const l=yield r.data(),u=yield s.data(),[d,h]=[l.length/o,o],p=Rt("bool",d);for(let g=0;g<d;g++){const y=g*h,b=l.subarray(y,y+h),_=[];for(let I=0;I<b.length;I++)_.push({value:b[I],index:I});_.sort((I,S)=>S.value-I.value),p[g]=0;for(let I=0;I<e;I++)if(_[I].index===u[g]){p[g]=1;break}}return n!==r&&r.dispose(),t!==s&&s.dispose(),Va(p,s.shape,"bool")})).apply(this,arguments)}const Fb=function Ob(n,t){return Pf.apply(this,arguments)},O1=de({conv2DBackpropFilter_:function $b(n,t,e,r,s,o="NHWC",l){let u=n;3===n.rank&&(u=tt(n,[1,n.shape[0],n.shape[1],n.shape[2]]));let d=t;3===d.rank&&(d=tt(t,[1,t.shape[0],t.shape[1],t.shape[2]])),G(4===u.rank,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${u.shape}.`),G(4===d.rank,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${d.shape}.`),G(4===e.length,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${e}.`);const h="NHWC"===o?u.shape[3]:u.shape[1],p="NHWC"===o?d.shape[3]:d.shape[1];return G(h===e[2],()=>`Error in conv2dDerFilter: depth of input ${h}) must match input depth in filter (${e[2]}.`),G(p===e[3],()=>`Error in conv2dDerFilter: depth of dy (${p}) must match output depth for filter (${e[3]}).`),Po("conv2dDerFilter",s,l),pe.runKernel(ol,{x:u,dy:d},{strides:r,pad:s,dataFormat:o,dimRoundingMode:l,filterShape:e})}});function Lf(n,t,e){if(null==e||"linear"===e)return n;if("relu"===e)return Nt(n,_b(t));throw new Error(`Cannot compute gradient for fused activation ${e}.`)}function Bf(n,t){let e=t;const r=pw(n.shape,t.shape);return r.length>0&&(e=Zn(e,r)),tt(e,n.shape)}function Hl(n,t,e,r){if("linear"===t)return n;if("relu"===t)return dg(n);if("elu"===t)return Wm(n);if("relu6"===t)return J0(n);if("prelu"===t)return V0(n,e);if("leakyrelu"===t)return C0(n,r);if("sigmoid"===t)return Ol(n);throw new Error(`Unknown fused activation ${t}.`)}const Vf=(n,t)=>!(n>0)||"linear"===t,$1=de({fusedConv2d_:function F1({x:n,filter:t,strides:e,pad:r,dataFormat:s="NHWC",dilations:o=[1,1],dimRoundingMode:l,bias:u,activation:d="linear",preluActivationWeights:h,leakyreluAlpha:p}){if(!1===Vf(pe.state.gradientDepth,d=d||"linear")){G("NHWC"===s,()=>`Error in fused conv2d: got dataFormat of ${s} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);let te=ff(n,t,e,r,s,o,l);return null!=u&&(te=rn(te,u)),Hl(te,d,h,p)}const g=q(n,"x","conv2d","float32"),y=q(t,"filter","conv2d","float32");let b=g,_=!1;3===g.rank&&(_=!0,b=tt(g,[1,g.shape[0],g.shape[1],g.shape[2]])),G(4===b.rank,()=>`Error in fused conv2d: input must be rank 4, but got rank ${b.rank}.`),G(4===y.rank,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${y.rank}.`),Po("fused conv2d",r,l);const I="NHWC"===s?b.shape[3]:b.shape[1];G(y.shape[2]===I,()=>`Error in conv2d: depth of input (${I}) must match input depth for filter ${y.shape[2]}.`),G(Ns(e,o),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${e} and dilations '${o}'`);const S=Xr(b.shape,y.shape,e,o,r,l);let T,O;if(null!=u&&(T=q(u,"bias","fused conv2d"),[T]=jt(T,g),"NHWC"===s?Nn(S.outShape,T.shape):(G(T.shape.length<=1,()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${T.shape.length}.`),G(0===T.shape.length||T.shape[0]===S.outChannels||1===T.shape[0],()=>`Error in fused conv2d: bias shape (${T.shape}) is not compatible with the number of output channels (${S.outChannels})`))),null!=h){const te=h.shape;if(G(te.length<=1||3===te.length,()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${te.length}.`),1===te.length)G(1===te[0]||te[0]===S.outChannels,()=>`Error in fused conv2d: PReLU activation weights (${te}) is not compatible with the number of output channels (${S.outChannels}).`);else if(3===te.length)try{Nn(te,S.outShape)}catch(se){throw Error(`Error in fused conv2d: PReLU activation weights (${te}) is not compatible with the output shape of the conv2d (${S.outShape}).`)}O=q(h,"prelu weights","fused conv2d")}const V=(te,se)=>{G("NHWC"===s,()=>`Error in gradient of fused conv2D: got dataFormat of ${s} but only NHWC is currently supported.`);const[le,Ce,be,Me]=se,He=Lf(te,be,d);G(Vd(o),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${o}'`);const Ke=[Pm(Ce.shape,He,le,e,r),O1(Ce,He,le.shape,e,r)];if(null!=Me){const Se=Bf(Me,He);Ke.push(Se)}return Ke},U={x:b,filter:y,bias:T,preluActivationWeights:O},j={strides:e,pad:r,dataFormat:s,dilations:o,dimRoundingMode:l,activation:d,leakyreluAlpha:p};return null==u?Wa((se,le,Ce)=>{let be=pe.runKernel(du,U,j);return Ce([le,se,be]),_&&(be=tt(be,[be.shape[1],be.shape[2],be.shape[3]])),{value:be,gradFunc:V}})(b,y):Wa((se,le,Ce,be)=>{let Me=pe.runKernel(du,U,j);return be([le,se,Me,Ce]),_&&(Me=tt(Me,[Me.shape[1],Me.shape[2],Me.shape[3]])),{value:Me,gradFunc:V}})(b,y,T)}}),Pb=de({depthwiseConv2dNativeBackpropFilter_:function Uf(n,t,e,r,s,o=[1,1],l){let u=n;3===n.rank&&(u=tt(n,[1,n.shape[0],n.shape[1],n.shape[2]]));let d=t;return 3===d.rank&&(d=tt(t,[1,t.shape[0],t.shape[1],t.shape[2]])),pe.runKernel(nc,{x:u,dy:d},{strides:r,pad:s,dimRoundingMode:l,dilations:o,filterShape:e})}}),Bb=de({depthwiseConv2dNativeBackpropInput_:function Lb(n,t,e,r,s,o=[1,1],l){let u=t,d=!1;3===t.rank&&(d=!0,u=tt(t,[1,t.shape[0],t.shape[1],t.shape[2]]));const g=pe.runKernel(Xc,{dy:u,filter:e},{strides:r,pad:s,dimRoundingMode:l,dilations:o,inputShape:n});return d?tt(g,[g.shape[1],g.shape[2],g.shape[3]]):g}}),eh=de({fusedDepthwiseConv2d_:function P1({x:n,filter:t,strides:e,pad:r,dataFormat:s="NHWC",dilations:o=[1,1],dimRoundingMode:l,bias:u,activation:d="linear",preluActivationWeights:h,leakyreluAlpha:p}){if(!1===Vf(pe.state.gradientDepth,d)){let j=Hd(n,t,e,r,s,o,l);return null!=u&&(j=rn(j,u)),Hl(j,d,h,p)}const g=q(n,"x","depthwiseConv2d","float32"),y=q(t,"filter","depthwiseConv2d","float32");let b=g,_=!1;3===g.rank&&(_=!0,b=tt(g,[1,g.shape[0],g.shape[1],g.shape[2]])),G(4===b.rank,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${b.rank}.`),G(4===y.rank,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${y.rank}.`),G(b.shape[3]===y.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${b.shape[3]}) must match the inChannels dimension in filter ${y.shape[2]}.`),null==o&&(o=[1,1]),G(Ns(e,o),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${e} and dilations '${o}'`),Po("fused depthwiseConv2d",r,l);const I=Xr(b.shape,y.shape,e,o,r,l,!0);let S,T;null!=u&&(S=q(u,"bias","fused conv2d"),[S]=jt(S,g),Nn(I.outShape,S.shape)),null!=h&&(T=q(h,"prelu weights","fused depthwiseConv2d"));const O=(j,te)=>{G(Vd(o),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${o}'`);const[se,le,Ce,be]=te,Me=Lf(j,Ce,d),He=Bb(le.shape,Me,se,e,r,o,l),We=Pb(le,Me,se.shape,e,r,o,l);return null!=be?[He,We,Bf(S,Me)]:[He,We]},V={x:b,filter:y,bias:S,preluActivationWeights:T},U={strides:e,pad:r,dataFormat:s,dilations:o,dimRoundingMode:l,activation:d,leakyreluAlpha:p};return null==u?Wa((te,se,le)=>{let Ce=pe.runKernel(Qs,V,U);return le([se,te,Ce]),_&&(Ce=tt(Ce,[Ce.shape[1],Ce.shape[2],Ce.shape[3]])),{value:Ce,gradFunc:O}})(b,y):Wa((te,se,le,Ce)=>{let be=pe.runKernel(Qs,V,U);return Ce([se,te,be,le]),_&&(be=tt(be,[be.shape[1],be.shape[2],be.shape[3]])),{value:be,gradFunc:O}})(b,y,S)}}),L1=de({fusedMatMul_:function th({a:n,b:t,transposeA:e=!1,transposeB:r=!1,bias:s,activation:o="linear",preluActivationWeights:l,leakyreluAlpha:u=.2}){if(!1===Vf(pe.state.gradientDepth,o)){let Me=Yn(n,t,e,r);return null!=s&&(Me=rn(Me,s)),Hl(Me,o,l,u)}let d=q(n,"a","fused matMul"),h=q(t,"b","fused matMul");[d,h]=jt(d,h);const p=e?d.shape[d.rank-2]:d.shape[d.rank-1],g=r?h.shape[h.rank-1]:h.shape[h.rank-2],y=e?d.shape[d.rank-1]:d.shape[d.rank-2],b=r?h.shape[h.rank-2]:h.shape[h.rank-1],_=d.shape.slice(0,-2),I=h.shape.slice(0,-2),S=Ee(_),T=Ee(I);G(p===g,()=>`Error in fused matMul: inner shapes (${p}) and (${g}) of Tensors with shapes ${d.shape} and ${h.shape} and transposeA=${e} and transposeB=${r} must match.`);const V=Nn(d.shape.slice(0,-2),h.shape.slice(0,-2)).concat([y,b]),U=tt(d,e?[S,p,y]:[S,y,p]),j=tt(h,r?[T,b,g]:[T,g,b]);let te,se;null!=s&&(te=q(s,"bias","fused matMul"),[te]=jt(te,d),Nn(V,te.shape)),null!=l&&(se=q(l,"prelu weights","fused matMul"));const le=(Me,He)=>{const[We,je,Ke,Se]=He,ke=Lf(tt(Me,Ke.shape),Ke,o);let De,Be;return e||r?!e&&r?(De=Yn(ke,je,!1,!1),Be=Yn(ke,We,!0,!1)):e&&!r?(De=Yn(je,ke,!1,!0),Be=Yn(We,ke,!1,!1)):(De=Yn(je,ke,!0,!0),Be=Yn(ke,We,!0,!0)):(De=Yn(ke,je,!1,!0),Be=Yn(We,ke,!0,!1)),null!=s?[De,Be,Bf(Se,ke)]:[De,Be]},Ce={a:U,b:j,bias:te,preluActivationWeights:se},be={transposeA:e,transposeB:r,activation:o,leakyreluAlpha:u};return null==s?Wa((He,We,je)=>{const Ke=pe.runKernel(pc,Ce,be);return je([He,We,Ke]),{value:tt(Ke,V),gradFunc:le}})(U,j):Wa((He,We,je,Ke)=>{const Se=pe.runKernel(pc,Ce,be);return Ke([He,We,Se,je]),{value:tt(Se,V),gradFunc:le}})(U,j,te)}}),V1=de({hammingWindow_:function B1(n){return vg(n,.54,.46)}}),bg=de({hannWindow_:function Vb(n){return vg(n,.5,.5)}}),zb=de({frame_:function Ub(n,t,e,r=!1,s=0){let o=0;const l=[];for(;o+t<=n.size;)l.push(Pn(n,o,t)),o+=e;if(r)for(;o<n.size;){const u=o+t-n.size,d=zs([Pn(n,o,t-u),Rd([u],s)]);l.push(d),o+=e}return 0===l.length?qu([],[0,t]):tt(zs(l),[l.length,t])}}),U1=de({stft_:function Hb(n,t,e,r,s=bg){null==r&&(r=yg(t));const o=zb(n,t,e),l=Nt(o,s(t));return Mf(l,r)}}),TD=de({cropAndResize_:function z1(n,t,e,r,s="bilinear",o=0){const l=q(n,"image","cropAndResize"),u=q(t,"boxes","cropAndResize","float32"),d=q(e,"boxInd","cropAndResize","int32"),h=u.shape[0];return G(4===l.rank,()=>`Error in cropAndResize: image must be rank 4,but got rank ${l.rank}.`),G(2===u.rank&&4===u.shape[1],()=>`Error in cropAndResize: boxes must be have size [${h},4] but had shape ${u.shape}.`),G(1===d.rank&&d.shape[0]===h,()=>`Error in cropAndResize: boxInd must be have size [${h}] but had shape ${u.shape}.`),G(2===r.length,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${r.length}.`),G(r[0]>=1&&r[1]>=1,()=>`cropSize must be atleast [1,1], but was ${r}`),G("bilinear"===s||"nearest"===s,()=>`method must be bilinear or nearest, but was ${s}`),pe.runKernel(qs,{image:l,boxes:u,boxInd:d},{method:s,extrapolationValue:o,cropSize:r})}}),kD=de({flipLeftRight_:function ND(n){const t=q(n,"image","flipLeftRight","float32");return G(4===t.rank,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${t.rank}.`),pe.runKernel(Do,{image:t},{})}}),Wb=de({grayscaleToRGB_:function AD(n){const t=q(n,"image","grayscaleToRGB"),e=t.rank-1,r=t.shape[e];G(t.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${t.rank}.`),G(1===r,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${r}.`);const s=new Array(t.rank);return s.fill(1,0,e),s[e]=3,Ru(t,s)}}),H1=de({rgbToGrayscale_:function zf(n){const t=q(n,"image","RGBToGrayscale"),r=t.shape[t.rank-1];G(t.rank>=2,()=>`Error in RGBToGrayscale: images must be at least rank 2, but got rank ${t.rank}.`),G(3===r,()=>`Error in RGBToGrayscale: last dimension of an RGB image should be size 3, but got size ${r}.`);const s=t.dtype,o=fr(t,"float32"),l=ho([.2989,.587,.114]);let u;switch(t.rank){case 2:u=Rc("ij,j->i",o,l);break;case 3:u=Rc("ijk,k->ij",o,l);break;case 4:u=Rc("ijkl,l->ijk",o,l);break;case 5:u=Rc("ijklm,m->ijkl",o,l);break;case 6:u=Rc("ijklmn,n->ijklm",o,l);break;default:throw new Error("Not a valid tensor rank.")}return u=ra(u,-1),fr(u,s)}}),jb=de({rotateWithOffset_:function W1(n,t,e=0,r=.5){const s=q(n,"image","rotateWithOffset","float32");return G(4===s.rank,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${s.rank}.`),pe.runKernel(uu,{image:s},{radians:t,fillValue:e,center:r})}});function la(n,t,e,r,s,o){null==r&&(r=.5),null==s&&(s=Number.NEGATIVE_INFINITY),null==o&&(o=0);const l=n.shape[0];return e=Math.min(e,l),G(0<=r&&r<=1,()=>`iouThreshold must be in [0, 1], but was '${r}'`),G(2===n.rank,()=>`boxes must be a 2D tensor, but was of rank '${n.rank}'`),G(4===n.shape[1],()=>`boxes must have 4 columns, but 2nd dimension was ${n.shape[1]}`),G(1===t.rank,()=>"scores must be a 1D tensor"),G(t.shape[0]===l,()=>`scores has incompatible shape with boxes. Expected ${l}, but was ${t.shape[0]}`),G(0<=o&&o<=1,()=>`softNmsSigma must be in [0, 1], but was '${o}'`),{maxOutputSize:e,iouThreshold:r,scoreThreshold:s,softNmsSigma:o}}const G1=de({nonMaxSuppression_:function j1(n,t,e,r=.5,s=Number.NEGATIVE_INFINITY){const o=q(n,"boxes","nonMaxSuppression","float32"),l=q(t,"scores","nonMaxSuppression","float32"),u=la(o,l,e,r,s);return pe.runKernel(Wi,{boxes:o,scores:l},{maxOutputSize:e=u.maxOutputSize,iouThreshold:r=u.iouThreshold,scoreThreshold:s=u.scoreThreshold})}});function K1(n,t,e){const r=function q1(n,t,e){return function Gb(n,t,e){let r=0,s=n.length,o=0,l=!1;for(;r<s;){o=r+(s-r>>>1);const u=e(t,n[o]);u>0?r=o+1:(s=o,l=!u)}return l?r:-r-1}(n,t,e||X1)}(n,t,e);n.splice(r<0?-(r+1):r,0,t)}function X1(n,t){return n>t?1:n<t?-1:0}function _g(n,t,e,r,s){return wg(n,t,e,r,s,0)}function xg(n,t,e,r,s,o){return wg(n,t,e,r,s,0,!1,o,!0)}function Bc(n,t,e,r,s,o){return wg(n,t,e,r,s,o,!0)}function wg(n,t,e,r,s,o,l=!1,u=!1,d=!1){const h=[];for(let S=0;S<t.length;S++)t[S]>s&&h.push({score:t[S],boxIndex:S,suppressBeginIndex:0});h.sort(Cg);const p=o>0?-.5/o:0,g=[],y=[];for(;g.length<e&&h.length>0;){const S=h.pop(),{score:T,boxIndex:O,suppressBeginIndex:V}=S;if(T<s)break;let U=!1;for(let j=g.length-1;j>=V;--j){const te=Kb(n,O,g[j]);if(te>=r){U=!0;break}if(S.score=S.score*Y1(r,p,te),S.score<=s)break}S.suppressBeginIndex=g.length,U||(S.score===T?(g.push(O),y.push(S.score)):S.score>s&&K1(h,S,Cg))}const b=g.length,_=e-b;u&&_>0&&(g.push(...new Array(_).fill(0)),y.push(...new Array(_).fill(0)));const I={selectedIndices:g};return l&&(I.selectedScores=y),d&&(I.validOutputs=b),I}function Kb(n,t,e){const r=n.subarray(4*t,4*t+4),s=n.subarray(4*e,4*e+4),o=Math.min(r[0],r[2]),l=Math.min(r[1],r[3]),u=Math.max(r[0],r[2]),d=Math.max(r[1],r[3]),h=Math.min(s[0],s[2]),p=Math.min(s[1],s[3]),g=Math.max(s[0],s[2]),y=Math.max(s[1],s[3]),b=(u-o)*(d-l),_=(g-h)*(y-p);if(b<=0||_<=0)return 0;const I=Math.max(o,h),S=Math.max(l,p),T=Math.min(u,g),O=Math.min(d,y),V=Math.max(T-I,0)*Math.max(O-S,0);return V/(b+_-V)}function Y1(n,t,e){const r=Math.exp(t*e*e);return e<=n?r:0}function Cg(n,t){return n.score-t.score||n.score===t.score&&t.boxIndex-n.boxIndex}function Hf(){return(Hf=xe(function*(n,t,e,r=.5,s=Number.NEGATIVE_INFINITY){const o=q(n,"boxes","nonMaxSuppressionAsync"),l=q(t,"scores","nonMaxSuppressionAsync"),u=la(o,l,e,r,s);e=u.maxOutputSize,r=u.iouThreshold,s=u.scoreThreshold;const d=yield Promise.all([o.data(),l.data()]),h=d[0],p=d[1],{selectedIndices:g}=_g(h,p,e,r,s);return o!==n&&o.dispose(),l!==t&&l.dispose(),ho(g,"int32")})).apply(this,arguments)}const J1=de({nonMaxSuppressionWithScore_:function Sg(n,t,e,r=.5,s=Number.NEGATIVE_INFINITY,o=0){const l=q(n,"boxes","nonMaxSuppression"),u=q(t,"scores","nonMaxSuppression"),d=la(l,u,e,r,s,o),g=pe.runKernel(Xs,{boxes:l,scores:u},{maxOutputSize:e=d.maxOutputSize,iouThreshold:r=d.iouThreshold,scoreThreshold:s=d.scoreThreshold,softNmsSigma:o=d.softNmsSigma});return{selectedIndices:g[0],selectedScores:g[1]}}});function Wf(){return(Wf=xe(function*(n,t,e,r=.5,s=Number.NEGATIVE_INFINITY,o=0){const l=q(n,"boxes","nonMaxSuppressionAsync"),u=q(t,"scores","nonMaxSuppressionAsync"),d=la(l,u,e,r,s,o);e=d.maxOutputSize,r=d.iouThreshold,s=d.scoreThreshold,o=d.softNmsSigma;const h=yield Promise.all([l.data(),u.data()]),p=h[0],g=h[1],{selectedIndices:y,selectedScores:b}=Bc(p,g,e,r,s,o);return l!==n&&l.dispose(),u!==t&&u.dispose(),{selectedIndices:ho(y,"int32"),selectedScores:ho(b)}})).apply(this,arguments)}const nS=de({nonMaxSuppressionPadded_:function tS(n,t,e,r=.5,s=Number.NEGATIVE_INFINITY,o=!1){const l=q(n,"boxes","nonMaxSuppression"),u=q(t,"scores","nonMaxSuppression"),d=la(l,u,e,r,s,null),_=pe.runKernel(ji,{boxes:l,scores:u},{maxOutputSize:d.maxOutputSize,iouThreshold:d.iouThreshold,scoreThreshold:d.scoreThreshold,padToMaxOutputSize:o});return{selectedIndices:_[0],validOutputs:_[1]}}});function Ig(){return(Ig=xe(function*(n,t,e,r=.5,s=Number.NEGATIVE_INFINITY,o=!1){const l=q(n,"boxes","nonMaxSuppressionAsync"),u=q(t,"scores","nonMaxSuppressionAsync"),d=la(l,u,e,r,s,null),h=d.maxOutputSize,p=d.iouThreshold,g=d.scoreThreshold,[y,b]=yield Promise.all([l.data(),u.data()]),{selectedIndices:_,validOutputs:I}=xg(y,b,h,p,g,o);return l!==n&&l.dispose(),u!==t&&u.dispose(),{selectedIndices:ho(_,"int32"),validOutputs:xn(I,"int32")}})).apply(this,arguments)}const sS=de({resizeBilinear_:function rS(n,t,e=!1,r=!1){const s=q(n,"images","resizeBilinear");G(3===s.rank||4===s.rank,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${s.rank}.`),G(2===t.length,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${t}.`),G(!1===r||!1===e,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let o=s,l=!1;3===s.rank&&(l=!0,o=tt(s,[1,s.shape[0],s.shape[1],s.shape[2]]));const[]=t,h=pe.runKernel(Gi,{images:o},{alignCorners:e,halfPixelCenters:r,size:t});return l?tt(h,[h.shape[1],h.shape[2],h.shape[3]]):h}}),iS=de({resizeNearestNeighbor_:function oS(n,t,e=!1,r=!1){const s=q(n,"images","resizeNearestNeighbor");G(3===s.rank||4===s.rank,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${s.rank}.`),G(2===t.length,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${t}.`),G("float32"===s.dtype||"int32"===s.dtype,()=>"`images` must have `int32` or `float32` as dtype"),G(!1===r||!1===e,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let o=s,l=!1;3===s.rank&&(l=!0,o=tt(s,[1,s.shape[0],s.shape[1],s.shape[2]]));const[]=t,h=pe.runKernel(Ro,{images:o},{alignCorners:e,halfPixelCenters:r,size:t});return l?tt(h,[h.shape[1],h.shape[2],h.shape[3]]):h}}),cS=de({threshold_:function aS(n,t="binary",e=!1,r=.5){const s=q(n,"image","threshold"),d=s.shape[0]*s.shape[1];let p,g,y,b,h=Nt(ho([r]),255);if(G(3===s.rank,()=>`Error in threshold: image must be rank 3,but got rank ${s.rank}.`),G(3===s.shape[2]||1===s.shape[2],()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${s.shape[2]}.`),G("int32"===s.dtype||"float32"===s.dtype,()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${s.dtype}.`),G("otsu"===t||"binary"===t,()=>`Method must be binary or otsu, but was ${t}`),3===s.shape[2]){[p,g,y]=Gu(s,[1,1,1],-1);const S=Nt(p,.2989),T=Nt(g,.587),O=Nt(y,.114);b=rn(rn(S,T),O)}else b=n;"otsu"===t&&(h=function lS(n,t){let o,l,u,d,h,p,e=ho([-1]),r=ho([0]),s=ho([0]);for(let g=0;g<n.size-1;g++){o=Pn(n,0,g+1),l=Pn(n,g+1),h=Hn(Zn(o),t),p=Hn(Zn(l),t);const y=Zn(Nt(o,zu(0,o.size)));u=Hn(y,Zn(o));const b=Rd(l.shape,o.size),_=rn(zu(0,l.size),b),I=Nt(l,_);d=Hn(Zn(I),Zn(l));const S=fn(u,d),T=fn(u,d),O=Nt(h,p);s=Nt(Nt(O,S),T);const V=bf(s,r);r=Ac(V,s,r),e=Ac(V,ho([g]),e)}return e}(e0(fr(ob(b),"int32"),Va([]),256),d));const _=e?Ym(b,h):bf(b,h);return fr(Nt(_,255),"int32")}}),Yb=de({transform_:function uS(n,t,e="nearest",r="constant",s=0,o){const l=q(n,"image","transform","float32"),u=q(t,"transforms","transform","float32");return G(4===l.rank,()=>`Error in transform: image must be rank 4,but got rank ${l.rank}.`),G(2===u.rank&&(u.shape[0]===l.shape[0]||1===u.shape[0])&&8===u.shape[1],()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),G(null==o||2===o.length,()=>`Error in transform: outputShape must be [height, width] or null, but got ${o}.`),pe.runKernel(or,{image:l,transforms:u},{interpolation:e,fillMode:r,fillValue:s,outputShape:o})}}),dS=de({bandPart_:function Zb(n,t,e){const r=q(n,"a","bandPart");G(r.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${r.rank}.`);const s=r.shape,[o,l]=r.shape.slice(-2);let u,d;"number"==typeof t?(G(t%1==0,()=>`bandPart(): numLower must be an integer, got ${t}.`),G(t<=o,()=>`bandPart(): numLower (${t}) must not be greater than the number of rows (${o}).`),u=q(t<0?o:t,"numLower","bandPart")):(G("int32"===t.dtype,()=>"bandPart(): numLower's dtype must be an int32."),u=Ac(xf(t,0),o,If(t,o))),"number"==typeof e?(G(e%1==0,()=>`bandPart(): numUpper must be an integer, got ${e}.`),G(e<=l,()=>`bandPart(): numUpper (${e}) must not be greater than the number of columns (${l}).`),d=q(e<0?l:e,"numUpper","bandPart")):(G("int32"===e.dtype,()=>"bandPart(): numUpper's dtype must be an int32."),d=Ac(xf(e,0),l,If(e,l)));const h=tt(zu(0,o,1,"int32"),[-1,1]),p=zu(0,l,1,"int32"),g=fn(h,p),y=Vl(Ym(g,u),b0(g,si(d))),b=Mc([o,l],r.dtype);return tt(Ya(zl(tt(r,[-1,o,l])).map(_=>Ac(y,_,b))),s)}}),Qb=de({gramSchmidt_:function hS(n){let t;if(Array.isArray(n)){t=!1,G(null!=n&&n.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");const s=n[0].shape[0];for(let o=1;o<n.length;++o)G(n[o].shape[0]===s,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${n[o].shape[0]} vs. ${s})`)}else t=!0,n=Gu(n,n.shape[0],0).map(s=>Ku(s,[0]));G(n.length<=n[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${n.length}) exceeds number of dimensions (${n[0].shape[0]}).`);const e=[],r=n;for(let s=0;s<n.length;++s)e.push(pe.tidy(()=>{let o=r[s];if(s>0)for(let l=0;l<s;++l){const u=Nt(Zn(Nt(e[l],o)),e[l]);o=fn(o,u)}return Hn(o,Au(o,"euclidean"))}));return t?Ya(e,0):e}});function Jb(n,t=!1){return pe.tidy(()=>{G(2===n.shape.length,()=>`qr2d() requires a 2D Tensor, but got a ${n.shape.length}D Tensor.`);const e=n.shape[0],r=n.shape[1];let s=CC(e),o=kl(n);const l=qu([[1]],[1,1]);let u=kl(l);const d=e>=r?r:e;for(let h=0;h<d;++h){const p=o,g=u,y=s;[u,o,s]=pe.tidy(()=>{const b=Pn(o,[h,h],[e-h,1]),_=Au(b),I=Pn(o,[h,h],[1,1]),S=Ac(bf(I,0),qu([[-1]]),qu([[1]])),T=fn(I,Nt(S,_)),O=Hn(b,T);u=1===O.shape[0]?kl(l):zs([l,Pn(O,[1,0],[O.shape[0]-1,O.shape[1]])],0);const V=si(Hn(Yn(S,T),_)),U=Pn(o,[h,0],[e-h,r]),j=Nt(V,u),te=Of(u);if(0===h)o=fn(U,Yn(j,Yn(te,U)));else{const Ce=fn(U,Yn(j,Yn(te,U)));o=zs([Pn(o,[0,0],[h,r]),Ce],0)}const se=Of(j),le=Pn(s,[0,h],[e,s.shape[1]-h]);if(0===h)s=fn(le,Yn(Yn(le,u),se));else{const Ce=fn(le,Yn(Yn(le,u),se));s=zs([Pn(s,[0,0],[e,h]),Ce],1)}return[u,o,s]}),lo([p,g,y])}return!t&&e>r&&(s=Pn(s,[0,0],[e,r]),o=Pn(o,[0,0],[r,r])),[s,o]})}const pS=de({qr_:function fS(n,t=!1){if(G(n.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${n.rank}`),2===n.rank)return Jb(n,t);{const e=n.shape.slice(0,n.shape.length-2).reduce((d,h)=>d*h),r=zl(tt(n,[e,n.shape[n.shape.length-2],n.shape[n.shape.length-1]]),0),s=[],o=[];return r.forEach(d=>{const[h,p]=Jb(d,t);s.push(h),o.push(p)}),[tt(Ya(s,0),n.shape),tt(Ya(o,0),n.shape)]}}});var xs=(()=>{return(n=xs||(xs={}))[n.NONE=0]="NONE",n[n.MEAN=1]="MEAN",n[n.SUM=2]="SUM",n[n.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS",xs;var n})();const ca=de({computeWeightedLoss_:function Dg(n,t,e=xs.SUM_BY_NONZERO_WEIGHTS){const r=q(n,"losses","computeWeightedLoss");let s=null;null!=t&&(s=q(t,"weights","computeWeightedLoss"));const o=null==s?r:Nt(r,s);if(e===xs.NONE)return o;if(e===xs.SUM)return Zn(o);if(e===xs.MEAN){if(null==s)return Ef(o);{const l=r.size/s.size,u=Hn(Zn(o),Zn(s));return l>1?Hn(u,xn(l)):u}}if(e===xs.SUM_BY_NONZERO_WEIGHTS){if(null==s)return Hn(Zn(o),xn(r.size));{const l=Nt(s,Oc(r.shape)),u=fr(Zn(Ul(l,xn(0))),"float32");return Hn(Zn(o),u)}}throw Error(`Unknown reduction: ${e}`)}}),mS=de({absoluteDifference_:function Tg(n,t,e,r=xs.SUM_BY_NONZERO_WEIGHTS){const s=q(n,"labels","absoluteDifference"),o=q(t,"predictions","absoluteDifference");let l=null;null!=e&&(l=q(e,"weights","absoluteDifference")),bn(s.shape,o.shape,"Error in absoluteDifference: ");const u=uo(fn(s,o));return ca(u,l,r)}}),Ng=de({cosineDistance_:function gS(n,t,e,r,s=xs.SUM_BY_NONZERO_WEIGHTS){const o=q(n,"labels","cosineDistance"),l=q(t,"predictions","cosineDistance");let u=null;null!=r&&(u=q(r,"weights","cosineDistance")),bn(o.shape,l.shape,"Error in cosineDistance: ");const d=xn(1),h=fn(d,Zn(Nt(o,l),e,!0));return ca(h,u,s)}}),e_=de({hingeLoss_:function yS(n,t,e,r=xs.SUM_BY_NONZERO_WEIGHTS){let s=q(n,"labels","hingeLoss");const o=q(t,"predictions","hingeLoss");let l=null;null!=e&&(l=q(e,"weights","hingeLoss")),bn(s.shape,o.shape,"Error in hingeLoss: ");const u=xn(1);s=fn(Nt(xn(2),s),u);const d=dg(fn(u,Nt(s,o)));return ca(d,l,r)}}),t_=de({huberLoss_:function Yu(n,t,e,r=1,s=xs.SUM_BY_NONZERO_WEIGHTS){const o=q(n,"labels","huberLoss"),l=q(t,"predictions","huberLoss");let u=null;null!=e&&(u=q(e,"weights","huberLoss")),bn(o.shape,l.shape,"Error in huberLoss: ");const d=xn(r),h=uo(fn(l,o)),p=If(h,d),g=fn(h,p),y=rn(Nt(xn(.5),Fo(p)),Nt(d,g));return ca(y,u,s)}}),RD=de({logLoss_:function vS(n,t,e,r=1e-7,s=xs.SUM_BY_NONZERO_WEIGHTS){const o=q(n,"labels","logLoss"),l=q(t,"predictions","logLoss");let u=null;null!=e&&(u=q(e,"weights","logLoss")),bn(o.shape,l.shape,"Error in logLoss: ");const d=xn(1),h=xn(r),p=si(Nt(o,Bl(rn(l,h)))),g=Nt(fn(d,o),Bl(rn(fn(d,l),h))),y=fn(p,g);return ca(y,u,s)}}),kg=de({meanSquaredError_:function n_(n,t,e,r=xs.SUM_BY_NONZERO_WEIGHTS){const s=q(n,"labels","meanSquaredError"),o=q(t,"predictions","meanSquaredError");let l=null;null!=e&&(l=q(e,"weights","meanSquaredError")),bn(s.shape,o.shape,"Error in meanSquaredError: ");const u=pg(s,o);return ca(u,l,r)}}),_S=de({sigmoidCrossEntropy_:function Ag(n,t,e,r=0,s=xs.SUM_BY_NONZERO_WEIGHTS){let o=q(n,"multiClassLabels","sigmoidCrossEntropy");const l=q(t,"logits","sigmoidCrossEntropy");let u=null;if(null!=e&&(u=q(e,"weights","sigmoidCrossEntropy")),bn(o.shape,l.shape,"Error in sigmoidCrossEntropy: "),r>0){const h=xn(r),p=xn(1),g=xn(.5);o=rn(Nt(o,fn(p,h)),Nt(g,h))}const d=function bS(n,t){const e=q(n,"labels","sigmoidCrossEntropyWithLogits"),r=q(t,"logits","sigmoidCrossEntropyWithLogits");bn(e.shape,r.shape,"Error in sigmoidCrossEntropyWithLogits: ");const s=dg(r),o=Nt(r,e),l=Wd(Ll(si(uo(r))));return rn(fn(s,o),l)}(o,l);return ca(d,u,s)}}),s_=de({softmaxCrossEntropy_:function Rg(n,t,e,r=0,s=xs.SUM_BY_NONZERO_WEIGHTS){let o=q(n,"onehotLabels","softmaxCrossEntropy");const l=q(t,"logits","softmaxCrossEntropy");let u=null;if(null!=e&&(u=q(e,"weights","softmaxCrossEntropy")),bn(o.shape,l.shape,"Error in softmaxCrossEntropy: "),r>0){const h=xn(r),p=xn(1),g=xn(o.shape[1]);o=rn(Nt(o,fn(p,h)),Hn(h,g))}const d=function r_(n,t,e=-1){if(-1===e&&(e=t.rank-1),e!==t.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${t.rank} and dim was ${e}`);return Wa((s,o,l)=>{const d=jd(o,[e],!0),h=fn(fr(o,"float32"),d);l([s,h]);const p=si(Nt(h,s));return{value:Zn(p,[e]),gradFunc:(b,_)=>{const[I,S]=_,T=Yr(b.shape,[e]);return[Nt(tt(b,T),fn(fr(I,"float32"),Ll(S))),Nt(tt(b,T),fn(Ll(S),fr(I,"float32")))]}}})(n,t)}(o,l);return ca(d,u,s)}}),NS={fft:ju,ifft:Qd,rfft:Mf,irfft:Rf},kS={hammingWindow:V1,hannWindow:bg,frame:zb,stft:U1},nh={flipLeftRight:kD,grayscaleToRGB:Wb,resizeNearestNeighbor:iS,resizeBilinear:sS,rgbToGrayscale:H1,rotateWithOffset:jb,cropAndResize:TD,nonMaxSuppression:G1,nonMaxSuppressionAsync:function Z1(n,t,e){return Hf.apply(this,arguments)},nonMaxSuppressionWithScore:J1,nonMaxSuppressionWithScoreAsync:function qb(n,t,e){return Wf.apply(this,arguments)},nonMaxSuppressionPadded:nS,nonMaxSuppressionPaddedAsync:function Eg(n,t,e){return Ig.apply(this,arguments)},threshold:cS,transform:Yb},AS={bandPart:dS,gramSchmidt:Qb,qr:pS},RS={absoluteDifference:mS,computeWeightedLoss:ca,cosineDistance:Ng,hingeLoss:e_,huberLoss:t_,logLoss:RD,meanSquaredError:kg,sigmoidCrossEntropy:_S,softmaxCrossEntropy:s_},MS={sparseFillEmptyRows:de({sparseFillEmptyRows_:function o_(n,t,e,r){const s=q(n,"indices","sparseFillEmptyRows","int32"),o=q(t,"values","sparseFillEmptyRows"),l=q(e,"denseShape","sparseFillEmptyRows","int32"),u=q(r,"defaultValue","sparseFillEmptyRows",o.dtype);if(2!==s.rank)throw new Error(`Indices should be Tensor2D but received shape\n        ${s.shape}`);if(1!==o.rank)throw new Error(`Values should be Tensor1D but received shape ${o.shape}`);if(1!==l.rank)throw new Error(`Dense shape should be Tensor1D but received shape ${l.shape}`);if(0!==u.rank)throw new Error(`Default value should be a scalar but received shape ${u.shape}`);const h=pe.runKernel(Xo,{indices:s,values:o,denseShape:l,defaultValue:u});return{outputIndices:h[0],outputValues:h[1],emptyRowIndicator:h[2],reverseIndexMap:h[3]}}}),sparseReshape:de({sparseReshape_:function a_(n,t,e){const r=q(n,"inputIndices","sparseReshape","int32"),s=q(t,"inputShape","sparseReshape","int32"),o=q(e,"newShape","sparseReshape","int32");if(2!==r.rank)throw new Error(`Input indices should be Tensor2D but received shape\n        ${r.shape}`);if(1!==s.rank)throw new Error(`Input shape should be Tensor1D but received shape ${s.shape}`);if(1!==o.rank)throw new Error(`New shape should be Tensor1D but received shape ${o.shape}`);const u=pe.runKernel(Ma,{inputIndices:r,inputShape:s,newShape:o});return{outputIndices:u[0],outputShape:u[1]}}}),sparseSegmentMean:de({sparseSegmentMean_:function wS(n,t,e){const r=q(n,"data","sparseSegmentMean"),s=q(t,"indices","sparseSegmentMean","int32"),o=q(e,"segmentIds","sparseSegmentMean","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.rank)throw new Error(`Indices should be Tensor1D but received shape\n          ${s.shape}`);if(1!==o.rank)throw new Error(`Segment ids should be Tensor1D but received shape\n          ${o.shape}`);return pe.runKernel(yi,{data:r,indices:s,segmentIds:o})}}),sparseSegmentSum:de({sparseSegmentSum_:function SS(n,t,e){const r=q(n,"data","sparseSegmentSum"),s=q(t,"indices","sparseSegmentSum","int32"),o=q(e,"segmentIds","sparseSegmentSum","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.rank)throw new Error(`Indices should be Tensor1D but received shape\n         ${s.shape}`);if(1!==o.rank)throw new Error(`Segment ids should be Tensor1D but received shape\n         ${o.shape}`);return pe.runKernel(k,{data:r,indices:s,segmentIds:o})}})},OS={stringNGrams:de({stringNGrams_:function MD(n,t,e,r,s,o,l,u){const d=q(n,"data","stringNGrams","string");if("string"!==d.dtype)throw new Error("Data must be of datatype string");if(1!==d.shape.length)throw new Error(`Data must be a vector, saw: ${d.shape}`);const h=q(t,"dataSplits","stringNGrams");if("int32"!==h.dtype)throw new Error("Data splits must be of datatype int32");const y=pe.runKernel(Ye,{data:d,dataSplits:h},{separator:e,nGramWidths:r,leftPad:s,rightPad:o,padWidth:l,preserveShortSequences:u});return{nGrams:y[0],nGramsSplits:y[1]}}}),stringSplit:de({stringSplit_:function ES(n,t,e=!0){const r=q(n,"input","stringSplit","string"),s=q(t,"delimiter","stringSplit","string");if(1!==r.rank)throw new Error(`Input should be Tensor1D but received shape ${r.shape}`);if(0!==s.rank)throw new Error(`Delimiter should be a scalar but received shape ${s.shape}`);const u=pe.runKernel(Ht,{input:r,delimiter:s},{skipEmpty:e});return{indices:u[0],values:u[1],shape:u[2]}}}),stringToHashBucketFast:de({stringToHashBucketFast_:function OD(n,t){const e=q(n,"input","stringToHashBucketFast","string"),r={numBuckets:t};if(t<=0)throw new Error("Number of buckets must be at least 1");return pe.runKernel(Dn,{input:e},r)}}),staticRegexReplace:de({staticRegexReplace_:function DS(n,t,e,r=!0){const s=q(n,"input","staticRegexReplace","string");return pe.runKernel(oe,{x:s},{pattern:t,rewrite:e,replaceGlobal:r})}})},FS="undefined"!=typeof requestAnimationFrame?requestAnimationFrame:"undefined"!=typeof setImmediate?setImmediate:n=>n();function Mg(n,t){const e=n[0].length;n.forEach((s,o)=>{G(s.length===e,()=>`Error in concat${e}D: rank of tensors[${o}] must be the same as the rank of the rest (${e})`)}),G(t>=0&&t<e,()=>`Error in concat${e}D: axis must be between 0 and ${e-1}.`);const r=n[0];n.forEach((s,o)=>{for(let l=0;l<e;l++)G(l===t||s[l]===r[l],()=>`Error in concat${e}D: Shape of tensors[${o}] (${s}) does not match the shape of the rest (${r}) along the non-concatenated axis ${o}.`)})}function fo(n,t){const e=n[0].slice();for(let r=1;r<n.length;r++)e[t]+=n[r][t];return e}var Bo=(()=>{return(n=Bo||(Bo={}))[n.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",n[n.VALUE_ROWIDS=1]="VALUE_ROWIDS",n[n.ROW_LENGTHS=2]="ROW_LENGTHS",n[n.ROW_SPLITS=3]="ROW_SPLITS",n[n.ROW_LIMITS=4]="ROW_LIMITS",n[n.ROW_STARTS=5]="ROW_STARTS",Bo;var n})();function Og(n,t,e){let r=new Array;if(null==e&&null==t)return r;if(null==t)for(;r.length<n+e.length;)r.push(-1);else r=t.slice();if(null==e)return r;if(n+e.length!==r.length)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.rank = ${n+e.length}, but shape.rank = ${r.length}`);for(let s=1;s<e.length;++s){const o=e[s],l=r[r.length-e.length+s],u=r[l];if(o>=0)if(u>=0){if(u!==o)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.shape[${s+n}] = ${o} but shape[${s+n}] = ${u}`)}else r[l]=o}return r}function Fg(n){const t={FIRST_DIM_SIZE:Bo.FIRST_DIM_SIZE,VALUE_ROWIDS:Bo.VALUE_ROWIDS,ROW_LENGTHS:Bo.ROW_LENGTHS,ROW_SPLITS:Bo.ROW_SPLITS,ROW_LIMITS:Bo.ROW_LIMITS,ROW_STARTS:Bo.ROW_STARTS},e=[];for(const r of n){if(!(r in t))break;e.push(t[r])}return e}function $g(n){return 0===n.length?0:n[0]===Bo.FIRST_DIM_SIZE?n.length-1:n.length}function Pg(n,t){if(null==n||null==t)return;const e=n.length,r=t.length;if(e>=r)throw new Error(`defaultValue.shape=${n} and ragged tensor flatValues.shape=${t}, are incompatible: defaultValue.rank = ${e} must be less than ragged tensor input flatValues.rank = ${r})`);for(let s=0;s<Math.min(e,r-1);++s){const o=n[s],l=t[s+1];if(o>=0&&l>=0&&1!==o&&o!==l)throw new Error(`defaultValue.shape=${n}, and ragged tensor input flatValues.shape=${t} are incompatible: defaultValue.shape[${s-n.length}] = ${o} but ragged tensor input.flatValues.shape[${s-n.length}] = ${l}`)}}const Lg=30;function jf(n){return n<=Lg?n:di(n,Math.floor(Math.sqrt(n)))}function u_(n,t,e){return[e*("number"==typeof n?n:n[0]),t*("number"==typeof n?n:n[1])]}function rh(n,t,e,r=!0){let s=[];if(r)s=s.concat(t.slice(0)),s.push(n[0]/e),s=s.concat(n.slice(1));else{s=s.concat(n[0]);const o=t.length;for(let l=0;l<o;++l)s=s.concat([n[l+1]/t[l],t[l]]);s=s.concat(n.slice(o+1))}return s}function sh(n,t,e=!0){const r=[];if(e){r.push(t);for(let s=t+1;s<n;++s)s<=2*t?(r.push(s),r.push(s-(t+1))):r.push(s)}else{const s=[],o=[];for(let l=1;l<n;++l)l>=2*t+1||l%2==1?o.push(l):s.push(l);r.push(...s),r.push(0),r.push(...o)}return r}function oh(n,t,e,r=!0){const s=[];s.push(r?n[0]/e:n[0]*e);for(let o=1;o<n.length;++o)s.push(o<=t.length?r?t[o-1]*n[o]:n[o]/t[o-1]:n[o]);return s}function Bg(n,t){const e=[0];for(let r=0;r<t;++r)e.push(n[r][0]);return e}function Vg(n,t,e){const r=n.slice(0,1);for(let s=0;s<e;++s)r.push(n[s+1]-t[s][0]-t[s][1]);return r}function Vc(n,t){const e=n.shape.length,r=t.shape.length;if(e<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${e}.`);if(r<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${r}.`);if("int32"!==t.dtype)throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.shape[r-1]>e)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${t.shape[r-1]} vs. ${e}`);if(0===Ee(n.shape))throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${n.shape}.`);const s=t.shape,o=s[s.length-1];let l=1;for(let g=0;g<s.length-1;++g)l*=s[g];const u=n.shape,d=s.slice();d.pop();let h=1;for(let g=o;g<e;++g)h*=u[g],d.push(u[g]);const p=[...Wt(n.shape).map(g=>g/h),1].slice(0,o);return[d,l,h,p]}const Ug=1.7580993408473768,ih=1.0507009873554805,ai=.3275911,zg=.254829592,ah=-.284496736,Uc=1.421413741,Hg=-1.453152027,Wg=1.061405429;function Qa(n,t){if(n.length!==t.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${n.length}, imag: ${t.length}.`);const e=new Float32Array(2*n.length);for(let r=0;r<e.length;r+=2)e[r]=n[r/2],e[r+1]=t[r/2];return e}function lh(n){const t=new Float32Array(n.length/2),e=new Float32Array(n.length/2);for(let r=0;r<n.length;r+=2)t[r/2]=n[r],e[r/2]=n[r+1];return{real:t,imag:e}}function ch(n){const t=Math.ceil(n.length/4),e=new Float32Array(t),r=new Float32Array(t);for(let s=0;s<n.length;s+=4)e[Math.floor(s/4)]=n[s],r[Math.floor(s/4)]=n[s+1];return{real:e,imag:r}}function d_(n){const t=Math.floor(n.length/4),e=new Float32Array(t),r=new Float32Array(t);for(let s=2;s<n.length;s+=4)e[Math.floor(s/4)]=n[s],r[Math.floor(s/4)]=n[s+1];return{real:e,imag:r}}function jg(n,t){return{real:n[2*t],imag:n[2*t+1]}}function Gg(n,t,e,r){n[2*r]=t,n[2*r+1]=e}function Kg(n,t){const e=new Float32Array(n/2),r=new Float32Array(n/2);for(let s=0;s<Math.ceil(n/2);s++){const o=(t?2:-2)*Math.PI*(s/n);e[s]=Math.cos(o),r[s]=Math.sin(o)}return{real:e,imag:r}}function Gf(n,t,e){const r=(e?2:-2)*Math.PI*(n/t);return{real:Math.cos(r),imag:Math.sin(r)}}const PS=/->/g;function uh(n,t){const e=((n=n.replace(/\s/g,"")).length-n.replace(PS,"").length)/"->".length;if(e<1)throw new Error("Equations without an arrow are not supported.");if(e>1)throw new Error('Equation must contain exactly one arrow ("->").');const[r,s]=n.split("->");G(-1===r.indexOf("..."),()=>'The ellipsis notation ("...") is not supported yet.');const o=r.split(","),l=o.length;if(t!==l)throw new Error(`Expected ${l} input tensors, received ${t}`);if(l>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const u=[];for(let y=0;y<s.length;++y){const b=s[y];if(!o.some(_=>-1!==_.indexOf(b)))throw new Error(`Output subscripts contain the label ${b} not present in the input subscripts.`);-1===u.indexOf(b)&&u.push(b)}for(let y=0;y<r.length;++y){const b=r[y];-1===u.indexOf(b)&&","!==b&&u.push(b)}const d=new Array(o.length);for(let y=0;y<l;++y){if(new Set(o[y].split("")).size!==o[y].length)throw new Error(`Found duplicate axes in input component ${o[y]}. Support for duplicate axes in input is not implemented yet.`);d[y]=[];for(let b=0;b<o[y].length;++b)d[y].push(u.indexOf(o[y][b]))}const h=u.length,g=[];for(let y=s.length;y<h;++y)g.push(y);return{allDims:u,summedDims:g,idDims:d}}function dh(n,t){let e=new Array(n);e.fill(-1);for(let s=0;s<t.length;++s)e[t[s]]=s;const r=[];for(let s=0;s<n;++s)-1===e[s]&&r.push(s);return e=e.filter(s=>-1!==s),{permutationIndices:e,expandDims:r}}function qf(n,t,e){const r=new Array(n);for(let s=0;s<e.length;++s){const o=e[s].shape;for(let l=0;l<t[s].length;++l)void 0===r[t[s][l]]?r[t[s][l]]=o[l]:G(r[t[s][l]]===o[l],()=>`Expected dimension ${r[t[s][l]]} at axis ${l} of input shaped ${JSON.stringify(o)}, but got dimension ${o[l]}`)}}function hh(n,t){const e=n,r=[];let s=0;0===n.length&&e.push(-1),s=n.length+1;for(let l=0;l<s;++l)r.push([]);const o=[];for(let l=0;l<e.length;++l){const d=BS(t,e[l]);for(const h of d)-1===o.indexOf(h)&&(r[l].push(h),o.push(h))}return{path:e,steps:r}}function fh(n){return n.every((t,e)=>t===e)}function BS(n,t){const e=[];for(let r=0;r<n.length;++r)(0===n[r].length||-1!==n[r].indexOf(t)||-1===t)&&e.push(r);return e}function qg(n,t,e=0){let r=[];if("number"==typeof t)G(n.shape[e]%t==0,()=>"Number of splits must evenly divide the axis."),r=new Array(t).fill(n.shape[e]/t);else{G(t.reduce((l,u)=>(-1===u&&(l+=1),l),0)<=1,()=>"There should be only one negative value in split array.");const o=t.indexOf(-1);if(-1!==o){const l=t.reduce((u,d)=>d>0?u+d:u);t[o]=n.shape[e]-l}G(n.shape[e]===t.reduce((l,u)=>l+u),()=>"The sum of sizes must match the size of the axis dimension."),r=t}return r}function f_(n){return`Received SparseTensor with denseShape[0] = 0 but\n  indices.shape[0] = ${n}`}function p_(n,t){return`indices(${n}, 0) is invalid: ${t} < 0`}function Xg(n,t,e){return`indices(${n}, 0) is invalid: ${t} >= ${e}`}function Xf(n,t){return`only one output dimension may be -1, not both ${n} and ${t}`}function Yg(n,t){return`size ${n} must be non-negative, not ${t}`}function Zg(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function Qg(n,t){return`Input to reshape is a SparseTensor with ${Ee(n)}\n  dense values, but the requested shape requires a multiple of ${Ee(t)}. inputShape=${n} outputShape= ${t}`}function Jg(n,t){return`Input to reshape is a tensor with ${Ee(n)} dense values, but the requested shape has ${Ee(t)}. inputShape=${n} outputShape=${t}`}function ey(){return"segment ids must be >= 0"}function ty(){return"segment ids are not increasing"}function ny(n,t){return`Segment id ${n} out of range [0, ${t}), possibly because segmentIds input is not sorted.`}function m_(n,t,e){return`Bad: indices[${n}] == ${t} out of range [0, ${e})`}function ry(n,t){let r,e=!1;for(n<=Lg?(r=n,e=!0):r=di(n,Math.floor(Math.sqrt(n)));!e;)r>t||r===n?e=!0:r=di(n,r+1);return r}function g_(n,t,e){const r=[],s=n.length;for(let o=0;o<s;o++)r.push(o!==t?n[o]:e);return r}function ks(n,t,e,r){const s=t.shape.length,o=n.shape.length;if(0!==r&&(r<-s||r>s))throw new Error(`Expect batchDims in the range of [-${s}, ${s}], but got ${r}`);if(r<0&&(r+=s),r>o)throw new Error(`batchDims (${r}) must be less than rank(x) (\n    ${o}).`);if(e<r)throw new Error(`batchDims (${r}) must be less than or equal to axis (${e}).`);for(let g=0;g<r;++g)if(n.shape[g]!==t.shape[g])throw new Error(`x.shape[${g}]: ${n.shape[g]} should be equal to indices.shape[${g}]: ${t.shape[g]}.`);const l=n.shape[e],u=[];let d=1,h=1,p=1;for(let g=0;g<r;++g)u.push(n.shape[g]),d*=n.shape[g];for(let g=r;g<e;g++)u.push(n.shape[g]),h*=n.shape[g];for(let g=r;g<s;g++)u.push(t.shape[g]);for(let g=e+1;g<o;g++)u.push(n.shape[g]),p*=n.shape[g];return{batchSize:d,sliceSize:p,outerSize:h,dimSize:l,outputShape:u}}function po(n){try{return n.map(t=>wi(t))}catch(t){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${t}`)}}function y_(n){return n.map(t=>oo(t))}!function yw(){for(const n of gw)jI(n)}(),Q().registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,n=>{n&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")});var VS,mo=(()=>{return(n=mo||(mo={}))[n.DT_INVALID=0]="DT_INVALID",n[n.DT_FLOAT=1]="DT_FLOAT",n[n.DT_DOUBLE=2]="DT_DOUBLE",n[n.DT_INT32=3]="DT_INT32",n[n.DT_UINT8=4]="DT_UINT8",n[n.DT_INT16=5]="DT_INT16",n[n.DT_INT8=6]="DT_INT8",n[n.DT_STRING=7]="DT_STRING",n[n.DT_COMPLEX64=8]="DT_COMPLEX64",n[n.DT_INT64=9]="DT_INT64",n[n.DT_BOOL=10]="DT_BOOL",n[n.DT_QINT8=11]="DT_QINT8",n[n.DT_QUINT8=12]="DT_QUINT8",n[n.DT_QINT32=13]="DT_QINT32",n[n.DT_BFLOAT16=14]="DT_BFLOAT16",n[n.DT_QINT16=15]="DT_QINT16",n[n.DT_QUINT16=16]="DT_QUINT16",n[n.DT_UINT16=17]="DT_UINT16",n[n.DT_COMPLEX128=18]="DT_COMPLEX128",n[n.DT_HALF=19]="DT_HALF",n[n.DT_RESOURCE=20]="DT_RESOURCE",n[n.DT_VARIANT=21]="DT_VARIANT",n[n.DT_UINT32=22]="DT_UINT32",n[n.DT_UINT64=23]="DT_UINT64",n[n.DT_FLOAT_REF=101]="DT_FLOAT_REF",n[n.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",n[n.DT_INT32_REF=103]="DT_INT32_REF",n[n.DT_UINT8_REF=104]="DT_UINT8_REF",n[n.DT_INT16_REF=105]="DT_INT16_REF",n[n.DT_INT8_REF=106]="DT_INT8_REF",n[n.DT_STRING_REF=107]="DT_STRING_REF",n[n.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",n[n.DT_INT64_REF=109]="DT_INT64_REF",n[n.DT_BOOL_REF=110]="DT_BOOL_REF",n[n.DT_QINT8_REF=111]="DT_QINT8_REF",n[n.DT_QUINT8_REF=112]="DT_QUINT8_REF",n[n.DT_QINT32_REF=113]="DT_QINT32_REF",n[n.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",n[n.DT_QINT16_REF=115]="DT_QINT16_REF",n[n.DT_QUINT16_REF=116]="DT_QUINT16_REF",n[n.DT_UINT16_REF=117]="DT_UINT16_REF",n[n.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",n[n.DT_HALF_REF=119]="DT_HALF_REF",n[n.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",n[n.DT_VARIANT_REF=121]="DT_VARIANT_REF",n[n.DT_UINT32_REF=122]="DT_UINT32_REF",n[n.DT_UINT64_REF=123]="DT_UINT64_REF",mo;var n})();!function(n){let t;var e;(e=t=n.CheckpointFormatVersion||(n.CheckpointFormatVersion={}))[e.LEGACY=0]="LEGACY",e[e.V1=1]="V1",e[e.V2=2]="V2"}(VS||(VS={}));const Yf={};function Zu(n){return Yf[n]}function $(n,t,e,r,s){const o=t.inputParams[n];if(o&&void 0!==o.inputIndexStart){const u=o.inputIndexStart,d=0===o.inputIndexEnd?void 0:void 0===o.inputIndexEnd?u+1:o.inputIndexEnd,h=u<0?t.inputNames.length+u:u;if("tensor"===o.type)return ws(t.inputNames[h],e,r,s);if("tensors"===o.type){const y=t.inputs.slice(u,d);return t.inputNames.slice(u,d).filter((_,I)=>{var S;return"NoOp"!==(null===(S=y[I])||void 0===S?void 0:S.op)}).map(_=>ws(_,e,r,s))}const p=ws(t.inputNames[h],e,r,s),g=p.dataSync();return"number"===o.type?g[0]:Pr(p.shape,g)}const l=t.attrParams[n];return l&&l.value}function ws(n,t,e,r){const[s,o]=go(n,e);if(null!=r){const u=r.getHashTableHandleByName(s);if(null!=u)return u}const l=e.currentContextIds.find(u=>!!t[Zf(s,u)]);return void 0!==l?t[Zf(s,l)][o]:void 0}function sy(n,t,e){return t[Zf(n,e.currentContextId)]}function Ja(n,t){const[e,r,s]=go(n,t);return[Zf(e,t&&t.currentContextId),r,s]}function Zf(n,t){return t?`${n}-${t}`:n}function go(n,t){if(""===n)return["",0,void 0];const e=null!=t&&null!=t.parseNodeNameCache;if(e){const o=t.parseNodeNameCache.get(n);if(null!=o)return o}const r=n.split(":");let s;if(1===r.length)s=[n,0,void 0];else{const l=3===r.length?r[1]:void 0;s=[r[0],Number(r[r.length-1]),l]}return e&&t.parseNodeNameCache.set(n,s),s}function ph(n,t,e){let r=$("pad",n,t,e);if("explicit"===r){r=$("explicitPaddings",n,t,e);const s=[[0,0],[0,0],[0,0],[0,0]];for(let o=0;o<4;o++)s[o][0]=r[2*o],s[o][1]=r[2*o+1];return s}return r}function ua(n){return n.kept?n:kl(n)}const Qf=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],oy=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsFinite",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsInf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],LD=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}],b_=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],zS=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniformInt",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number"},{tfName:"maxval",name:"maxval",type:"number"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],__=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],Qu=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}],HS=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],x_=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"InitializeTable",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]},{tfOpName:"InitializeTableV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],iy=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}],BD=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BitwiseAnd",category:"logical",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}]}],WS=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"MatrixBandPart",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"numLower",type:"tensor"},{start:1,name:"numUpper",type:"tensor"}]}],VD=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]}],jS=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],GS=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]},{tfOpName:"TensorScatterUpdate",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],KS=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}],w_=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],C_=[{tfOpName:"StaticRegexReplace",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"pattern",name:"pattern",type:"string"},{tfName:"rewrite",name:"rewrite",type:"string"},{tfName:"replace_global",name:"replaceGlobal",type:"bool"}]},{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}],qS=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"EnsureShape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}];class ay{static get Instance(){return this._instance||(this._instance=new this)}constructor(){const e=[].concat(...[Fe,ct,nt,he,Ie,we,_e,Ge,$e,ut,vt,bt,Jt,Cn,Dt,at,Ze,Xe,Ue].map(r=>r.json));this.opMappers=e.reduce((r,s)=>(r[s.tfOpName]=s,r),{})}transformGraph(t,e={}){const s=[],o=[],l=[],u=t.node.reduce((I,S)=>(I[S.name]=this.mapNode(S),S.op.startsWith("Placeholder")?s.push(I[S.name]):"Const"===S.op?o.push(I[S.name]):(null==S.input||0===S.input.length)&&l.push(I[S.name]),I),{});let d=[];const h=[];let p={},g={};null!=e&&(p=this.mapSignatureEntries(e.inputs),g=this.mapSignatureEntries(e.outputs));const y=Object.keys(u);y.forEach(I=>{const S=u[I];S.inputNames.forEach((T,O)=>{const[V,,U]=Ja(T),j=u[V];if(null!=j.outputs){const te=j.outputs.indexOf(U);-1!==te&&(S.inputNames[O]=`${V}:${te}`)}S.inputs.push(j),j.children.push(S)})}),0===Object.keys(g).length?y.forEach(I=>{const S=u[I];0===S.children.length&&h.push(S)}):Object.keys(g).forEach(I=>{const[S]=Ja(I),T=u[S];null!=T&&(T.signatureKey=g[I],h.push(T))}),Object.keys(p).length>0?Object.keys(p).forEach(I=>{const[S]=Ja(I),T=u[S];T&&(T.signatureKey=p[I],d.push(T))}):d=s;let b={};null!=t.library&&null!=t.library.function&&(b=t.library.function.reduce((I,S)=>(I[S.signature.name]=this.mapFunction(S),I),{}));const _={nodes:u,inputs:d,outputs:h,weights:o,placeholders:s,signature:e,functions:b};return l.length>0&&(_.initNodes=l),_}mapSignatureEntries(t){return Object.keys(t||{}).reduce((e,r)=>(e[t[r].name]=r,e),{})}mapNode(t){const e=Zu(t.op)||this.opMappers[t.op]||{};null==t.attr&&(t.attr={});const r={name:t.name,op:t.op,category:e.category,inputNames:(t.input||[]).map(s=>s.startsWith("^")?s.slice(1):s),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:t.attr,outputs:e.outputs};return null!=e.inputs&&(r.inputParams=e.inputs.reduce((s,o)=>(s[o.name]={type:o.type,inputIndexStart:o.start,inputIndexEnd:o.end},s),{})),null!=e.attrs&&(r.attrParams=e.attrs.reduce((s,o)=>{const l=o.type;let u;switch(o.type){case"string":u=ly(t.attr,o.tfName,o.defaultValue),void 0===u&&o.tfDeprecatedName&&(u=ly(t.attr,o.tfDeprecatedName,o.defaultValue));break;case"string[]":u=rp(t.attr,o.tfName,o.defaultValue),void 0===u&&o.tfDeprecatedName&&(u=rp(t.attr,o.tfDeprecatedName,o.defaultValue));break;case"number":u=cy(t.attr,o.tfName,o.defaultValue||0),void 0===u&&o.tfDeprecatedName&&(u=cy(t.attr,o.tfDeprecatedName,o.defaultValue));break;case"number[]":u=D_(t.attr,o.tfName,o.defaultValue),void 0===u&&o.tfDeprecatedName&&(u=D_(t.attr,o.tfDeprecatedName,o.defaultValue));break;case"bool":u=Jf(t.attr,o.tfName,o.defaultValue),void 0===u&&o.tfDeprecatedName&&(u=Jf(t.attr,o.tfDeprecatedName,o.defaultValue));break;case"bool[]":u=N_(t.attr,o.tfName,o.defaultValue),void 0===u&&o.tfDeprecatedName&&(u=N_(t.attr,o.tfDeprecatedName,o.defaultValue));break;case"shape":u=dy(t.attr,o.tfName,o.defaultValue),void 0===u&&o.tfDeprecatedName&&(u=dy(t.attr,o.tfDeprecatedName,o.defaultValue));break;case"shape[]":u=T_(t.attr,o.tfName,o.defaultValue),void 0===u&&o.tfDeprecatedName&&(u=T_(t.attr,o.tfDeprecatedName,o.defaultValue));break;case"dtype":u=tp(t.attr,o.tfName,o.defaultValue),void 0===u&&o.tfDeprecatedName&&(u=tp(t.attr,o.tfDeprecatedName,o.defaultValue));break;case"dtype[]":u=np(t.attr,o.tfName,o.defaultValue),void 0===u&&o.tfDeprecatedName&&(u=np(t.attr,o.tfDeprecatedName,o.defaultValue));break;case"func":u=uy(t.attr,o.tfName,o.defaultValue),void 0===u&&o.tfDeprecatedName&&(u=uy(t.attr,o.tfDeprecatedName,o.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${o.type} for op: ${t.op}`)}return s[o.name]={value:u,type:l},s},{})),r}mapFunction(t){const e=t.nodeDef,s=[];let o={};null!=e&&(o=e.reduce((g,y)=>(g[y.name]=this.mapNode(y),"Const"===y.op&&s.push(g[y.name]),g),{}));const l=[],u=[];t.signature.inputArg.forEach(g=>{const[y]=Ja(g.name),b={name:y,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:ep(g.type),type:"dtype"}},children:[]};b.signatureKey=g.name,l.push(b),o[y]=b}),Object.keys(o).forEach(g=>{const y=o[g];y.inputNames.forEach((b,_)=>{const[I,,S]=Ja(b),T=o[I];if(null!=T.outputs){const O=T.outputs.indexOf(S);-1!==O&&(y.inputNames[_]=`${I}:${O}`)}y.inputs.push(T),T.children.push(y)})});const h=t.ret;t.signature.outputArg.forEach(g=>{const[y,b]=Ja(h[g.name]),_=o[y];null!=_&&(_.defaultOutput=b,u.push(_))});const p=this.mapArgsToSignature(t);return{nodes:o,inputs:l,outputs:u,weights:s,placeholders:[],signature:p}}mapArgsToSignature(t){return{methodName:t.signature.name,inputs:t.signature.inputArg.reduce((e,r)=>(e[r.name]=this.mapArgToTensorInfo(r),e),{}),outputs:t.signature.outputArg.reduce((e,r)=>(e[r.name]=this.mapArgToTensorInfo(r,t.ret),e),{})}}mapArgToTensorInfo(t,e){let r=t.name;return null!=e&&(r=e[r]),{name:r,dtype:t.type}}}function E_(n,t){const e=Array.isArray(n)?String.fromCharCode.apply(null,n):function S_(n){const t=Q().global;if(void 0!==t.atob)return t.atob(n);if("undefined"!=typeof Buffer)return new Buffer(n,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}(n);return t?e:e.toLowerCase()}function ly(n,t,e,r=!1){const s=n[t];return null!=s?E_(s.s,r):e}function Jf(n,t,e){const r=n[t];return r?r.b:e}function cy(n,t,e){const r=n[t]||{},s=null!=r.i?r.i:null!=r.f?r.f:e;return"number"==typeof s?s:parseInt(s,10)}function ep(n){switch("string"==typeof n&&(n=mo[n]),n){case mo.DT_FLOAT:case mo.DT_HALF:return"float32";case mo.DT_INT32:case mo.DT_INT64:case mo.DT_INT8:case mo.DT_UINT8:return"int32";case mo.DT_BOOL:return"bool";case mo.DT_DOUBLE:return"float32";case mo.DT_STRING:return"string";case mo.DT_COMPLEX64:case mo.DT_COMPLEX128:return"complex64";default:return null}}function uy(n,t,e){const r=n[t];return r&&r.func?r.func.name:e}function tp(n,t,e){const r=n[t];return r&&r.type?ep(r.type):e}function np(n,t,e){const r=n[t];return r&&r.list&&r.list.type?r.list.type.map(s=>ep(s)):e}function I_(n){if(!n.unknownRank)return null!=n.dim?n.dim.map(t=>"number"==typeof t.size?t.size:parseInt(t.size,10)):[]}function dy(n,t,e){const r=n[t];return r&&r.shape?I_(r.shape):e}function D_(n,t,e){const r=n[t];return r?((r.list.f&&r.list.f.length?r.list.f:r.list.i)||[]).map(s=>"number"==typeof s?s:parseInt(s,10)):e}function rp(n,t,e,r=!1){const s=n[t];return s&&s.list&&s.list.s?s.list.s.map(o=>E_(o,r)):e}function T_(n,t,e){const r=n[t];return r&&r.list&&r.list.shape?r.list.shape.map(s=>I_(s)):e}function N_(n,t,e){const r=n[t];return r&&r.list&&r.list.b?r.list.b:e}class UD{constructor(t,e,r){this.node=t,this.tensorMap=e,this.context=r,this.inputs=[],this.attrs={},this.inputs=t.inputNames.map(s=>this.getInput(s)),null!=t.rawAttrs&&(this.attrs=Object.keys(t.rawAttrs).reduce((s,o)=>(s[o]=this.getAttr(o),s),{}))}getInput(t){return ws(t,this.tensorMap,this.context)}getAttr(t,e){const r=this.node.rawAttrs[t];if(null!=r.tensor)return ws(t,this.tensorMap,this.context);if(null!=r.i||null!=r.f)return cy(this.node.rawAttrs,t,e);if(null!=r.s)return ly(this.node.rawAttrs,t,e);if(null!=r.b)return Jf(this.node.rawAttrs,t,e);if(null!=r.shape)return dy(this.node.rawAttrs,t,e);if(null!=r.type)return tp(this.node.rawAttrs,t,e);if(null!=r.list){if(null!=r.list.i||null!=r.list.f)return D_(this.node.rawAttrs,t,e);if(null!=r.list.s)return rp(this.node.rawAttrs,t,e);if(null!=r.list.shape)return T_(this.node.rawAttrs,t,e);if(null!=r.list.b)return N_(this.node.rawAttrs,t,e);if(null!=r.list.type)return np(this.node.rawAttrs,t,e)}return e}}function Ni(n,t,e=""){if("number"!=typeof n&&"number"!=typeof t){G(n.length===t.length,()=>e+` Shapes ${n} and ${t} must match`);for(let r=0;r<n.length;r++){const s=n[r],o=t[r];G(s<0||o<0||s===o,()=>e+` Shapes ${n} and ${t} must match`)}}}function mh(n){return!("number"==typeof n||n.some(t=>t<0))}function sp(n,t,e){let r=op(n,e);const s=!mh(r);if(s&&0===t.length)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${r}`);if(s&&t.forEach(o=>{r=op(o.shape,r)}),!mh(r))throw new Error(`Non-fully-defined elementShape: ${r}`);return r}function op(n,t){if("number"==typeof n)return t;if("number"==typeof t)return n;if(n.length!==t.length)throw new Error(`Incompatible ranks during merge: ${n} vs. ${t}`);const e=[];for(let r=0;r<n.length;++r){const s=n[r],o=t[r];if(s>=0&&o>=0&&s!==o)throw new Error(`Incompatible shape during merge: ${n} vs. ${t}`);e[r]=s>=0?s:o}return e}class ip{constructor(t,e,r,s,o,l,u){this.name=t,this.dtype=e,this.maxSize=r,this.elementShape=s,this.identicalElementShapes=o,this.dynamicSize=l,this.clearAfterRead=u,this.tensors=[],this.closed_=!1,this.idTensor=xn(0),Ji(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(t){this.tensors.forEach(e=>{(null==t||!t.has(e.tensor.id))&&e.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(t<0||t>=this.size())throw new Error(`Tried to read from index ${t}, but array size is: ${this.size()}`);const e=this.tensors[t];if(e.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${t} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(e.cleared=!0),e.read=!0,e.tensor}readMany(t){return t.map(e=>this.read(e))}write(t,e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(t<0||!this.dynamicSize&&t>=this.maxSize)throw new Error(`Tried to write to index ${t}, but array is not resizeable and size is: ${this.maxSize}`);const r=this.tensors[t]||{};if(e.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${t},\n          because the value dtype is ${e.dtype}, but TensorArray dtype is ${this.dtype}.`);if(0===this.size()&&(null==this.elementShape||0===this.elementShape.length)&&(this.elementShape=e.shape),Ni(this.elementShape,e.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${t}.`),r.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${t}, because it has already been read.`);if(r.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${t}, because it has already been written.`);r.tensor=e,Ji(e),r.written=!0,this.tensors[t]=r}writeMany(t,e){if(t.length!==e.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${t.length} is not the same as tensors size: ${e.length}.`);t.forEach((r,s)=>this.write(r,e[s]))}gather(t,e){if(e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${e}`);if(t)t=t.slice(0,this.size());else{t=[];for(let s=0;s<this.size();s++)t.push(s)}if(0===t.length)return Va([],[0].concat(this.elementShape));const r=this.readMany(t);return Ni(this.elementShape,r[0].shape,"TensorArray shape mismatch: "),Ya(r,0)}concat(t){if(t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${t}`);if(0===this.size())return Va([],[0].concat(this.elementShape));const e=[];for(let s=0;s<this.size();s++)e.push(s);const r=this.readMany(e);return Ni(this.elementShape,r[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${r[0].shape})`),zs(r,0)}scatter(t,e){if(e.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${e.dtype}`);if(t.length!==e.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${t.length} vs. ${e.shape[0]}`);const r=Math.max(...t);if(!this.dynamicSize&&r>=this.maxSize)throw new Error(`Max index must be < array size (${r}  vs. ${this.maxSize})`);this.writeMany(t,zl(e,0))}split(t,e){if(e.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${e.dtype}`);let r=0;const s=t.map(d=>(r+=d,r));if(r!==e.shape[0])throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${r}, and tensor's shape is: ${e.shape}`);if(!this.dynamicSize&&t.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${t.length}), and the TensorArray is not marked as dynamically resizeable`);const o=0===r?0:e.size/r,l=[];En(()=>{e=tt(e,[1,r,o]);for(let d=0;d<t.length;++d)l[d]=tt(Pn(e,[0,0===d?0:s[d-1],0],[1,t[d],o]),this.elementShape);return l});const u=[];for(let d=0;d<t.length;d++)u[d]=d;this.writeMany(u,l)}}class Wl{get id(){return this.idTensor.id}constructor(t,e,r,s=-1){this.tensors=t,this.elementShape=e,this.elementDtype=r,null!=t&&t.forEach(o=>{if(r!==o.dtype)throw new Error(`Invalid data types; op elements ${r}, but list elements ${o.dtype}`);Ni(e,o.shape,"TensorList shape mismatch: "),Ji(o)}),this.idTensor=xn(0),this.maxNumElements=s,Ji(this.idTensor)}copy(){return new Wl([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(t){this.tensors.forEach(e=>{(null==t||!t.has(e.id))&&e.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(t,e,r=-1){if(e!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e}, but list elements ${this.elementDtype}`);if(-1!==r&&this.tensors.length!==r)throw new Error(`Operation expected a list with ${r} elements but got a list with ${this.tensors.length} elements.`);Ni(t,this.elementShape,"TensorList shape mismatch: ");const s=sp(this.elementShape,this.tensors,t);return En(()=>{const o=this.tensors.map(l=>tt(l,s));return Ya(o,0)})}popBack(t,e){if(e!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e}, but list elements ${this.elementDtype}`);if(0===this.size())throw new Error("Trying to pop from an empty list.");const r=sp(this.elementShape,this.tensors,t),s=this.tensors.pop();return s.kept=!1,Ni(s.shape,t,"TensorList shape mismatch: "),tt(s,r)}pushBack(t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(Ni(t.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");Ji(t),this.tensors.push(t)}resize(t){if(t<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${t}`);if(-1!==this.maxNumElements&&t>this.maxNumElements)throw new Error(`TensorListResize input size ${t} is greater maxNumElement ${this.maxNumElements}.`);const e=new Wl([],this.elementShape,this.elementDtype,this.maxNumElements);e.tensors.length=t;for(let r=0;r<Math.min(this.tensors.length,t);++r)e.tensors[r]=this.tensors[r];return e}getItem(t,e,r){if(r!==this.elementDtype)throw new Error(`Invalid data types; op elements ${r}, but list elements ${this.elementDtype}`);if(t<0||t>this.tensors.length)throw new Error(`Trying to access element ${t} in a list with ${this.tensors.length} elements.`);if(null==this.tensors[t])throw new Error(`element at index ${t} is null.`);Ni(this.tensors[t].shape,e,"TensorList shape mismatch: ");const s=sp(this.elementShape,this.tensors,e);return tt(this.tensors[t],s)}setItem(t,e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(t<0||-1!==this.maxNumElements&&t>=this.maxNumElements)throw new Error(`Trying to set element ${t} in a list with max ${this.maxNumElements} elements.`);Ni(this.elementShape,e.shape,"TensorList shape mismatch: "),Ji(e),null!=this.tensors[t]&&(this.tensors[t].kept=!1),this.tensors[t]=e}gather(t,e,r){if(e!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e}, but list elements ${this.elementDtype}`);Ni(this.elementShape,r,"TensorList shape mismatch: "),t=t.slice(0,this.size());const s=sp(this.elementShape,this.tensors,r);return 0===t.length?Va([],[0].concat(s)):En(()=>{const o=t.map(l=>tt(this.tensors[l],s));return Ya(o,0)})}concat(t,e){if(t&&t!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${t}`);Ni(this.elementShape,e,"TensorList shape mismatch: ");const r=sp(this.elementShape,this.tensors,e);return 0===this.size()?Va([],[0].concat(r)):En(()=>{const s=this.tensors.map(o=>tt(o,r));return zs(s,0)})}}const XS=function(){var n=xe(function*(t,e,r){switch(t.op){case"If":case"StatelessIf":{const s=$("thenBranch",t,e,r),o=$("elseBranch",t,e,r),l=$("cond",t,e,r),u=$("args",t,e,r);return(yield l.data())[0]?r.functionMap[s].executeFunctionAsync(u,r.tensorArrayMap,r.tensorListMap):r.functionMap[o].executeFunctionAsync(u,r.tensorArrayMap,r.tensorListMap)}case"While":case"StatelessWhile":{const s=$("body",t,e,r),o=$("cond",t,e,r),l=$("args",t,e,r),u=yield r.functionMap[o].executeFunctionAsync(l,r.tensorArrayMap,r.tensorListMap),d=l.map(g=>g.id);let h=yield u[0].data();u.forEach(g=>{!g.kept&&-1===d.indexOf(g.id)&&g.dispose()});let p=l;for(;h[0];){const g=p;p=yield r.functionMap[s].executeFunctionAsync(p,r.tensorArrayMap,r.tensorListMap);const y=p.map(_=>_.id);g.forEach(_=>{!_.kept&&-1===d.indexOf(_.id)&&-1===y.indexOf(_.id)&&_.dispose()});const b=yield r.functionMap[o].executeFunctionAsync(p,r.tensorArrayMap,r.tensorListMap);h=yield b[0].data(),b.forEach(_=>{!_.kept&&-1===d.indexOf(_.id)&&-1===y.indexOf(_.id)&&_.dispose()})}return p}case"LoopCond":return[ua($("pred",t,e,r))];case"Switch":{const s=$("pred",t,e,r);let o=$("data",t,e,r);return o.kept||(o=ua(o)),(yield s.data())[0]?[void 0,o]:[o,void 0]}case"Merge":{const s=t.inputNames.find(o=>void 0!==ws(o,e,r));return s?[ua(ws(s,e,r))]:void 0}case"Enter":{const s=$("frameName",t,e,r),o=$("tensor",t,e,r);return r.enterFrame(s),[ua(o)]}case"Exit":{const s=$("tensor",t,e,r);return r.exitFrame(),[ua(s)]}case"NextIteration":{const s=$("tensor",t,e,r);return r.nextIteration(),[ua(s)]}case"TensorArrayV3":{const s=$("size",t,e,r),o=$("dtype",t,e,r),l=$("elementShape",t,e,r),u=$("dynamicSize",t,e,r),d=$("clearAfterRead",t,e,r),h=$("identicalElementShapes",t,e,r),p=$("name",t,e,r),g=new ip(p,o,s,l,h,u,d);return r.addTensorArray(g),[g.idTensor,xn(1)]}case"TensorArrayWriteV3":{const s=$("tensorArrayId",t,e,r),o=$("index",t,e,r),l=$("tensor",t,e,r),u=r.getTensorArray(s.id);return u.write(o,l),[u.idTensor]}case"TensorArrayReadV3":{const s=$("tensorArrayId",t,e,r),o=$("index",t,e,r);return[r.getTensorArray(s.id).read(o)]}case"TensorArrayGatherV3":{const s=$("tensorArrayId",t,e,r),o=$("indices",t,e,r),l=$("dtype",t,e,r);return[r.getTensorArray(s.id).gather(o,l)]}case"TensorArrayScatterV3":{const s=$("tensorArrayId",t,e,r),o=$("indices",t,e,r),l=$("tensor",t,e,r),u=r.getTensorArray(s.id);return u.scatter(o,l),[u.idTensor]}case"TensorArrayConcatV3":{const s=$("tensorArrayId",t,e,r),o=r.getTensorArray(s.id),l=$("dtype",t,e,r);return[o.concat(l)]}case"TensorArraySplitV3":{const s=$("tensorArrayId",t,e,r),o=$("tensor",t,e,r),l=$("lengths",t,e,r),u=r.getTensorArray(s.id);return u.split(l,o),[u.idTensor]}case"TensorArraySizeV3":{const s=$("tensorArrayId",t,e,r);return[xn(r.getTensorArray(s.id).size(),"int32")]}case"TensorArrayCloseV3":{const s=$("tensorArrayId",t,e,r),o=r.getTensorArray(s.id);return o.clearAndClose(),[o.idTensor]}case"TensorListSetItem":{const s=$("tensorListId",t,e,r),o=$("index",t,e,r),l=$("tensor",t,e,r),u=r.getTensorList(s.id);return u.setItem(o,l),[u.idTensor]}case"TensorListGetItem":{const s=$("tensorListId",t,e,r),o=$("index",t,e,r),l=$("elementShape",t,e,r),u=$("elementDType",t,e,r);return[r.getTensorList(s.id).getItem(o,l,u)]}case"TensorListScatterV2":case"TensorListScatter":{const s=$("indices",t,e,r),d=function hy(n,t,e,r){if(t.length!==n.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${t.length} vs. ${n.shape[0]}`);const s=Math.max(...t);if(null!=r&&-1!==r&&s>=r)throw new Error(`Max index must be < array size (${s}  vs. ${r})`);const o=new Wl([],e,n.dtype,r),l=zl(n,0);return t.forEach((u,d)=>{o.setItem(u,l[d])}),o}($("tensor",t,e,r),s,$("elementShape",t,e,r),$("numElements",t,e,r));return r.addTensorList(d),[d.idTensor]}case"TensorListReserve":case"EmptyTensorList":{const s=$("elementShape",t,e,r),o=$("elementDType",t,e,r);let l;l="TensorListReserve"===t.op?"numElements":"maxNumElements";const u=$(l,t,e,r),h=function WD(n,t,e,r){return new Wl([],n,t,r)}(s,o,0,"TensorListReserve"===t.op?-1:u);return r.addTensorList(h),[h.idTensor]}case"TensorListGather":{const s=$("tensorListId",t,e,r),o=$("indices",t,e,r),l=$("elementShape",t,e,r),u=$("elementDType",t,e,r);return[r.getTensorList(s.id).gather(o,u,l)]}case"TensorListStack":{const s=$("tensorListId",t,e,r),o=$("elementShape",t,e,r),l=$("elementDType",t,e,r),u=$("numElements",t,e,r);return[r.getTensorList(s.id).stack(o,l,u)]}case"TensorListFromTensor":{const u=function k_(n,t,e){const r=n.dtype;if(n.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${n.shape}`);if(n.dtype!==e)throw new Error(`Invalid data types; op elements ${n.dtype}, but list elements ${e}`);Ni(n.shape.slice(1),t,"TensorList shape mismatch: ");const o=zl(n);return new Wl(o,t,r)}($("tensor",t,e,r),$("elementShape",t,e,r),$("elementDType",t,e,r));return r.addTensorList(u),[u.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{const s=$("tensorListId",t,e,r),o=r.getTensorList(s.id),l=$("dtype",t,e,r),u=$("elementShape",t,e,r);return[o.concat(l,u)]}case"TensorListPushBack":{const s=$("tensorListId",t,e,r),o=$("tensor",t,e,r),l=r.getTensorList(s.id);return l.pushBack(o),[l.idTensor]}case"TensorListPopBack":{const s=$("tensorListId",t,e,r),o=$("elementShape",t,e,r),l=$("elementDType",t,e,r);return[r.getTensorList(s.id).popBack(o,l)]}case"TensorListSplit":{const s=$("tensor",t,e,r),o=$("elementShape",t,e,r),u=function A_(n,t,e){let r=0;const s=t.map(p=>(r+=p,r));if(r!==n.shape[0])throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${r}, and tensor's shape is: ${n.shape}`);const l=op(n.shape.slice(1),e),u=0===r?0:n.size/r,d=En(()=>{const p=[];n=tt(n,[1,r,u]);for(let g=0;g<t.length;++g)p[g]=tt(Pn(n,[0,0===g?0:s[g-1],0],[1,t[g],u]),l);return n.dispose(),p}),h=new Wl([],e,n.dtype,t.length);for(let p=0;p<d.length;p++)h.setItem(p,d[p]);return h}(s,$("lengths",t,e,r),o);return r.addTensorList(u),[u.idTensor]}case"TensorListLength":{const s=$("tensorListId",t,e,r);return[xn(r.getTensorList(s.id).size(),"int32")]}case"TensorListResize":{const s=$("tensorListId",t,e,r),o=$("size",t,e,r),u=r.getTensorList(s.id).resize(o);return r.addTensorList(u),[u.idTensor]}default:throw TypeError(`Node type ${t.op} is not implemented`)}});return function(e,r,s){return n.apply(this,arguments)}}();function ZS(n,t,e){const[r,s]=$("fusedOps",n,t,e),o="biasadd"===r,l=!o,u="prelu"===s,d="fusedbatchnorm"===r,h=$("numArgs",n,t,e);if(o){if(u&&2!==h)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!u&&o&&1!==h)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(d)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");const p=$("strides",n,t,e),g=ph(n,t,e),y=$("dataFormat",n,t,e).toUpperCase(),b=$("dilations",n,t,e);let[_,I]=$("args",n,t,e);return l&&(I=_,_=void 0),{stride:p,pad:g,dataFormat:y,dilations:b,biasArg:_,preluArg:I,activationFunc:s,leakyreluAlpha:$("leakyreluAlpha",n,t,e)}}function py(n,t,e){return{boxes:$("boxes",n,t,e),scores:$("scores",n,t,e),maxOutputSize:$("maxOutputSize",n,t,e),iouThreshold:$("iouThreshold",n,t,e),scoreThreshold:$("scoreThreshold",n,t,e),softNmsSigma:$("softNmsSigma",n,t,e)}}const GD=function(){var n=xe(function*(t,e,r,s,o=ie){switch(t.op){case"NonMaxSuppressionV5":{const{boxes:l,scores:u,maxOutputSize:d,iouThreshold:h,scoreThreshold:p,softNmsSigma:g}=py(t,e,r),y=yield o.image.nonMaxSuppressionWithScoreAsync(l,u,d,h,p,g);return[y.selectedIndices,y.selectedScores]}case"NonMaxSuppressionV4":{const{boxes:l,scores:u,maxOutputSize:d,iouThreshold:h,scoreThreshold:p}=py(t,e,r),g=$("padToMaxOutputSize",t,e,r),y=yield o.image.nonMaxSuppressionPaddedAsync(l,u,d,h,p,g);return[y.selectedIndices,y.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{const{boxes:l,scores:u,maxOutputSize:d,iouThreshold:h,scoreThreshold:p}=py(t,e,r);return[yield o.image.nonMaxSuppressionAsync(l,u,d,h,p)]}case"Where":{const l=o.cast($("condition",t,e,r),"bool"),u=[yield o.whereAsync(l)];return l.dispose(),u}case"ListDiff":return o.setdiff1dAsync($("x",t,e,r),$("y",t,e,r));default:throw TypeError(`Node type ${t.op} is not implemented`)}});return function(e,r,s,o){return n.apply(this,arguments)}}();class YD{get id(){return this.handle.id}constructor(t,e){this.keyDType=t,this.valueDType=e,this.handle=xn(0),this.tensorMap=new Map,Ji(this.handle)}clearAndClose(){this.tensorMap.forEach(t=>t.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return xn(this.size(),"int32")}import(t,e){var r=this;return xe(function*(){r.checkKeyAndValueTensor(t,e);const s=yield t.data();return r.tensorMap.forEach(o=>o.dispose()),r.tensorMap.clear(),En(()=>{const o=zl(e),l=s.length,u=o.length;G(l===u,()=>`The number of elements doesn't match, keys has ${l} elements, the values has ${u} elements.`);for(let d=0;d<l;d++){const h=s[d],p=o[d];Ji(p),r.tensorMap.set(h,p)}return r.handle})})()}find(t,e){var r=this;return xe(function*(){r.checkKeyAndValueTensor(t,e);const s=yield t.data();return En(()=>{const o=[];for(let l=0;l<s.length;l++){const d=r.findWithDefault(s[l],e);o.push(d)}return Ya(o)})})()}findWithDefault(t,e){const r=this.tensorMap.get(t);return null!=r?r:e}checkKeyAndValueTensor(t,e){if(t.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${t.dtype}`);if(e.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${e.dtype}`)}}const tE=function(){var n=xe(function*(t,e,r,s){switch(t.op){case"HashTable":case"HashTableV2":{const o=s.getHashTableHandleByName(t.name);if(null!=o)return[o];{const l=$("keyDType",t,e,r),u=$("valueDType",t,e,r),d=new YD(l,u);return s.addHashTable(t.name,d),[d.handle]}}case"InitializeTable":case"InitializeTableV2":case"LookupTableImport":case"LookupTableImportV2":{const o=$("tableHandle",t,e,r,s),l=$("keys",t,e,r),u=$("values",t,e,r);return[yield s.getHashTableById(o.id).import(l,u)]}case"LookupTableFind":case"LookupTableFindV2":{const o=$("tableHandle",t,e,r,s),l=$("keys",t,e,r),u=$("defaultValue",t,e,r);return[yield s.getHashTableById(o.id).find(l,u)]}case"LookupTableSize":case"LookupTableSizeV2":{const o=$("tableHandle",t,e,r,s);return[s.getHashTableById(o.id).tensorSize()]}default:throw TypeError(`Node type ${t.op} is not implemented`)}});return function(e,r,s,o){return n.apply(this,arguments)}}();function yy(n,t,e,r,s=En){const o=((l,u,d)=>{switch(l.category){case"arithmetic":return s(()=>((n,t,e,r=ie)=>{switch(n.op){case"BiasAdd":case"AddV2":case"Add":return[r.add($("a",n,t,e),$("b",n,t,e))];case"AddN":return[r.addN($("tensors",n,t,e))];case"FloorMod":case"Mod":return[r.mod($("a",n,t,e),$("b",n,t,e))];case"Mul":return[r.mul($("a",n,t,e),$("b",n,t,e))];case"RealDiv":case"Div":return[r.div($("a",n,t,e),$("b",n,t,e))];case"DivNoNan":return[r.divNoNan($("a",n,t,e),$("b",n,t,e))];case"FloorDiv":return[r.floorDiv($("a",n,t,e),$("b",n,t,e))];case"Sub":return[r.sub($("a",n,t,e),$("b",n,t,e))];case"Minimum":return[r.minimum($("a",n,t,e),$("b",n,t,e))];case"Maximum":return[r.maximum($("a",n,t,e),$("b",n,t,e))];case"Pow":return[r.pow($("a",n,t,e),$("b",n,t,e))];case"SquaredDifference":return[r.squaredDifference($("a",n,t,e),$("b",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}})(l,u,d));case"basic_math":return s(()=>((n,t,e,r=ie)=>{switch(n.op){case"Abs":case"ComplexAbs":return[r.abs($("x",n,t,e))];case"Acos":return[r.acos($("x",n,t,e))];case"Acosh":return[r.acosh($("x",n,t,e))];case"Asin":return[r.asin($("x",n,t,e))];case"Asinh":return[r.asinh($("x",n,t,e))];case"Atan":return[r.atan($("x",n,t,e))];case"Atan2":return[r.atan2($("x",n,t,e),$("y",n,t,e))];case"Atanh":return[r.atanh($("x",n,t,e))];case"Ceil":return[r.ceil($("x",n,t,e))];case"Complex":return[r.complex($("real",n,t,e),$("imag",n,t,e))];case"Cos":return[r.cos($("x",n,t,e))];case"Cosh":return[r.cosh($("x",n,t,e))];case"Elu":return[r.elu($("x",n,t,e))];case"Erf":return[r.erf($("x",n,t,e))];case"Exp":return[r.exp($("x",n,t,e))];case"Expm1":return[r.expm1($("x",n,t,e))];case"Floor":return[r.floor($("x",n,t,e))];case"Log":return[r.log($("x",n,t,e))];case"Log1p":return[r.log1p($("x",n,t,e))];case"Imag":return[r.imag($("x",n,t,e))];case"Neg":return[r.neg($("x",n,t,e))];case"Reciprocal":return[r.reciprocal($("x",n,t,e))];case"Real":return[r.real($("x",n,t,e))];case"Relu":return[r.relu($("x",n,t,e))];case"Round":return[r.round($("x",n,t,e))];case"Selu":return[r.selu($("x",n,t,e))];case"Sigmoid":return[r.sigmoid($("x",n,t,e))];case"Sin":return[r.sin($("x",n,t,e))];case"Sign":return[r.sign($("x",n,t,e))];case"Sinh":return[r.sinh($("x",n,t,e))];case"Softplus":return[r.softplus($("x",n,t,e))];case"Sqrt":return[r.sqrt($("x",n,t,e))];case"Square":return[r.square($("x",n,t,e))];case"Tanh":return[r.tanh($("x",n,t,e))];case"Tan":return[r.tan($("x",n,t,e))];case"ClipByValue":return[r.clipByValue($("x",n,t,e),$("clipValueMin",n,t,e),$("clipValueMax",n,t,e))];case"Relu6":return[r.relu6($("x",n,t,e))];case"Rsqrt":return[r.rsqrt(ws(n.inputNames[0],t,e))];case"LeakyRelu":return[r.leakyRelu($("x",n,t,e),$("alpha",n,t,e))];case"Prelu":return[r.prelu($("x",n,t,e),$("alpha",n,t,e))];case"IsNan":return[r.isNaN(ws(n.inputNames[0],t,e))];case"IsInf":return[r.isInf(ws(n.inputNames[0],t,e))];case"IsFinite":return[r.isFinite(ws(n.inputNames[0],t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}})(l,u,d));case"control":return XS(l,u,d);case"convolution":return s(()=>((n,t,e,r=ie)=>{switch(n.op){case"Conv1D":{const s=$("stride",n,t,e),o=$("pad",n,t,e),l=$("dataFormat",n,t,e).toUpperCase(),u=$("dilation",n,t,e);return[r.conv1d($("x",n,t,e),$("filter",n,t,e),s,o,l,u)]}case"Conv2D":{const s=$("strides",n,t,e),o=ph(n,t,e),l=$("dataFormat",n,t,e).toUpperCase(),u=$("dilations",n,t,e);return[r.conv2d($("x",n,t,e),$("filter",n,t,e),[s[1],s[2]],o,l,[u[1],u[2]])]}case"_FusedConv2D":{const{stride:s,pad:o,dataFormat:l,dilations:u,biasArg:d,preluArg:h,activationFunc:p,leakyreluAlpha:g}=ZS(n,t,e);return[r.fused.conv2d({x:$("x",n,t,e),filter:$("filter",n,t,e),strides:[s[1],s[2]],pad:o,dataFormat:l,dilations:[u[1],u[2]],bias:d,activation:p,preluActivationWeights:h,leakyreluAlpha:g})]}case"FusedDepthwiseConv2dNative":{const{stride:s,pad:o,dataFormat:l,dilations:u,biasArg:d,preluArg:h,activationFunc:p,leakyreluAlpha:g}=ZS(n,t,e);return[r.fused.depthwiseConv2d({x:$("x",n,t,e),filter:$("filter",n,t,e),strides:[s[1],s[2]],pad:o,dataFormat:l,dilations:[u[1],u[2]],bias:d,activation:p,preluActivationWeights:h,leakyreluAlpha:g})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{const s=$("outputShape",n,t,e),o=$("strides",n,t,e),l=ph(n,t,e);return[r.conv2dTranspose($("x",n,t,e),$("filter",n,t,e),s,[o[1],o[2]],l)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{const s=$("strides",n,t,e),o=ph(n,t,e),l=$("dilations",n,t,e),u=$("dataFormat",n,t,e).toUpperCase();return[r.depthwiseConv2d($("input",n,t,e),$("filter",n,t,e),[s[1],s[2]],o,u,[l[1],l[2]])]}case"Conv3D":{const s=$("strides",n,t,e),o=$("pad",n,t,e),l=$("dataFormat",n,t,e).toUpperCase(),u=$("dilations",n,t,e);return[r.conv3d($("x",n,t,e),$("filter",n,t,e),[s[1],s[2],s[3]],o,l,[u[1],u[2],u[3]])]}case"AvgPool":{const s=$("strides",n,t,e),o=$("pad",n,t,e),l=$("kernelSize",n,t,e);return[r.avgPool($("x",n,t,e),[l[1],l[2]],[s[1],s[2]],o)]}case"MaxPool":{const s=$("strides",n,t,e),o=$("pad",n,t,e),l=$("kernelSize",n,t,e);return[r.maxPool($("x",n,t,e),[l[1],l[2]],[s[1],s[2]],o)]}case"MaxPoolWithArgmax":{const s=$("strides",n,t,e),o=$("pad",n,t,e),l=$("kernelSize",n,t,e),u=$("includeBatchInIndex",n,t,e),{result:d,indexes:h}=r.maxPoolWithArgmax($("x",n,t,e),[l[1],l[2]],[s[1],s[2]],o,u);return[d,h]}case"AvgPool3D":{const s=$("strides",n,t,e),o=$("pad",n,t,e),l=$("kernelSize",n,t,e);return[r.avgPool3d($("x",n,t,e),[l[1],l[2],l[3]],[s[1],s[2],s[3]],o)]}case"MaxPool3D":{const s=$("strides",n,t,e),o=$("pad",n,t,e),l=$("kernelSize",n,t,e);return[r.maxPool3d($("x",n,t,e),[l[1],l[2],l[3]],[s[1],s[2],s[3]],o)]}case"Dilation2D":{const s=$("strides",n,t,e),o=$("pad",n,t,e),l=$("dilations",n,t,e),u=s[1],d=s[2],h=l[1],p=l[2];return[r.dilation2d($("x",n,t,e),$("filter",n,t,e),[u,d],o,[h,p],"NHWC")]}default:throw TypeError(`Node type ${n.op} is not implemented`)}})(l,u,d));case"creation":return s(()=>((n,t,e,r=ie)=>{switch(n.op){case"Fill":{const s=$("shape",n,t,e),o=$("dtype",n,t,e),l=$("value",n,t,e);return[r.fill(s,l,o)]}case"LinSpace":{const s=$("start",n,t,e),o=$("stop",n,t,e),l=$("num",n,t,e);return[r.linspace(s,o,l)]}case"Multinomial":{const s=$("logits",n,t,e),o=$("numSamples",n,t,e),l=$("seed",n,t,e);return[r.multinomial(s,o,l)]}case"OneHot":{const s=$("indices",n,t,e),o=$("depth",n,t,e),l=$("onValue",n,t,e),u=$("offValue",n,t,e),d=$("dtype",n,t,e);return[r.oneHot(s,o,l,u,d)]}case"Ones":return[r.ones($("shape",n,t,e),$("dtype",n,t,e))];case"OnesLike":return[r.onesLike($("x",n,t,e))];case"RandomStandardNormal":return[r.randomStandardNormal($("shape",n,t,e),$("dtype",n,t,e),$("seed",n,t,e))];case"RandomUniform":return[r.randomUniform($("shape",n,t,e),$("minval",n,t,e),$("maxval",n,t,e),$("dtype",n,t,e))];case"RandomUniformInt":return[r.randomUniformInt($("shape",n,t,e),$("minval",n,t,e),$("maxval",n,t,e),$("seed",n,t,e))];case"Range":{const s=$("start",n,t,e),o=$("stop",n,t,e),l=$("step",n,t,e);return[r.range(s,o,l,$("dtype",n,t,e))]}case"TruncatedNormal":{const s=$("shape",n,t,e),o=$("mean",n,t,e),l=$("stdDev",n,t,e),u=$("seed",n,t,e);return[r.truncatedNormal(s,o,l,$("dtype",n,t,e),u)]}case"Zeros":return[r.zeros($("shape",n,t,e),$("dtype",n,t,e))];case"ZerosLike":return[r.zerosLike($("x",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}})(l,u,d));case"dynamic":return GD(l,u,d);case"evaluation":return s(()=>((n,t,e,r=ie)=>{switch(n.op){case"LowerBound":{const s=$("sortedSequence",n,t,e),o=$("values",n,t,e);return[r.lowerBound(s,o)]}case"TopKV2":{const s=$("x",n,t,e),o=$("k",n,t,e),l=$("sorted",n,t,e),u=r.topk(s,o,l);return[u.values,u.indices]}case"UpperBound":{const s=$("sortedSequence",n,t,e),o=$("values",n,t,e);return[r.upperBound(s,o)]}case"Unique":{const s=$("x",n,t,e),o=r.unique(s);return[o.values,o.indices]}case"UniqueV2":{const s=$("x",n,t,e),o=$("axis",n,t,e),l=r.unique(s,o);return[l.values,l.indices]}default:throw TypeError(`Node type ${n.op} is not implemented`)}})(l,u,d));case"image":return s(()=>((n,t,e,r=ie)=>{switch(n.op){case"ResizeBilinear":{const s=$("images",n,t,e),o=$("size",n,t,e),l=$("alignCorners",n,t,e),u=$("halfPixelCenters",n,t,e);return[r.image.resizeBilinear(s,[o[0],o[1]],l,u)]}case"ResizeNearestNeighbor":{const s=$("images",n,t,e),o=$("size",n,t,e),l=$("alignCorners",n,t,e),u=$("halfPixelCenters",n,t,e);return[r.image.resizeNearestNeighbor(s,[o[0],o[1]],l,u)]}case"CropAndResize":{const s=$("image",n,t,e),o=$("boxes",n,t,e),l=$("boxInd",n,t,e),u=$("cropSize",n,t,e),d=$("method",n,t,e),h=$("extrapolationValue",n,t,e);return[r.image.cropAndResize(s,o,l,u,d,h)]}case"ImageProjectiveTransformV3":{const s=$("images",n,t,e),o=$("transforms",n,t,e),l=$("outputShape",n,t,e),u=$("fillValue",n,t,e),d=$("interpolation",n,t,e),h=$("fillMode",n,t,e);return[r.image.transform(s,o,d.toLowerCase(),h.toLowerCase(),u,l)]}default:throw TypeError(`Node type ${n.op} is not implemented`)}})(l,u,d));case"graph":return s(()=>((n,t,e,r=ie)=>{switch(n.op){case"Const":return t[n.name];case"PlaceholderWithDefault":const s=$("default",n,t,e);return[ws(n.name,t,e)||s];case"Placeholder":return[ws(n.name,t,e)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":case"Snapshot":return[ua($("x",n,t,e))];case"IdentityN":return $("x",n,t,e).map(p=>ua(p));case"Shape":return[r.tensor1d($("x",n,t,e).shape,"int32")];case"ShapeN":return $("x",n,t,e).map(p=>r.tensor1d(p.shape));case"Size":return[r.scalar($("x",n,t,e).size,"int32")];case"Rank":return[r.scalar($("x",n,t,e).rank,"int32")];case"NoOp":return[r.scalar(1)];case"Print":const l=$("x",n,t,e),u=$("data",n,t,e),d=$("message",n,t,e),h=$("summarize",n,t,e);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(d);for(let p=0;p<u.length;p++)console.log(Array.prototype.slice.call(u[p].dataSync()).slice(0,h));return[l];default:throw TypeError(`Node type ${n.op} is not implemented`)}})(l,u,d));case"logical":return s(()=>((n,t,e,r=ie)=>{switch(n.op){case"Equal":return[r.equal($("a",n,t,e),$("b",n,t,e))];case"NotEqual":return[r.notEqual($("a",n,t,e),$("b",n,t,e))];case"Greater":return[r.greater($("a",n,t,e),$("b",n,t,e))];case"GreaterEqual":return[r.greaterEqual($("a",n,t,e),$("b",n,t,e))];case"Less":return[r.less($("a",n,t,e),$("b",n,t,e))];case"LessEqual":return[r.lessEqual($("a",n,t,e),$("b",n,t,e))];case"LogicalAnd":return[r.logicalAnd($("a",n,t,e),$("b",n,t,e))];case"LogicalNot":return[r.logicalNot($("a",n,t,e))];case"LogicalOr":return[r.logicalOr($("a",n,t,e),$("b",n,t,e))];case"Select":case"SelectV2":return[r.where($("condition",n,t,e),$("a",n,t,e),$("b",n,t,e))];case"BitwiseAnd":return[r.bitwiseAnd($("a",n,t,e),$("b",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}})(l,u,d));case"matrices":return s(()=>((n,t,e,r=ie)=>{switch(n.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[r.matMul($("a",n,t,e),$("b",n,t,e),$("transposeA",n,t,e),$("transposeB",n,t,e))];case"Einsum":return[r.einsum($("equation",n,t,e),...$("tensors",n,t,e))];case"Transpose":return[r.transpose($("x",n,t,e),$("perm",n,t,e))];case"_FusedMatMul":const[s,o]=$("fusedOps",n,t,e),l="biasadd"===s,u="prelu"===o,d=$("numArgs",n,t,e),h=$("leakyreluAlpha",n,t,e);if(l){if(u&&2!==d)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!u&&1!==d)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}const[p,g]=$("args",n,t,e);return[r.fused.matMul({a:$("a",n,t,e),b:$("b",n,t,e),transposeA:$("transposeA",n,t,e),transposeB:$("transposeB",n,t,e),bias:p,activation:o,preluActivationWeights:g,leakyreluAlpha:h})];case"MatrixBandPart":return[r.linalg.bandPart($("a",n,t,e),$("numLower",n,t,e),$("numUpper",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}})(l,u,d));case"normalization":return s(()=>((n,t,e,r=ie)=>{switch(n.op){case"EuclideanNorm":return[r.euclideanNorm($("x",n,t,e),$("axis",n,t,e),$("keepDims",n,t,e))];case"FusedBatchNorm":case"FusedBatchNormV2":case"FusedBatchNormV3":return[r.batchNorm($("x",n,t,e),$("mean",n,t,e),$("variance",n,t,e),$("offset",n,t,e),$("scale",n,t,e),$("epsilon",n,t,e))];case"LRN":return[r.localResponseNormalization($("x",n,t,e),$("radius",n,t,e),$("bias",n,t,e),$("alpha",n,t,e),$("beta",n,t,e))];case"Softmax":return[r.softmax($("x",n,t,e))];case"LogSoftmax":return[r.logSoftmax($("x",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}})(l,u,d));case"ragged":return s(()=>((n,t,e,r=ie)=>{switch(n.op){case"RaggedGather":{const{outputNestedSplits:s,outputDenseValues:o}=r.raggedGather($("paramsNestedSplits",n,t,e),$("paramsDenseValues",n,t,e),$("indices",n,t,e),$("outputRaggedRank",n,t,e));return s.concat(o)}case"RaggedRange":{const{rtNestedSplits:s,rtDenseValues:o}=r.raggedRange($("starts",n,t,e),$("limits",n,t,e),$("splits",n,t,e));return[s,o]}case"RaggedTensorToTensor":return[r.raggedTensorToTensor($("shape",n,t,e),$("values",n,t,e),$("defaultValue",n,t,e),$("rowPartitionTensors",n,t,e),$("rowPartitionTypes",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}})(l,u,d));case"reduction":return s(()=>((n,t,e,r=ie)=>{switch(n.op){case"Max":{const u=$("axis",n,t,e),d=$("keepDims",n,t,e);return[r.max($("x",n,t,e),u,d)]}case"Mean":{const u=$("axis",n,t,e),d=$("keepDims",n,t,e);return[r.mean($("x",n,t,e),u,d)]}case"Min":{const u=$("axis",n,t,e),d=$("keepDims",n,t,e);return[r.min($("x",n,t,e),u,d)]}case"Sum":{const u=$("axis",n,t,e),d=$("keepDims",n,t,e);return[r.sum($("x",n,t,e),u,d)]}case"All":{const u=$("axis",n,t,e),d=$("keepDims",n,t,e);return[r.all($("x",n,t,e),u,d)]}case"Any":{const u=$("axis",n,t,e),d=$("keepDims",n,t,e);return[r.any($("x",n,t,e),u,d)]}case"ArgMax":{const u=$("axis",n,t,e);return[r.argMax($("x",n,t,e),u)]}case"ArgMin":{const u=$("axis",n,t,e);return[r.argMin($("x",n,t,e),u)]}case"Prod":{const u=$("axis",n,t,e),d=$("keepDims",n,t,e);return[r.prod($("x",n,t,e),u,d)]}case"Cumprod":{const u=$("axis",n,t,e),d=$("exclusive",n,t,e),h=$("reverse",n,t,e);return[r.cumprod($("x",n,t,e),u,d,h)]}case"Cumsum":{const u=$("axis",n,t,e),d=$("exclusive",n,t,e),h=$("reverse",n,t,e);return[r.cumsum($("x",n,t,e),u,d,h)]}case"Bincount":const s=$("x",n,t,e),o=$("weights",n,t,e),l=$("size",n,t,e);return[r.bincount(s,o,l)];case"DenseBincount":{const u=$("x",n,t,e),d=$("weights",n,t,e),h=$("size",n,t,e),p=$("binaryOutput",n,t,e);return[r.denseBincount(u,d,h,p)]}default:throw TypeError(`Node type ${n.op} is not implemented`)}})(l,u,d));case"slice_join":return s(()=>((n,t,e,r=ie)=>{switch(n.op){case"ConcatV2":case"Concat":{const s=$("n",n,t,e),o=$("axis",n,t,e);let l=$("tensors",n,t,e);return l=l.slice(0,s),[r.concat(l,o)]}case"Gather":{const s=$("x",n,t,e),o=$("indices",n,t,e);return[r.gather(s,r.cast(o,"int32"),0)]}case"GatherV2":{const s=$("axis",n,t,e),o=$("batchDims",n,t,e),l=$("x",n,t,e),u=$("indices",n,t,e);return[r.gather(l,r.cast(u,"int32"),s,o)]}case"Reverse":{const s=$("dims",n,t,e),o=[];for(let u=0;u<s.length;u++)s[u]&&o.push(u);const l=$("x",n,t,e);return[r.reverse(l,o)]}case"ReverseV2":{const s=$("axis",n,t,e),o=$("x",n,t,e);return[r.reverse(o,s)]}case"Slice":{const s=$("begin",n,t,e),o=$("size",n,t,e);return[r.slice($("x",n,t,e),s,o)]}case"StridedSlice":{const s=$("begin",n,t,e),o=$("end",n,t,e),l=$("strides",n,t,e),u=$("beginMask",n,t,e),d=$("endMask",n,t,e),h=$("ellipsisMask",n,t,e),p=$("newAxisMask",n,t,e),g=$("shrinkAxisMask",n,t,e),y=$("x",n,t,e);return[r.stridedSlice(y,s,o,l,u,d,h,p,g)]}case"Pack":return En(()=>{const s=$("axis",n,t,e),o=$("tensors",n,t,e),l=o[0].shape,u=r.squeeze(o[0]).shape,d=o.map(h=>{const p=un(h.shape,l);if(!p&&!un(r.squeeze(h).shape,u))throw new Error("the input tensors shape does not match");return p?h:r.reshape(h,l)});return[r.stack(d,s)]});case"Unpack":{const s=$("axis",n,t,e),o=$("tensor",n,t,e);return r.unstack(o,s)}case"Tile":{const s=$("reps",n,t,e);return[r.tile($("x",n,t,e),s)]}case"Split":case"SplitV":{const s=$("axis",n,t,e),o=$("numOrSizeSplits",n,t,e),l=$("x",n,t,e);return r.split(l,o,s)}case"ScatterNd":{const s=$("indices",n,t,e),o=$("values",n,t,e),l=$("shape",n,t,e);return[r.scatterND(s,o,l)]}case"GatherNd":{const s=$("x",n,t,e),o=$("indices",n,t,e);return[r.gatherND(s,o)]}case"SparseToDense":{const s=$("sparseIndices",n,t,e),o=$("outputShape",n,t,e),l=$("sparseValues",n,t,e),u=$("defaultValue",n,t,e);return[r.sparseToDense(s,l,o,l.dtype===u.dtype?u:r.cast(u,l.dtype))]}case"TensorScatterUpdate":{const s=$("indices",n,t,e),o=$("values",n,t,e),l=$("tensor",n,t,e);return[r.tensorScatterUpdate(l,s,o)]}default:throw TypeError(`Node type ${n.op} is not implemented`)}})(l,u,d));case"sparse":return s(()=>((n,t,e,r=ie)=>{switch(n.op){case"SparseFillEmptyRows":{const{outputIndices:s,outputValues:o,emptyRowIndicator:l,reverseIndexMap:u}=r.sparse.sparseFillEmptyRows($("indices",n,t,e),$("values",n,t,e),$("denseShape",n,t,e),$("defaultValue",n,t,e));return[s,o,l,u]}case"SparseReshape":{const{outputIndices:s,outputShape:o}=r.sparse.sparseReshape($("inputIndices",n,t,e),$("inputShape",n,t,e),$("newShape",n,t,e));return[s,o]}case"SparseSegmentMean":return[r.sparse.sparseSegmentMean($("data",n,t,e),$("indices",n,t,e),$("segmentIds",n,t,e))];case"SparseSegmentSum":return[r.sparse.sparseSegmentSum($("data",n,t,e),$("indices",n,t,e),$("segmentIds",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}})(l,u,d));case"spectral":return s(()=>((n,t,e,r=ie)=>{switch(n.op){case"FFT":return[r.fft($("x",n,t,e))];case"IFFT":return[r.ifft($("x",n,t,e))];case"RFFT":return[r.rfft($("x",n,t,e))];case"IRFFT":return[r.irfft($("x",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}})(l,u,d));case"string":return s(()=>((n,t,e,r=ie)=>{switch(n.op){case"StaticRegexReplace":return[r.string.staticRegexReplace($("input",n,t,e),$("pattern",n,t,e),$("rewrite",n,t,e),$("replaceGlobal",n,t,e))];case"StringNGrams":{const{nGrams:s,nGramsSplits:o}=r.string.stringNGrams($("data",n,t,e),$("dataSplits",n,t,e),$("separator",n,t,e),$("nGramWidths",n,t,e),$("leftPad",n,t,e),$("rightPad",n,t,e),$("padWidth",n,t,e),$("preserveShortSequences",n,t,e));return[s,o]}case"StringSplit":{const{indices:s,values:o,shape:l}=r.string.stringSplit($("input",n,t,e),$("delimiter",n,t,e),$("skipEmpty",n,t,e));return[s,o,l]}case"StringToHashBucketFast":return[r.string.stringToHashBucketFast($("input",n,t,e),$("numBuckets",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}})(l,u,d));case"transformation":return s(()=>((n,t,e,r=ie)=>{switch(n.op){case"Cast":return[r.cast($("x",n,t,e),$("dtype",n,t,e))];case"ExpandDims":{const s=$("axis",n,t,e);return[r.expandDims($("x",n,t,e),s)]}case"Squeeze":{const s=$("axis",n,t,e);return[r.squeeze($("x",n,t,e),s)]}case"Reshape":return[r.reshape($("x",n,t,e),$("shape",n,t,e))];case"EnsureShape":return[r.ensureShape($("x",n,t,e),$("shape",n,t,e))];case"MirrorPad":return[r.mirrorPad($("x",n,t,e),$("padding",n,t,e),$("mode",n,t,e))];case"PadV2":case"Pad":return[r.pad($("x",n,t,e),$("padding",n,t,e),$("constantValue",n,t,e))];case"SpaceToBatchND":{const s=$("blockShape",n,t,e),o=$("paddings",n,t,e);return[r.spaceToBatchND($("x",n,t,e),s,o)]}case"BatchToSpaceND":{const s=$("blockShape",n,t,e),o=$("crops",n,t,e);return[r.batchToSpaceND($("x",n,t,e),s,o)]}case"DepthToSpace":{const s=$("blockSize",n,t,e),o=$("dataFormat",n,t,e).toUpperCase();return[r.depthToSpace($("x",n,t,e),s,o)]}case"BroadcastTo":return[r.broadcastTo($("x",n,t,e),$("shape",n,t,e))];case"BroadcastArgs":return[r.broadcastArgs($("s0",n,t,e),$("s1",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}})(l,u,d));case"hash_table":return tE(l,u,d,r);case"custom":const h=Zu(l.op);if(h&&h.customExecutor)return h.customExecutor(new UD(l,u,d));throw TypeError(`Custom op ${l.op} is not registered.`);default:throw TypeError(`Unknown op '${l.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(n,t,e);return dn(o)?o.then(l=>[].concat(l)):[].concat(o)}class ap{constructor(t={},e={},r={},s={},o){this.weightMap=t,this.tensorArrayMap=e,this.tensorListMap=r,this.functionMap=s,this.parseNodeNameCache=o,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(t,e){return{id:t,frameName:e,iterationId:0}}set currentContext(t){this.contexts!==t&&(this.contexts=t,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){const t=[];for(let e=0;e<this.contexts.length-1;e++){const r=this.contexts.slice(0,this.contexts.length-e);t.push(this.contextIdforContexts(r))}t.push(""),this._currentContextIds=t}contextIdforContexts(t){return t?t.map(e=>0===e.id&&0===e.iterationId?"":`${e.frameName}-${e.iterationId}`).join("/"):""}enterFrame(t){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,t)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(!(this.contexts&&this.contexts.length>1))throw new Error("Cannot exit frame, the context is empty");this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift()}nextIteration(){if(!(this.contexts&&this.contexts.length>0))throw new Error("Cannot increase frame iteration, the context is empty");{this.contexts=this.contexts.slice(),this.lastId++;const t=Object.assign({},this.contexts[this.contexts.length-1]);t.iterationId+=1,t.id=this.lastId,this.contexts.splice(-1,1,t),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}}getWeight(t){return this.weightMap[t]}addTensorArray(t){this.tensorArrayMap[t.id]=t}getTensorArray(t){return this.tensorArrayMap[t]}addTensorList(t){this.tensorListMap[t.id]=t}getTensorList(t){return this.tensorListMap[t]}dispose(t){for(const e in this.tensorArrayMap)this.tensorArrayMap[e].clearAndClose(t);for(const e in this.tensorListMap)this.tensorListMap[e].clearAndClose(t)}}function da(n,t,e,r){const s=new Set,o=[];let l=null,u=null;const d=new Set,h=new Set(Object.keys(n).map(y=>go(y)[0]));r=r||[];const p=new Set(r.map(y=>go(y.name)[0])),g=[...t];for(;g.length>0;){const y=g.pop();if((jl(y)||dE(y)||L_(y))&&null==l&&(l=y,u=l.children.map(b=>b.name).filter(b=>s.has(b))),s.add(y.name),null==e[y.name]&&!h.has(y.name)&&!p.has(y.name)){if(0===y.inputs.length){o.push(y.name);continue}y.inputs.forEach(b=>{d.has(b.name)||(d.add(b.name),g.push(b))})}}return{inputs:n,outputs:t,usedNodes:s,missingInputs:o,dynamicNode:l,syncInputs:u}}class lp extends Error{constructor(t){super(`NodesExecutionOrderError: ${t}`)}}const uE=new Set(["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"]),P_=new Set(["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"]),sT=new Set(["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"]);function jl(n){return uE.has(n.op)}function dE(n){return P_.has(n.op)}function L_(n){return sT.has(n.op)}class vy{get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(t){const e=Object.keys(t).map(r=>t[r].map(s=>s.id));this._weightIds=[].concat(...e),this._weightMap=t}set resourceManager(t){this._resourceManager=t}get inputs(){return this._inputs.map(t=>({name:t.name,shape:t.attrParams.shape?t.attrParams.shape.value:void 0,dtype:t.attrParams.dtype?t.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(t=>({name:t.name,shape:t.attrParams.shape?t.attrParams.shape.value:void 0,dtype:t.attrParams.dtype?t.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(t=>t.signatureKey||t.name)}get outputNodes(){return this._outputs.map(t=>{const e=t.signatureKey||t.name;return t.defaultOutput?`${e}:${t.defaultOutput}`:e})}get functions(){return Object.keys(this._functions).reduce((t,e)=>(t[e]=this._functions[e].signature,t),{})}constructor(t,e){this.graph=t,this.parent=e,this.compiledMap=new Map,this.parseNodeNameCache=new Map,this._weightMap={},this.SEPARATOR=",",this._functions={},this._functionExecutorMap={},this.keepIntermediateTensors=!1,this._outputs=t.outputs,this._inputs=t.inputs,this._initNodes=t.initNodes,this._signature=t.signature,this._functions=t.functions,null!=t.functions&&Object.keys(t.functions).forEach(r=>{this._functionExecutorMap[r]=new vy(t.functions[r],this)})}getCompilationKey(t,e){const r=t.map(o=>o.name).sort(),s=e.map(o=>o.name).sort();return r.join(this.SEPARATOR)+"--"+s.join(this.SEPARATOR)}compile(t,e){const r=da(t,e,this.weightMap,this._initNodes),{missingInputs:s,dynamicNode:o,syncInputs:l}=r;if(null!=o)throw new Error(`This execution contains the node '${o.name}', which has the dynamic op '${o.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${l}]`);if(s.length>0){const h=e.map(g=>g.name),p=Object.keys(t);throw new Error(`Cannot compute the outputs [${h}] from the provided inputs [${p}]. Missing the following inputs: [${s}]`)}const u=function aE(n,t){const{usedNodes:e,inputs:r}=t,l=S=>e.has("string"==typeof S?S:S.name);function u(S){return[...new Map(S.map(T=>[T.name,T])).values()]}const d=u([...Object.keys(r).map(S=>go(S)[0]).map(S=>n.nodes[S]),...n.weights,...n.initNodes||[]]).filter(l),h=u([...d,...Object.values(n.nodes)]).filter(l),p=new Map(h.map(S=>[S.name,S])),g={};for(const S of h){g[S.name]=g[S.name]||0;for(const T of S.children)l(T)||(g[T.name]=Number.POSITIVE_INFINITY),g[T.name]=(g[T.name]||0)+1}const y=Object.entries(g).filter(([,S])=>0===S).map(([S])=>S),b=[...y];for(;y.length>0;){const S=y.pop(),T=p.get(S);for(const O of T.children.filter(l))0==--g[O.name]&&(b.push(O.name),y.push(O.name))}const I=function rT(n,t){const e=new Map(n.map(l=>[l.name,l])),r=t.map(l=>l.name),s=new Set(r);for(;r.length>0;){const l=r.pop(),u=e.get(l);for(const d of u.children)!e.has(d.name)||s.has(d.name)||(s.add(d.name),r.push(d.name))}return n.filter(l=>s.has(l.name))}(b.map(S=>p.get(S)),d);return function lE(n,t){const e=new Map(n.map((u,d)=>[u.name,d])),r=new Set(t.map(u=>u.name)),s=u=>r.has("string"==typeof u?u:u.name),o=new Set(n.map(u=>u.name)),l=u=>o.has("string"==typeof u?u:u.name);for(const u of n){for(const d of u.children.filter(l)){if(!e.has(d.name))throw new lp(`Child ${d.name} of node ${u.name} is unreachable.`);if(e.get(u.name)>e.get(d.name))throw new lp(`Node ${u.name} is scheduled to run after its child ${d.name}.`)}if(!s(u))for(const d of u.inputs){if(!e.has(d.name))throw new lp(`Input ${d.name} of node ${u.name} is unreachable.`);if(e.get(d.name)>e.get(u.name))throw new lp(`Node ${u.name} is scheduled to run before its input ${d.name}.`)}}}(I,d),I}(this.graph,r),d=function cE(n){const t=new Map(n.map((u,d)=>[u.name,d])),e=Number.MAX_SAFE_INTEGER,r=n.map((u,d)=>jl(u)?e:d),s=u=>{const d=r[t.get(u.name)];return null==d?-1:d},o=n.map((u,d)=>u.children.map(s).reduce((h,p)=>Math.max(h,p),r[d])),l=new Map;for(let u=0;u<n.length;++u){const d=o[u];if(d===e)continue;const h=n[u],p=n[d];l.has(p.name)||l.set(p.name,[]),l.get(p.name).push(h)}return l}(u);return{orderedNodes:u,nodeLiveUntilMap:d}}cloneAndKeepTensor(t){if(null==t)return null;const e=t.clone();return Ji(e),e}cloneTensorList(t){return t?t.map(r=>this.cloneAndKeepTensor(r)):null}cloneTensorMap(t){return Object.fromEntries(Object.entries(t).map(([e,r])=>[e,this.cloneTensorList(r)]))}execute(t,e){this.disposeIntermediateTensors(),t=this.mapInputs(t);const r=Object.keys(t).sort();this.checkInputs(t),this.checkInputShapeAndType(t),e=this.mapOutputs(e),this.checkOutputs(e);const s=r.map(y=>this.graph.nodes[go(y)[0]]),o=e.map(y=>go(y)[0]),l=new Set(o);let u=o.map(y=>this.graph.nodes[y]);0===u.length&&(u=this._outputs);const d=this.getCompilationKey(s,u);let h=this.compiledMap.get(d);null==h&&(h=this.compile(t,u),this.compiledMap.set(d,h));try{this.keepIntermediateTensors=Q().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(y){this.keepIntermediateTensors=!1,console.warn(y.message)}const p={},g={};return En(()=>{const y=new ap(this.weightMap,p,g,this.functionExecutorMap,this.parseNodeNameCache),b=Object.assign({},this.weightMap);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap)),Object.keys(t).forEach(T=>{const[O,V]=go(T,y),U=[];U[V]=t[T],b[O]=U,this.keepIntermediateTensors&&(this.clonedTensorsMap[O]=this.cloneTensorList(U))});const _=this.getFrozenTensorIds(b),{orderedNodes:I,nodeLiveUntilMap:S}=h;for(const T of I){if(b[T.name])continue;const O=yy(T,b,y,this._resourceManager);if(dn(O))throw new Error(`The execution of the op '${T.op}' returned a promise. Please use model.executeAsync() instead.`);b[T.name]=O,this.keepIntermediateTensors&&(this.clonedTensorsMap[T.name]=this.cloneTensorList(O)),this.checkTensorForDisposalWithNodeLiveUntilInfo(T,b,y,_,l,S.get(T.name))}return null==this.parent&&y.dispose(_),e.map(T=>ws(T,b,y))})}getFrozenTensorIds(t){const e=[].concat.apply([],Object.keys(t).map(r=>t[r]).map(r=>r.map(s=>s.id)));return new Set(e)}checkTensorForDisposal(t,e,r,s,o,l,u){if(!jl(e)&&!l.has(t)){for(const d of r[t])null!=d&&(u[d.id]=(u[d.id]||0)+e.children.length);for(const d of e.inputs){if(jl(d))continue;const h=sy(d.name,r,s);if(null!=h)for(const p of h){if(!p||p.kept||o.has(p.id))continue;const g=u[p.id];1===g?(p.dispose(),delete u[p.id]):null!=g&&u[p.id]--}}}}checkTensorForDisposalWithNodeLiveUntilInfo(t,e,r,s,o,l){function u(d){return jl(d)||o.has(d.name)}if(!jl(t)&&null!=l)for(const d of l){if(u(d))continue;const h=sy(d.name,e,r);for(const p of h)!p||p.kept||s.has(p.id)||p.dispose()}}executeAsync(t,e){var r=this;return xe(function*(){return r._executeAsync(t,e)})()}disposeIntermediateTensors(){!this.clonedTensorsMap||(Object.values(this.clonedTensorsMap).forEach(t=>{for(const e of t)e&&!e.isDisposed&&e.dispose()}),this.clonedTensorsMap=null)}getIntermediateTensors(){return this.clonedTensorsMap}_executeAsync(t,e,r=!1,s={},o={}){var l=this;return xe(function*(){l.disposeIntermediateTensors(),r||(t=l.mapInputs(t),l.checkInputs(t),l.checkInputShapeAndType(t),e=l.mapOutputs(e),l.checkOutputs(e));try{l.keepIntermediateTensors=Q().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(b){l.keepIntermediateTensors=!1,console.warn(b.message)}const u=new ap(l.weightMap,s,o,l.functionExecutorMap,l.parseNodeNameCache);l.keepIntermediateTensors&&(l.clonedTensorsMap=l.cloneTensorMap(l.weightMap));const d=yield l.executeWithControlFlow(t,u,e,r),h=e.map(b=>ws(b,d,u)),p=h.map(b=>b.id),g=Object.keys(t).map(b=>t[b].id),y=new Set([...p,...g,...l.weightIds]);return Object.values(d).forEach(b=>{b.forEach(_=>{_&&!_.isDisposed&&!y.has(_.id)&&_.dispose()})}),null==l.parent&&u.dispose(y),h})()}executeFunctionAsync(t,e,r){var s=this;return xe(function*(){const o=t.reduce((l,u,d)=>(l[s.inputs[d].name]=u,l),{});return s._executeAsync(o,s.outputNodes,!0,e,r)})()}executeWithControlFlow(t,e,r,s){var o=this;return xe(function*(){const l=Object.keys(t),u=l.map(j=>o.graph.nodes[go(j)[0]]),d=r.map(j=>go(j)[0]),h=new Set(d);let p=d.map(j=>o.graph.nodes[j]);0===p.length&&(p=o._outputs);const{usedNodes:g,missingInputs:y,dynamicNode:b,syncInputs:_}=da(t,p,o.weightMap,o._initNodes),I=[...u,...o.graph.weights,...o._initNodes||[]].map(j=>({node:j,contexts:e.currentContext})),S=Object.assign({},o.weightMap);Object.keys(t).forEach(j=>{const[te,se]=go(j),le=[];le[se]=t[j],S[te]=le});const T={},O=o.getFrozenTensorIds(S),V={};for(;I.length>0;){const j=o.processStack(u,I,e,S,V,O,h,T,g);yield Promise.all(j)}null==b&&!s&&console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");const U=p.filter(j=>!jl(j)&&!ws(j.name,S,e)).map(j=>j.name);if(U.length>0){let j="";throw null!=b&&(j=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${_}]`),new Error(`Cannot compute the outputs [${U}] from the provided inputs [${l}]. Consider providing the following inputs: [${y}]. ${j}`)}return S})()}processStack(t,e,r,s,o,l,u,d,h){const p=[];for(;e.length>0;){const g=e.pop();r.currentContext=g.contexts;let y="";if("Enter"===g.node.op&&$("isConstant",g.node,s,r)&&([y]=Ja(g.node.name,r)),null==s[g.node.name]){const b=yy(g.node,s,r,this._resourceManager);y||([y]=Ja(g.node.name,r));const _=r.currentContext;dn(b)?p.push(b.then(I=>(s[y]=I,this.keepIntermediateTensors&&(this.clonedTensorsMap[y]=this.cloneTensorList(I)),r.currentContext=_,this.checkTensorForDisposal(y,g.node,s,r,l,u,d),this.processChildNodes(g.node,e,r,s,o,h),I))):(s[y]=b,this.keepIntermediateTensors&&(this.clonedTensorsMap[y]=this.cloneTensorList(b)),this.checkTensorForDisposal(y,g.node,s,r,l,u,d),this.processChildNodes(g.node,e,r,s,o,h))}else this.processChildNodes(g.node,e,r,s,o,h)}return p}processChildNodes(t,e,r,s,o,l){t.children.forEach(u=>{const[d]=Ja(u.name,r);o[d]||!l.has(u.name)||("Merge"===u.op?u.inputNames.some(h=>!!ws(h,s,r))&&(o[d]=!0,e.push({contexts:r.currentContext,node:u})):u.inputNames.every(h=>!!ws(h,s,r))&&(o[d]=!0,e.push({contexts:r.currentContext,node:u})))})}dispose(){Object.keys(this.weightMap).forEach(t=>this.weightMap[t].forEach(e=>e.dispose()))}checkInputShapeAndType(t){Object.keys(t).forEach(e=>{const r=t[e],[s]=go(e),o=this.graph.nodes[s];if(o.attrParams.shape&&o.attrParams.shape.value){const l=o.attrParams.shape.value;G(l.length===r.shape.length&&r.shape.every((d,h)=>-1===l[h]||l[h]===d),()=>`The shape of dict['${o.name}'] provided in model.execute(dict) must be [${l}], but was [${r.shape}]`)}o.attrParams.dtype&&o.attrParams.dtype.value&&G(r.dtype===o.attrParams.dtype.value,()=>`The dtype of dict['${o.name}'] provided in model.execute(dict) must be ${o.attrParams.dtype.value}, but was ${r.dtype}`)})}mapInputs(t){var e,r;const s={};for(const o in t){const l=null===(r=null===(e=this._signature)||void 0===e?void 0:e.inputs)||void 0===r?void 0:r[o];null!=l?s[l.name]=t[o]:s[o]=t[o]}return s}checkInputs(t){const e=Object.keys(t).filter(r=>{const[s]=go(r);return null==this.graph.nodes[s]});if(e.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${e}] that are not part of graph`)}mapOutputs(t){return t.map(e=>{var r,s;const o=null===(s=null===(r=this._signature)||void 0===r?void 0:r.outputs)||void 0===s?void 0:s[e];return null!=o?o.name:e},{})}checkOutputs(t){t.forEach(e=>{const[r]=go(e);if(!this.graph.nodes[r])throw new Error(`The output '${e}' is not found in the graph`)})}}class by{constructor(t={},e={}){this.hashTableNameToHandle=t,this.hashTableMap=e}addHashTable(t,e){this.hashTableNameToHandle[t]=e.handle,this.hashTableMap[e.id]=e}getHashTableHandleByName(t){return this.hashTableNameToHandle[t]}getHashTableById(t){return this.hashTableMap[t]}dispose(){for(const t in this.hashTableMap)this.hashTableMap[t].clearAndClose(),delete this.hashTableMap[t];for(const t in this.hashTableNameToHandle)this.hashTableNameToHandle[t].dispose(),delete this.hashTableNameToHandle[t]}}class _y{get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}constructor(t,e={},r=P){this.modelUrl=t,this.loadOptions=e,this.version="n/a",this.io=r,null==e&&(this.loadOptions={}),this.resourceManager=new by}findIOHandler(){const t=this.modelUrl;if(null!=t.load)this.handler=t;else if(null!=this.loadOptions.requestInit)this.handler=this.io.browserHTTPRequest(t,this.loadOptions);else{const e=this.io.getLoadHandlers(t,this.loadOptions);if(0===e.length)e.push(this.io.browserHTTPRequest(t,this.loadOptions));else if(e.length>1)throw new Error(`Found more than one (${e.length}) load handlers for URL '${[t]}'`);this.handler=e[0]}}load(){if(this.findIOHandler(),null==this.handler.load)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const t=this.handler.load();return dn(t)?t.then(e=>null==e.getWeightStream?this.loadSync(e):this.loadStreaming(e)):this.loadSync(t)}loadSync(t){const e=this.io.decodeWeights(t.weightData,t.weightSpecs);return this.loadWithWeightMap(t,e)}loadStreaming(t){var e=this;return xe(function*(){if(null==t.getWeightStream)throw new Error("Model artifacts missing streamWeights function");const r=yield Gp(t.getWeightStream(),t.weightSpecs);return e.loadWithWeightMap(t,r)})()}loadWithWeightMap(t,e){this.artifacts=t;const r=this.artifacts.modelTopology;let s=this.artifacts.signature;if(null!=this.artifacts.userDefinedMetadata){const o=this.artifacts.userDefinedMetadata;null!=o.signature&&(s=o.signature),null!=o.structuredOutputKeys&&(this.structuredOutputKeys=o.structuredOutputKeys)}if(this.signature=s,this.version=`${r.versions.producer}.${r.versions.minConsumer}`,this.executor=new vy(ay.Instance.transformGraph(r,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(e),this.executor.resourceManager=this.resourceManager,null!=t.modelInitializer&&null!=t.modelInitializer.node){const o=ay.Instance.transformGraph(t.modelInitializer);this.initializer=new vy(o),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializerSignature=t.initializerSignature}return!0}save(t,e){var r=this;return xe(function*(){if("string"==typeof t){const s=r.io.getSaveHandlers(t);if(0===s.length)throw new Error(`Cannot find any save handlers for URL '${t}'`);if(s.length>1)throw new Error(`Found more than one (${s.length}) save handlers for URL '${t}'`);t=s[0]}if(null==t.save)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return t.save(r.artifacts)})()}addStructuredOutputNames(t){if(this.structuredOutputKeys){const r={};return(t instanceof Rr?[t]:t).forEach((s,o)=>r[this.structuredOutputKeys[o]]=s),r}return t}predict(t,e){const r=this.execute(t,this.outputNodes);return this.addStructuredOutputNames(r)}predictAsync(t,e){var r=this;return xe(function*(){const s=yield r.executeAsync(t,r.outputNodes);return r.addStructuredOutputNames(s)})()}normalizeInputs(t){var e;if(!(t instanceof Rr||Array.isArray(t))){const o=null===(e=this.signature)||void 0===e?void 0:e.inputs;if(null!=o)for(const l in o){const u=o[l];null!=u.resourceId&&(t[l]=this.resourceIdToCapturedInput[u.resourceId])}return t}t=Array.isArray(t)?t:[t];const r=Object.keys(this.resourceIdToCapturedInput).length;if(t.length+r!==this.inputNodes.length)throw new Error(`Input tensor count mismatch, the graph model has ${this.inputNodes.length-r} non-resource placeholders, while there are ${t.length} input tensors provided.`);let s=0;return this.inputNodes.reduce((o,l)=>{var u,d,h;const p=null===(h=null===(d=null===(u=this.signature)||void 0===u?void 0:u.inputs)||void 0===d?void 0:d[l])||void 0===h?void 0:h.resourceId;return o[l]=null!=p?this.resourceIdToCapturedInput[p]:t[s++],o},{})}normalizeOutputs(t){return t=t||this.outputNodes,Array.isArray(t)?t:[t]}executeInitializerGraph(){return null==this.initializer?[]:this.initializer.execute({},null==this.initializerSignature?[]:Object.keys(this.initializerSignature.outputs))}executeInitializerGraphAsync(){var t=this;return xe(function*(){return null==t.initializer?[]:t.initializer.executeAsync({},null==t.initializerSignature?[]:Object.keys(t.initializerSignature.outputs))})()}setResourceIdToCapturedInput(t){if(this.resourceIdToCapturedInput={},this.initializerSignature){const e=this.initializerSignature.outputs,r=Object.keys(e);for(let s=0;s<r.length;s++)this.resourceIdToCapturedInput[e[r[s]].resourceId]=t[s]}}execute(t,e){null==this.resourceIdToCapturedInput&&this.setResourceIdToCapturedInput(this.executeInitializerGraph()),t=this.normalizeInputs(t),e=this.normalizeOutputs(e);const r=this.executor.execute(t,e);return r.length>1?r:r[0]}executeAsync(t,e){var r=this;return xe(function*(){null==r.resourceIdToCapturedInput&&r.setResourceIdToCapturedInput(yield r.executeInitializerGraphAsync()),t=r.normalizeInputs(t),e=r.normalizeOutputs(e);const s=yield r.executor.executeAsync(t,e);return s.length>1?s:s[0]})()}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(t){return Object.keys(t).reduce((e,r)=>(e[r]=[t[r]],e),{})}dispose(){this.executor.dispose(),this.initializer&&(this.initializer.dispose(),this.resourceIdToCapturedInput&&lo(this.resourceIdToCapturedInput)),this.resourceManager.dispose()}}function xy(n){return cp.apply(this,arguments)}function cp(){return(cp=xe(function*(n,t={},e=P){if(null==n)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");null==t&&(t={}),t.fromTFHub&&"string"==typeof n&&(n=up(n));const r=new _y(n,t,e);return yield r.load(),r})).apply(this,arguments)}function up(n){return n.endsWith("/")||(n+="/"),`${n}model.json?tfjs-format=file`}function tl(n,t,e,r){return new(e||(e=Promise))(function(s,o){function l(h){try{d(r.next(h))}catch(p){o(p)}}function u(h){try{d(r.throw(h))}catch(p){o(p)}}function d(h){var p;h.done?s(h.value):(p=h.value,p instanceof e?p:new e(function(g){g(p)})).then(l,u)}d((r=r.apply(n,t||[])).next())})}function Gl(n,t){var e,r,s,o,l={label:0,sent:function(){if(1&s[0])throw s[1];return s[1]},trys:[],ops:[]};return o={next:u(0),throw:u(1),return:u(2)},"function"==typeof Symbol&&(o[Symbol.iterator]=function(){return this}),o;function u(d){return function(h){return function(p){if(e)throw new TypeError("Generator is already executing.");for(;o&&(o=0,p[0]&&(l=0)),l;)try{if(e=1,r&&(s=2&p[0]?r.return:p[0]?r.throw||((s=r.return)&&s.call(r),0):r.next)&&!(s=s.call(r,p[1])).done)return s;switch(r=0,s&&(p=[2&p[0],s.value]),p[0]){case 0:case 1:s=p;break;case 4:return l.label++,{value:p[1],done:!1};case 5:l.label++,r=p[1],p=[0];continue;case 7:p=l.ops.pop(),l.trys.pop();continue;default:if(!((s=(s=l.trys).length>0&&s[s.length-1])||6!==p[0]&&2!==p[0])){l=0;continue}if(3===p[0]&&(!s||p[1]>s[0]&&p[1]<s[3])){l.label=p[1];break}if(6===p[0]&&l.label<s[1]){l.label=s[1],s=p;break}if(s&&l.label<s[2]){l.label=s[2],l.ops.push(p);break}s[2]&&l.ops.pop(),l.trys.pop();continue}p=t.call(n,l)}catch(g){p=[6,g],r=0}finally{e=s=0}if(5&p[0])throw p[1];return{value:p[0]?p[1]:void 0,done:!0}}([d,h])}}}function zc(n,t,e){if(e||2===arguments.length)for(var r,s=0,o=t.length;s<o;s++)!r&&s in t||(r||(r=Array.prototype.slice.call(t,0,s)),r[s]=t[s]);return n.concat(r||Array.prototype.slice.call(t))}function dp(n){return[Math.abs(n.endPoint[0]-n.startPoint[0]),Math.abs(n.endPoint[1]-n.startPoint[1])]}function hp(n){return[n.startPoint[0]+(n.endPoint[0]-n.startPoint[0])/2,n.startPoint[1]+(n.endPoint[1]-n.startPoint[1])/2]}function U_(n,t){void 0===t&&(t=1.5);var e=hp(n),r=dp(n),s=[t*r[0]/2,t*r[1]/2];return{startPoint:[e[0]-s[0],e[1]-s[1]],endPoint:[e[0]+s[0],e[1]+s[1]],palmLandmarks:n.palmLandmarks}}function hE(n){var t=hp(n),e=dp(n),r=Math.max.apply(Math,e)/2;return{startPoint:[t[0]-r,t[1]-r],endPoint:[t[0]+r,t[1]+r],palmLandmarks:n.palmLandmarks}}function fE(n,t){var e=[n.endPoint[0]-n.startPoint[0],n.endPoint[1]-n.startPoint[1]],r=[e[0]*t[0],e[1]*t[1]];return{startPoint:[n.startPoint[0]+r[0],n.startPoint[1]+r[1]],endPoint:[n.endPoint[0]+r[0],n.endPoint[1]+r[1]],palmLandmarks:n.palmLandmarks}}"function"==typeof SuppressedError&&SuppressedError;var z_=function(){function n(t,e,r,s,o,l){this.model=t,this.width=e,this.height=r,this.iouThreshold=o,this.scoreThreshold=l,this.anchors=s.map(function(u){return[u.x_center,u.y_center]}),this.anchorsTensor=qu(this.anchors),this.inputSizeTensor=ho([e,r]),this.doubleInputSizeTensor=ho([2*e,2*r])}return n.prototype.normalizeBoxes=function(t){var e=this;return En(function(){var r=Pn(t,[0,0],[-1,2]),s=Pn(t,[0,2],[-1,2]),o=rn(Hn(r,e.inputSizeTensor),e.anchorsTensor),l=Hn(s,e.doubleInputSizeTensor),u=Nt(fn(o,l),e.inputSizeTensor),d=Nt(rn(o,l),e.inputSizeTensor);return kc([u,d],1)})},n.prototype.normalizeLandmarks=function(t,e){var r=this;return En(function(){var s=rn(Hn(tt(t,[-1,7,2]),r.inputSizeTensor),r.anchors[e]);return Nt(s,r.inputSizeTensor)})},n.prototype.getBoundingBoxes=function(t){return tl(this,void 0,void 0,function(){var e,r,s,o,l,u,d,h,p,g,y,b,_,I,S,T=this;return Gl(this,function(O){switch(O.label){case 0:return e=En(function(){return Nt(fn(t,.5),2)}),"webgl"===rv()?(s=Q().get("WEBGL_PACK_DEPTHWISECONV"),Q().set("WEBGL_PACK_DEPTHWISECONV",!0),r=this.model.predict(e),Q().set("WEBGL_PACK_DEPTHWISECONV",s)):r=this.model.predict(e),o=Ku(r),l=En(function(){return Ku(Ol(Pn(o,[0,0],[-1,1])))}),u=Pn(o,[0,1],[-1,4]),d=this.normalizeBoxes(u),h=console.warn,console.warn=function(){},p=nh.nonMaxSuppression(d,l,1,this.iouThreshold,this.scoreThreshold),console.warn=h,[4,p.array()];case 1:return g=O.sent(),y=[e,r,p,o,d,u,l],0===g.length?(y.forEach(function(V){return V.dispose()}),[2,null]):(_=Pn(d,[b=g[0],0],[1,-1]),I=Pn(o,[b,5],[1,14]),S=En(function(){return tt(T.normalizeLandmarks(I,b),[-1,2])}),y.push(I),y.forEach(function(V){return V.dispose()}),[2,{boxes:_,palmLandmarks:S}])}})})},n.prototype.estimateHandBounds=function(t){return tl(this,void 0,void 0,function(){var e,r,s,o,l,u,d,h,p=this;return Gl(this,function(g){switch(g.label){case 0:return e=t.shape[1],r=t.shape[2],s=En(function(){return Hn(nh.resizeBilinear(t,[p.width,p.height]),255)}),[4,this.getBoundingBoxes(s)];case 1:return null===(o=g.sent())?(s.dispose(),[2,null]):(l=o.boxes.arraySync(),u=l[0].slice(0,2),d=l[0].slice(2,4),h=o.palmLandmarks.arraySync(),s.dispose(),o.boxes.dispose(),o.palmLandmarks.dispose(),[2,(y={startPoint:u,endPoint:d,palmLandmarks:h},b=[r/this.width,e/this.height],{startPoint:[y.startPoint[0]*b[0],y.startPoint[1]*b[1]],endPoint:[y.endPoint[0]*b[0],y.endPoint[1]*b[1]],palmLandmarks:y.palmLandmarks.map(function(_){return[_[0]*b[0],_[1]*b[1]]})})])}var y,b})})},n}(),Cy={thumb:[1,2,3,4],indexFinger:[5,6,7,8],middleFinger:[9,10,11,12],ringFinger:[13,14,15,16],pinky:[17,18,19,20],palmBase:[0]},H_=function(n,t){return[[1,0,n],[0,1,t],[0,0,1]]};function Ju(n,t){for(var e=0,r=0;r<n.length;r++)e+=n[r]*t[r];return e}function oT(n,t){for(var e=[],r=0;r<n.length;r++)e.push(n[r][t]);return e}function mE(n,t){for(var e=[],r=n.length,s=0;s<r;s++){e.push([]);for(var o=0;o<r;o++)e[s].push(Ju(n[s],oT(t,o)))}return e}function gE(n,t){var e=Math.cos(n),r=Math.sin(n),s=[[e,-r,0],[r,e,0],[0,0,1]],o=mE(H_(t[0],t[1]),s);return mE(o,H_(-t[0],-t[1]))}function yE(n,t){return[Ju(n,t[0]),Ju(n,t[1])]}var vE=[0,-.4],fp=[0,-.1],W_=[0,5,9,13,17,1,2],bE=function(){function n(t,e,r,s,o,l){this.boundingBoxDetector=t,this.meshDetector=e,this.meshWidth=r,this.meshHeight=s,this.maxContinuousChecks=o,this.detectionConfidence=l,this.regionsOfInterest=[],this.runsWithoutHandDetector=0,this.maxHandsNumber=1}return n.prototype.getBoxForPalmLandmarks=function(t,e){var r=t.map(function(s){return yE(zc(zc([],s,!0),[1],!1),e)});return U_(hE(fE(this.calculateLandmarksBoundingBox(r),vE)),3)},n.prototype.getBoxForHandLandmarks=function(t){for(var e=U_(hE(fE(this.calculateLandmarksBoundingBox(t),fp)),1.65),r=[],s=0;s<W_.length;s++)r.push(t[W_[s]].slice(0,2));return e.palmLandmarks=r,e},n.prototype.transformRawCoords=function(t,e,r,s){var o,l,u,d,h=this,p=dp(e),g=[p[0]/this.meshWidth,p[1]/this.meshHeight],y=t.map(function(O){return[g[0]*(O[0]-h.meshWidth/2),g[1]*(O[1]-h.meshHeight/2),O[2]]}),b=gE(r,[0,0]),_=y.map(function(O){return zc(zc([],yE(O,b),!0),[O[2]],!1)}),I=(d=[-Ju((l=[[(o=s)[0][0],o[1][0]],[o[0][1],o[1][1]]])[0],u=[o[0][2],o[1][2]]),-Ju(l[1],u)],[l[0].concat(d[0]),l[1].concat(d[1]),[0,0,1]]),S=zc(zc([],hp(e),!0),[1],!1),T=[Ju(S,I[0]),Ju(S,I[1])];return _.map(function(O){return[O[0]+T[0],O[1]+T[1],O[2]]})},n.prototype.estimateHand=function(t){return tl(this,void 0,void 0,function(){var e,r,s,o,l,d,h,p,g,y,b,_,I,S,T,O,V,U,j;return Gl(this,function(te){switch(te.label){case 0:return!0!==(e=this.shouldUpdateRegionsOfInterest())?[3,2]:[4,this.boundingBoxDetector.estimateHandBounds(t)];case 1:return null===(r=te.sent())?(t.dispose(),this.regionsOfInterest=[],[2,null]):(this.updateRegionsOfInterest(r,!0),this.runsWithoutHandDetector=0,[3,3]);case 2:this.runsWithoutHandDetector++,te.label=3;case 3:return o=function pE(n,t){var e;return(e=Math.PI/2-Math.atan2(-(t[1]-n[1]),t[0]-n[0]))-2*Math.PI*Math.floor((e+Math.PI)/(2*Math.PI))}((s=this.regionsOfInterest[0]).palmLandmarks[0],s.palmLandmarks[2]),l=hp(s),d=nh.rotateWithOffset(t,o,0,[l[0]/t.shape[2],l[1]/t.shape[1]]),h=gE(-o,l),p=!0===e?this.getBoxForPalmLandmarks(s.palmLandmarks,h):s,g=nh.cropAndResize(le=d,[[(se=p).startPoint[1]/(be=le.shape[1]),se.startPoint[0]/(Me=le.shape[2]),se.endPoint[1]/be,se.endPoint[0]/Me]],[0],[this.meshWidth,this.meshHeight]),y=Hn(g,255),g.dispose(),d.dispose(),"webgl"===rv()?(_=Q().get("WEBGL_PACK_DEPTHWISECONV"),Q().set("WEBGL_PACK_DEPTHWISECONV",!0),b=this.meshDetector.predict(y),Q().set("WEBGL_PACK_DEPTHWISECONV",_)):b=this.meshDetector.predict(y),I=b[0],S=b[1],y.dispose(),T=I.dataSync()[0],I.dispose(),T<this.detectionConfidence?(S.dispose(),this.regionsOfInterest=[],[2,null]):(O=tt(S,[-1,3]),V=O.arraySync(),S.dispose(),O.dispose(),U=this.transformRawCoords(V,p,o,h),j=this.getBoxForHandLandmarks(U),this.updateRegionsOfInterest(j,!1),[2,{landmarks:U,handInViewConfidence:T,boundingBox:{topLeft:j.startPoint,bottomRight:j.endPoint}}])}var se,le,be,Me})})},n.prototype.calculateLandmarksBoundingBox=function(t){var e=t.map(function(s){return s[0]}),r=t.map(function(s){return s[1]});return{startPoint:[Math.min.apply(Math,e),Math.min.apply(Math,r)],endPoint:[Math.max.apply(Math,e),Math.max.apply(Math,r)]}},n.prototype.updateRegionsOfInterest=function(t,e){if(e)this.regionsOfInterest=[t];else{var r=this.regionsOfInterest[0],s=0;if(null!=r&&null!=r.startPoint){var o=t.startPoint,l=o[0],u=o[1],d=t.endPoint,h=d[0],p=d[1],g=r.startPoint,y=g[0],b=g[1],_=r.endPoint,I=_[0],S=_[1],T=Math.max(l,y),O=Math.max(u,b),V=(Math.min(h,I)-T)*(Math.min(p,S)-O);s=V/((h-l)*(p-u)+(I-y)*(S-u)-V)}this.regionsOfInterest[0]=s>.8?r:t}},n.prototype.shouldUpdateRegionsOfInterest=function(){return this.regionsOfInterest.length!==this.maxHandsNumber||this.runsWithoutHandDetector>=this.maxContinuousChecks},n}();function j_(){return tl(this,void 0,void 0,function(){return Gl(this,function(n){return[2,xy("https://tfhub.dev/mediapipe/tfjs-model/handdetector/1/default/1",{fromTFHub:!0})]})})}function Hc(){return tl(this,void 0,void 0,function(){return Gl(this,function(n){return[2,xy("https://tfhub.dev/mediapipe/tfjs-model/handskeleton/1/default/1",{fromTFHub:!0})]})})}function G_(){return tl(this,void 0,void 0,function(){return Gl(this,function(n){return[2,Bp("https://tfhub.dev/mediapipe/tfjs-model/handskeleton/1/default/1/anchors.json?tfjs-format=file").then(function(t){return t.json()})]})})}var Ey=function(){function n(t){this.pipeline=t}return n.getAnnotations=function(){return Cy},n.prototype.estimateHands=function(t,e){return void 0===e&&(e=!1),tl(this,void 0,void 0,function(){var s,o,l,u,d,h,p,g;return Gl(this,function(y){switch(y.label){case 0:return s=((b=t)instanceof Rr?[b.shape[0],b.shape[1]]:[b.height,b.width])[1],o=En(function(){return t instanceof Rr||(t=Cu(t)),ra(fr(t,"float32"))}),[4,this.pipeline.estimateHand(o)];case 1:if(l=y.sent(),o.dispose(),null===l)return[2,[]];for(u=l,!0===e&&(u=function(b,_){var T=b.boundingBox;return{handInViewConfidence:b.handInViewConfidence,landmarks:b.landmarks.map(function(O){return[_-1-O[0],O[1],O[2]]}),boundingBox:{topLeft:[_-1-T.topLeft[0],T.topLeft[1]],bottomRight:[_-1-T.bottomRight[0],T.bottomRight[1]]}}}(l,s)),d={},h=0,p=Object.keys(Cy);h<p.length;h++)d[g=p[h]]=Cy[g].map(function(b){return u.landmarks[b]});return[2,[{handInViewConfidence:u.handInViewConfidence,boundingBox:u.boundingBox,landmarks:u.landmarks,annotations:d}]]}var b})})},n}();const Kl={},ed={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function ha(n,t){if(!(n in Kl)||null!=t){const r=function aT(n,t){if(1!==n&&2!==n)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const e=null==t?function iT(n){if(!Q().getBool("IS_SAFARI")&&"undefined"!=typeof OffscreenCanvas&&2===n)return new OffscreenCanvas(300,150);if("undefined"!=typeof document)return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}(n):t;return e.addEventListener("webglcontextlost",r=>{r.preventDefault(),delete Kl[n]},!1),Q().getBool("SOFTWARE_WEBGL_ENABLED")&&(ed.failIfMajorPerformanceCaveat=!1),1===n?e.getContext("webgl",ed)||e.getContext("experimental-webgl",ed):e.getContext("webgl2",ed)}(n,t);if(null===r)return console.log("Could not get context for WebGL version",n),null;Kl[n]=r}const e=Kl[n];return null==e||e.isContextLost()?(delete Kl[n],ha(n)):(e.disable(e.DEPTH_TEST),e.disable(e.STENCIL_TEST),e.disable(e.BLEND),e.disable(e.DITHER),e.disable(e.POLYGON_OFFSET_FILL),e.disable(e.SAMPLE_COVERAGE),e.enable(e.SCISSOR_TEST),e.enable(e.CULL_FACE),e.cullFace(e.BACK),Kl[n])}var yh=(()=>{return(n=yh||(yh={}))[n.DENSE=0]="DENSE",n[n.SHARED_BATCH=1]="SHARED_BATCH",yh;var n})(),eo=(()=>{return(n=eo||(eo={}))[n.RENDER=0]="RENDER",n[n.UPLOAD=1]="UPLOAD",n[n.PIXELS=2]="PIXELS",n[n.DOWNLOAD=3]="DOWNLOAD",eo;var n})(),cs=(()=>{return(n=cs||(cs={}))[n.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",n[n.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",n[n.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",n[n.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",n[n.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16",cs;var n})();function vh(n,t){return[t,n]}function bh(n){const t=Ee(n);return wr(Math.ceil(t/4))}function td(n,t){return[Math.max(1,Math.ceil(t/2)),Math.max(1,Math.ceil(n/2))]}function mp(n,t){const e=n;let r,s,o,l,u,d,h,p,g,y;return 2===Q().getNumber("WEBGL_VERSION")?(r=e.R32F,s=e.R16F,o=e.RGBA16F,l=e.RGBA32F,u=e.RED,h=4,p=1,g=e.HALF_FLOAT,y=e.FLOAT,d=e.RGBA8):(r=n.RGBA,s=n.RGBA,o=n.RGBA,l=e.RGBA,u=n.RGBA,h=4,p=4,g=null!=t?t.HALF_FLOAT_OES:null,y=n.FLOAT,d=n.RGBA),{internalFormatFloat:r,internalFormatHalfFloat:s,internalFormatPackedHalfFloat:o,internalFormatPackedFloat:l,textureFormatFloat:u,downloadTextureFormat:d,downloadUnpackNumChannels:h,defaultNumChannels:p,textureTypeHalfFloat:g,textureTypeFloat:y}}function At(n,t){const e=t();return Q().getBool("DEBUG")&&function cT(n){const t=n.getError();if(t!==n.NO_ERROR)throw new Error("WebGL Error: "+function EE(n,t){switch(t){case n.NO_ERROR:return"NO_ERROR";case n.INVALID_ENUM:return"INVALID_ENUM";case n.INVALID_VALUE:return"INVALID_VALUE";case n.INVALID_OPERATION:return"INVALID_OPERATION";case n.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case n.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case n.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${t}`}}(n,t))}(n),e}function SE(n){return!!(Q().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||0===n||5.96e-8<Math.abs(n)&&Math.abs(n)<65504)}function Dy(n,t){return R(n,()=>n.getExtension(t),'Extension "'+t+'" not supported on this browser.')}const DE=/ERROR: [0-9]+:([0-9]+):/g;function X_(n,t){const e=DE.exec(t);if(null==e)return console.log(`Couldn't parse line number in error: ${t}`),void console.log(n);const r=+e[1],s=n.split("\n"),o=s.length.toString().length+2,l=s.map((g,y)=>vr((y+1).toString(),o)+g);let u=0;for(let g=0;g<l.length;g++)u=Math.max(l[g].length,u);const d=l.slice(0,r-1),h=l.slice(r-1,r),p=l.slice(r);console.log(d.join("\n")),console.log(t.split("\n")[0]),console.log(`%c ${vr(h[0],u)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(p.join("\n"))}function Y_(n,t){if(At(n,()=>n.validateProgram(t)),!1===n.getProgramParameter(t,n.VALIDATE_STATUS))throw console.log(n.getProgramInfoLog(t)),new Error("Shader program validation failed.")}function TE(n,t,e,r,s,o,l){const u=n.getAttribLocation(t,e);return-1!==u&&(At(n,()=>n.bindBuffer(n.ARRAY_BUFFER,r)),At(n,()=>n.vertexAttribPointer(u,s,n.FLOAT,!1,o,l)),At(n,()=>n.enableVertexAttribArray(u)),!0)}function c(n,t,e,r){At(n,()=>function bT(n,t,e){(function L(n,t){const e=n.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,r=t+n.TEXTURE0;if(r<n.TEXTURE0||r>e)throw new Error(`textureUnit must be in [gl.TEXTURE0, gl.TEXTURE${e}].`)})(n,e),At(n,()=>n.activeTexture(n.TEXTURE0+e)),At(n,()=>n.bindTexture(n.TEXTURE_2D,t))}(n,t,r)),At(n,()=>n.uniform1i(e,r))}function m(n,t,e){At(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,e)),At(n,()=>n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,t,0))}function v(n,t){At(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,t)),At(n,()=>n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,null,0))}function w(n){const t=n.checkFramebufferStatus(n.FRAMEBUFFER);if(t!==n.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+function D(n,t){switch(t){case n.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case n.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case n.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case n.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${t}`}}(n,t))}function R(n,t,e){const r=At(n,()=>t());if(null==r)throw new Error(e);return r}function W(n,t=2){return Ee(n.slice(0,n.length-t))}function J(n){if(0===n.length)throw Error("Cannot get rows and columns of an empty shape array.");return[n.length>1?n[n.length-2]:1,n[n.length-1]]}function fe(n){let t=[1,1,1];return 0===n.length||1===n.length&&1===n[0]||(t=[W(n),...J(n)]),t}function Qe(n){return n%2==0}function mt(n,t){if(un(n=n.slice(-2),t=t.slice(-2))||!n.length||!t.length||0===n[0]||0===n[1]||0===t[0]||0===t[1])return!0;if(n.length!==t.length){const e=n[n.length-1],r=t[t.length-1];if(e===r||Qe(e)&&Qe(r)&&(1===n[0]||1===t[0]))return!0}return n[1]===t[1]&&Qe(n[0])&&Qe(t[0])}let Et,Ut;function Cs(n,t){return null!=n.getExtension(t)}function gp(n){try{if(null!=ha(n))return!0}catch(t){return console.log("Error when getting WebGL context: ",t),!1}return!1}function _h(n){const t=mp(n),e=n.createTexture();n.bindTexture(n.TEXTURE_2D,e),n.texImage2D(n.TEXTURE_2D,0,t.internalFormatFloat,1,1,0,t.textureFormatFloat,t.textureTypeFloat,null);const o=n.createFramebuffer();n.bindFramebuffer(n.FRAMEBUFFER,o),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,e,0);const l=n.checkFramebufferStatus(n.FRAMEBUFFER)===n.FRAMEBUFFER_COMPLETE;return n.bindTexture(n.TEXTURE_2D,null),n.bindFramebuffer(n.FRAMEBUFFER,null),n.deleteTexture(e),n.deleteFramebuffer(o),l}function Wc(n,t){Array.isArray(n)||(n=[n]),n.forEach(e=>{null!=e&&G("complex64"!==e.dtype,()=>`${t} does not support complex64 tensors in the WebGL backend.`)})}const Gt=Q();function Ss(){let n,t,e,r,s,o,l,u,d,h;return 2===Q().getNumber("WEBGL_VERSION")?(n="#version 300 es",t="in",e="out",r="in",s="texture",o="outputColor",l="out vec4 outputColor;",u=Q().getBool("WEBGL2_ISNAN_CUSTOM")?"\n      bool isnan_custom(float val) {\n        uint floatToUint = floatBitsToUint(val);\n        return (floatToUint & 0x7fffffffu) > 0x7f800000u;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    ":"",d="",h="\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "):(n="",t="attribute",e="varying",r="varying",s="texture2D",o="gl_FragColor",l="",u="\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    ",d="\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    ",h="\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "),{version:n,attribute:t,varyingVs:e,varyingFs:r,texture2D:s,output:o,defineOutput:l,defineSpecialNaN:u,defineSpecialInf:d,defineRound:h}}function xh(n,t,e="index"){const r=Wt(t);return r.map((s,o)=>`int ${n[o]} = ${e} / ${s}; ${o===r.length-1?`int ${n[o+1]} = ${e} - ${n[o]} * ${s}`:`index -= ${n[o]} * ${s}`};`).join("")}function Z_(n,t,e="index"){const r=Wt(t);return r.map((s,o)=>`int ${n[o]} = ${e} / outShapeStrides[${o}]; ${o===r.length-1?`int ${n[o+1]} = ${e} - ${n[o]} * outShapeStrides[${o}]`:`index -= ${n[o]} * outShapeStrides[${o}]`};`).join("")}function NE(n){const t=Wt(n).map(e=>e.toString());return`\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * ${t[0]} + coords.y * ${t[1]} + coords.z;\n  }\n`}Gt.registerFlag("HAS_WEBGL",()=>Gt.getNumber("WEBGL_VERSION")>0),Gt.registerFlag("WEBGL_VERSION",()=>gp(2)?2:gp(1)?1:0),Gt.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1),Gt.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>2===Gt.get("WEBGL_VERSION")),Gt.registerFlag("WEBGL_CPU_FORWARD",()=>!0),Gt.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1),Gt.registerFlag("WEBGL_PACK",()=>Gt.getBool("HAS_WEBGL")),Gt.registerFlag("WEBGL_PACK_NORMALIZATION",()=>Gt.getBool("WEBGL_PACK")),Gt.registerFlag("WEBGL_PACK_CLIP",()=>Gt.getBool("WEBGL_PACK")),Gt.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>Gt.getBool("WEBGL_PACK")),Gt.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>Gt.getBool("WEBGL_PACK")),Gt.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>Gt.getBool("WEBGL_PACK")),Gt.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>Gt.getBool("WEBGL_PACK")),Gt.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>Gt.getBool("WEBGL_PACK")),Gt.registerFlag("WEBGL_PACK_REDUCE",()=>Gt.getBool("WEBGL_PACK")),Gt.registerFlag("WEBGL_LAZILY_UNPACK",()=>Gt.getBool("WEBGL_PACK")),Gt.registerFlag("WEBGL_CONV_IM2COL",()=>Gt.getBool("WEBGL_PACK")),Gt.registerFlag("WEBGL_PACK_CONV2DTRANSPOSE",()=>Gt.getBool("WEBGL_PACK")),Gt.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>function en(n){if(null==Et){const t=ha(n);Et=t.getParameter(t.MAX_TEXTURE_SIZE)}return Et}(Gt.getNumber("WEBGL_VERSION"))),Gt.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>function On(n){if(null==Ut){const t=ha(n);Ut=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,Ut)}(Gt.getNumber("WEBGL_VERSION"))),Gt.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{const n=Gt.getNumber("WEBGL_VERSION");return 0===n?0:function xr(n){if(0===n)return 0;let t;const e=ha(n);return t=Cs(e,"EXT_disjoint_timer_query_webgl2")&&2===n?2:Cs(e,"EXT_disjoint_timer_query")?1:0,t}(n)}),Gt.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>Gt.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!gu()),Gt.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>function Ty(n){if(0===n)return!1;const t=ha(n);if(1===n){if(!Cs(t,"OES_texture_float"))return!1}else if(!Cs(t,"EXT_color_buffer_float"))return!1;return _h(t)}(Gt.getNumber("WEBGL_VERSION"))),Gt.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>!Gt.getBool("WEBGL_FORCE_F16_TEXTURES")&&Gt.getBool("WEBGL_RENDER_FLOAT32_CAPABLE")),Gt.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>function Ny(n){if(0===n)return!1;const t=ha(n);if(1!==n){if(Cs(t,"EXT_color_buffer_float"))return _h(t);const r="EXT_color_buffer_half_float";if(Cs(t,r)){const s=t.getExtension(r);return function ky(n,t){const e=mp(n,t),r=n.createTexture();n.bindTexture(n.TEXTURE_2D,r),n.texImage2D(n.TEXTURE_2D,0,e.internalFormatHalfFloat,1,1,0,e.textureFormatFloat,e.textureTypeHalfFloat,null);const l=n.createFramebuffer();n.bindFramebuffer(n.FRAMEBUFFER,l),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,r,0);const u=n.checkFramebufferStatus(n.FRAMEBUFFER)===n.FRAMEBUFFER_COMPLETE;return n.bindTexture(n.TEXTURE_2D,null),n.bindFramebuffer(n.FRAMEBUFFER,null),n.deleteTexture(r),n.deleteFramebuffer(l),u}(t,s)}return!1}return!(!Cs(t,"OES_texture_float")||!Cs(t,"WEBGL_color_buffer_float"))&&_h(t)}(Gt.getNumber("WEBGL_VERSION"))),Gt.registerFlag("WEBGL_FENCE_API_ENABLED",()=>function Ay(n){return 2===n&&null!=ha(n).fenceSync}(Gt.getNumber("WEBGL_VERSION"))),Gt.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>Gt.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0),Gt.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,n=>{if("number"!=typeof n)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be a number but got ${n}.`);if(n<0&&-1!==n)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${n}.`)}),Gt.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>gu()?1:-1,n=>{if("number"!=typeof n)throw new Error(`WEBGL_FLUSH_THRESHOLD must be a number but got ${n}.`);if(n<0&&-1!==n)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${n}.`)}),Gt.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128),Gt.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1),Gt.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5),Gt.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128),Gt.registerFlag("WEBGL_EXP_CONV",()=>!1),Gt.registerFlag("SOFTWARE_WEBGL_ENABLED",()=>Gt.getBool("IS_TEST")),Gt.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",()=>1/0),Gt.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",()=>!1),Gt.registerFlag("WEBGL2_ISNAN_CUSTOM",()=>!1),Gt.registerFlag("ENGINE_COMPILE_ONLY",()=>!1);const _T="\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n",{getBroadcastDims:xT}=Le;function vR(n,t,e){const r=[];if(n.forEach(b=>{const _=Ee(b.shapeInfo.logicalShape);if(b.shapeInfo.isUniform?r.push(`uniform float ${b.name}${_>1?`[${_}]`:""};`):(r.push(`uniform sampler2D ${b.name};`),r.push(`uniform int offset${b.name};`)),e.enableShapeUniforms){const{uniformShape:I}=AE(e.packedInputs,b.shapeInfo.logicalShape,b.shapeInfo.texShape);switch(I.length){case 1:r.push(`uniform int ${b.name}Shape;`);break;case 2:r.push(`uniform ivec2 ${b.name}Shape;`);break;case 3:r.push(`uniform ivec3 ${b.name}Shape;`);break;case 4:r.push(`uniform ivec4 ${b.name}Shape;`)}r.push(`uniform ivec2 ${b.name}TexShape;`)}}),e.enableShapeUniforms){switch(t.logicalShape.length){case 1:r.push("uniform int outShape;");break;case 2:r.push("uniform ivec2 outShape;"),r.push("uniform int outShapeStrides;");break;case 3:r.push("uniform ivec3 outShape;"),r.push("uniform ivec2 outShapeStrides;");break;case 4:r.push("uniform ivec4 outShape;"),r.push("uniform ivec3 outShapeStrides;")}r.push("uniform ivec2 outTexShape;")}e.customUniforms&&e.customUniforms.forEach(b=>{r.push(`uniform ${b.type} ${b.name}${b.arrayIndex?`[${b.arrayIndex}]`:""};`)});const s=r.join("\n"),o=n.map(b=>function bR(n,t,e=!1,r){let s="";return s+=e?wT(n,r):yp(n,r),n.shapeInfo.logicalShape.length<=t.logicalShape.length&&(s+=e?function QR(n,t){const e=n.name,r=e.charAt(0).toUpperCase()+e.slice(1),s="get"+r+"AtOutCoords",o=n.shapeInfo.logicalShape.length,l=t.logicalShape.length,u=xT(n.shapeInfo.logicalShape,t.logicalShape),d=ir(l),h=l-o;let p;const g=["x","y","z","w","u","v"];p=0===o?"":l<2&&u.length>=1?"coords = 0;":u.map(O=>`coords.${g[O+h]} = 0;`).join("\n");let y="";y=l<2&&o>0?"coords":n.shapeInfo.logicalShape.map((O,V)=>`coords.${g[V+h]}`).join(", ");let b="return outputValue;";const I=1===Ee(n.shapeInfo.logicalShape),T=1===Ee(t.logicalShape);if(1!==o||I||T){if(I&&!T)b=1===l?"\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      ":"\n        return vec4(outputValue.x);\n      ";else if(u.length){const O=o-2,V=o-1;u.indexOf(O)>-1&&u.indexOf(V)>-1?b="return vec4(outputValue.x);":u.indexOf(O)>-1?b="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":u.indexOf(V)>-1&&(b="return vec4(outputValue.xx, outputValue.zz);")}}else b="\n      return vec4(outputValue.xy, outputValue.xy);\n    ";return`\n    vec4 ${s}() {\n      ${d} coords = getOutputCoords();\n      ${p}\n      vec4 outputValue = get${r}(${y});\n      ${b}\n    }\n  `}(n,t):function JR(n,t){const e=n.name,r=e.charAt(0).toUpperCase()+e.slice(1),s="get"+r+"AtOutCoords",u=n.shapeInfo.logicalShape.length,d=t.logicalShape.length;if(!n.shapeInfo.isUniform&&u===d&&null==n.shapeInfo.flatOffset&&un(n.shapeInfo.texShape,t.texShape))return`\n      float ${s}() {\n        return sampleTexture(${e}, resultUV);\n      }\n    `;const h=ir(d),p=xT(n.shapeInfo.logicalShape,t.logicalShape),g=d-u;let y;const b=["x","y","z","w","u","v"];y=0===u?"":d<2&&p.length>=1?"coords = 0;":p.map(I=>`coords.${b[I+g]} = 0;`).join("\n");let _="";return _=d<2&&u>0?"coords":n.shapeInfo.logicalShape.map((I,S)=>`coords.${b[S+g]}`).join(", "),`\n    float ${s}() {\n      ${h} coords = getOutputCoords();\n      ${y}\n      return get${r}(${_});\n    }\n  `}(n,t)),s}(b,t,e.packedInputs,e.enableShapeUniforms)).join("\n"),l=t.texShape,u=Ss(),d=function wR(n){return`\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return ${n.texture2D}(textureSampler, uv).r;\n    }\n  `}(u);let h,p,g=function ER(n){return`${n.version}\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ${n.varyingFs} vec2 resultUV;\n    ${n.defineOutput}\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    ${n.defineSpecialNaN}\n    ${n.defineSpecialInf}\n    ${n.defineRound}\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    ${IR}\n    ${DR}\n    ${TR}\n  `}(u);return t.isPacked?(h=function _R(n,t,e){switch(n.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return function kR(n,t,e){const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];return 1===r[0]?e?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));\n      }\n    ":`\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ${r[1]}.0);\n      }\n    `:1===r[1]?e?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));\n      }\n    ":`\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ${r[0]}.0);\n      }\n    `:e?"\n    int getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);\n    }\n  ":`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      return 2 * (resTexRC.x * ${r[1]} + resTexRC.y);\n    }\n  `}(0,t,e);case 2:return function LR(n,t,e){const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(un(n,t))return e?"\n      ivec2 getOutputCoords() {\n        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(${r[0]}, ${r[1]}));\n      }\n    `;const s=Math.ceil(n[1]/2);return e?"\n    ivec2 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec2(r, c);\n    }\n  ":`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n      int r = 2 * (index / ${s});\n      int c = imod(index, ${s}) * 2;\n\n      return ivec2(r, c);\n    }\n  `}(n,t,e);case 3:return function RR(n,t,e){if(e)return"\n    ivec3 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec3(b, r, c);\n    }\n  ";const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],s=Math.ceil(n[2]/2),o=s*Math.ceil(n[1]/2);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n\n      int b = index / ${o};\n      index -= b * ${o};\n\n      int r = 2 * (index / ${s});\n      int c = imod(index, ${s}) * 2;\n\n      return ivec3(b, r, c);\n    }\n  `}(n,t,e);default:return function OR(n,t,e){if(e)return"\n    ivec4 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatchN = texelsInBatch * outShape[1];\n\n      int b2 = index / texelsInBatchN;\n      index -= b2 * texelsInBatchN;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec4(b2, b, r, c);\n    }\n  ";const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],s=Math.ceil(n[n.length-1]/2),o=s*Math.ceil(n[n.length-2]/2);let l=o,u="",d="b, r, c";for(let h=2;h<n.length-1;h++)l*=n[n.length-h-1],u=`\n      int b${h} = index / ${l};\n      index -= b${h} * ${l};\n    `+u,d=`b${h}, `+d;return`\n    ivec${n.length} getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n\n      ${u}\n\n      int b = index / ${o};\n      index -= b * ${o};\n\n      int r = 2 * (index / ${s});\n      int c = imod(index, ${s}) * 2;\n\n      return ivec${n.length}(${d});\n    }\n  `}(n,t,e)}}(t.logicalShape,l,e.enableShapeUniforms),p=function SR(n){return`\n    void setOutput(vec4 val) {\n      ${n.output} = val;\n    }\n  `}(u)):(h=function xR(n,t,e){switch(n.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return function AR(n,t,e){return 1===t[0]?e?"\n      int getOutputCoords() {\n        return int(resultUV.x * float(outTexShape[1]));\n      }\n    ":`\n      int getOutputCoords() {\n        return int(resultUV.x * ${t[1]}.0);\n      }\n    `:1===t[1]?e?"\n      int getOutputCoords() {\n        return int(resultUV.y * float(outTexShape[0]));\n      }\n    ":`\n      int getOutputCoords() {\n        return int(resultUV.y * ${t[0]}.0);\n      }\n    `:e?"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      return resTexRC.x * outTexShape[1] + resTexRC.y;\n    }\n  ":`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      return resTexRC.x * ${t[1]} + resTexRC.y;\n    }\n  `}(0,t,e);case 2:return function BR(n,t,e){return un(n,t)?e?"\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(${t[0]}, ${t[1]}));\n      }\n    `:1===n[1]?e?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${t[0]}, ${t[1]}));\n        int index = resTexRC.x * ${t[1]} + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    `:1===n[0]?e?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(0, index);\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${t[0]}, ${t[1]}));\n        int index = resTexRC.x * ${t[1]} + resTexRC.y;\n        return ivec2(0, index);\n      }\n    `:e?"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      int r = index / outShape[1];\n      int c = index - r * outShape[1];\n      return ivec2(r, c);\n    }\n  ":`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      int r = index / ${n[1]};\n      int c = index - r * ${n[1]};\n      return ivec2(r, c);\n    }\n  `}(n,t,e);case 3:return function MR(n,t,e){if(e)return`\n  ivec3 getOutputCoords() {\n    ivec2 resTexRC = ivec2(resultUV.yx *\n                           vec2(outTexShape[0], outTexShape[1]));\n    int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n    ${Z_(["r","c","d"],n)}\n    return ivec3(r, c, d);\n  }\n`;const r=xh(["r","c","d"],n);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      ${r}\n      return ivec3(r, c, d);\n    }\n  `}(n,t,e);case 4:return function FR(n,t,e){if(e)return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      ${Z_(["r","c","d","d2"],n)}\n      return ivec4(r, c, d, d2);\n    }\n  `;const r=xh(["r","c","d","d2"],n);return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      ${r}\n      return ivec4(r, c, d, d2);\n    }\n  `}(n,t,e);case 5:return function $R(n,t){const e=xh(["r","c","d","d2","d3"],n);return`\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${t[0]},\n                             ${t[1]}));\n\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n\n      ${e}\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  `}(n,t);case 6:return function PR(n,t){const e=xh(["r","c","d","d2","d3","d4"],n);return`\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n\n      ${e}\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  `}(n,t);default:throw new Error(`${n.length}-D output sampling is not yet supported`)}}(t.logicalShape,l,e.enableShapeUniforms),p=function CR(n){return`\n    void setOutput(float val) {\n      ${n.output} = vec4(val, 0, 0, 0);\n    }\n  `}(u)),e.packedInputs&&(g+=NR),[g,d,p,s,h,o,e.userCode].join("\n")}function yp(n,t=!1){const e=n.shapeInfo.logicalShape;switch(e.length){case 0:return function UR(n,t){const e=n.name,r="get"+e.charAt(0).toUpperCase()+e.slice(1);if(n.shapeInfo.isUniform)return`float ${r}() {return ${e};}`;const[s,o]=n.shapeInfo.texShape;if(1===s&&1===o)return`\n      float ${r}() {\n        return sampleTexture(${e}, halfCR);\n      }\n    `;const l=wh(e);if(t)return`\n    float ${r}() {\n      vec2 uv = uvFromFlat(${e}TexShape[0], ${e}TexShape[1], ${l});\n      return sampleTexture(${e}, uv);\n    }\n  `;const[u,d]=n.shapeInfo.texShape;return`\n    float ${r}() {\n      vec2 uv = uvFromFlat(${u}, ${d}, ${l});\n      return sampleTexture(${e}, uv);\n    }\n  `}(n,t);case 1:return function HR(n,t){const e=n.name,r="get"+e.charAt(0).toUpperCase()+e.slice(1);if(n.shapeInfo.isUniform)return`\n      float ${r}(int index) {\n        ${vp(n)}\n      }\n    `;const s=n.shapeInfo.texShape,o=s[0],l=s[1];if(1===l&&1===o)return`\n      float ${r}(int index) {\n        return sampleTexture(${e}, halfCR);\n      }\n    `;const u=wh(e);return 1===l?t?`\n      float ${r}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${u}) + 0.5) / float(${e}TexShape[0]));\n        return sampleTexture(${e}, uv);\n      }\n    `:`\n      float ${r}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${u}) + 0.5) / ${o}.0);\n        return sampleTexture(${e}, uv);\n      }\n    `:1===o?t?`\n      float ${r}(int index) {\n        vec2 uv = vec2((float(index + ${u}) + 0.5) / float(${e}TexShape[1]), 0.5);\n        return sampleTexture(${e}, uv);\n      }\n    `:`\n      float ${r}(int index) {\n        vec2 uv = vec2((float(index + ${u}) + 0.5) / ${l}.0, 0.5);\n        return sampleTexture(${e}, uv);\n      }\n    `:t?`\n    float ${r}(int index) {\n      vec2 uv = uvFromFlat(${e}TexShape[0], ${e}TexShape[1], index + ${u});\n      return sampleTexture(${e}, uv);\n    }\n  `:`\n    float ${r}(int index) {\n      vec2 uv = uvFromFlat(${o}, ${l}, index + ${u});\n      return sampleTexture(${e}, uv);\n    }\n  `}(n,t);case 2:return function jR(n,t){const e=n.shapeInfo.logicalShape,r=n.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),o=n.shapeInfo.texShape;if(null!=o&&un(e,o))return t?`\n      float ${s}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${s}(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(${o[1]}.0, ${o[0]}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `;const{newShape:l,keptDims:u}=St(e);if(l.length<e.length){const b=["row","col"];return`\n      ${yp(bp(n,l),t)}\n      float ${s}(int row, int col) {\n        return ${s}(${_p(b,u)});\n      }\n    `}if(n.shapeInfo.isUniform)return`\n      float ${s}(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(${e[1]}, 1)));\n        ${vp(n)}\n      }\n    `;const h=o[0],p=o[1],g=wh(r);return 1===p?t?`\n      float ${s}(int row, int col) {\n        float index = dot(vec3(row, col, ${g}), vec3(${r}Shape[1], 1, 1));\n        vec2 uv = vec2(0.5, (index + 0.5) / float(${r}TexShape[0]));\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${s}(int row, int col) {\n      float index = dot(vec3(row, col, ${g}), vec3(${e[1]}, 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / ${h}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `:1===h?t?`\n      float ${s}(int row, int col) {\n        float index = dot(vec3(row, col, ${g}), vec3(${r}Shape[1], 1, 1));\n        vec2 uv = vec2((index + 0.5) / float(${r}TexShape[1]), 0.5);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${s}(int row, int col) {\n      float index = dot(vec3(row, col, ${g}), vec3(${e[1]}, 1, 1));\n      vec2 uv = vec2((index + 0.5) / ${p}.0, 0.5);\n      return sampleTexture(${r}, uv);\n    }\n  `:t?`\n      float ${s}(int row, int col) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${r}Shape[1] + col + ${g};\n        vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n  float ${s}(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * ${e[1]} + col + ${g};\n    vec2 uv = uvFromFlat(${h}, ${p}, index);\n    return sampleTexture(${r}, uv);\n  }\n`}(n,t);case 3:return function KR(n,t){const e=n.shapeInfo.logicalShape,r=n.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),o=e[1]*e[2],l=e[2],{newShape:u,keptDims:d}=St(e);if(u.length<e.length){const S=["row","col","depth"];return`\n        ${yp(bp(n,u),t)}\n        float ${s}(int row, int col, int depth) {\n          return ${s}(${_p(S,d)});\n        }\n      `}if(n.shapeInfo.isUniform)return`\n      float ${s}(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(${o}, ${l}, 1)));\n        ${vp(n)}\n      }\n    `;const p=n.shapeInfo.texShape,g=p[0],y=p[1],b=n.shapeInfo.flatOffset;if(y===o&&null==b)return t?`\n      float ${s}(int row, int col, int depth) {\n        int stride1 = ${r}Shape[2];\n        float texR = float(row);\n        float texC = dot(vec2(col, depth), vec2(stride1, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n        float ${s}(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(${l}, 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(${y}.0, ${g}.0);\n          return sampleTexture(${r}, uv);\n        }\n      `;if(y===l&&null==b)return t?`\n      float ${s}(int row, int col, int depth) {\n        float texR = dot(vec2(row, col), vec2(${r}Shape[1], 1));\n        float texC = float(depth);\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${s}(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(${e[1]}, 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${y}.0, ${g}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `;const _=wh(r);return t?`\n    float ${s}(int row, int col, int depth) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int stride0 = ${r}Shape[1] * ${r}Shape[2];\n      int stride1 = ${r}Shape[2];\n      int index = row * stride0 + col * stride1 + depth + ${_};\n      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);\n      return sampleTexture(${r}, uv);\n    }\n    `:`\n      float ${s}(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${o} + col * ${l} + depth + ${_};\n        vec2 uv = uvFromFlat(${g}, ${y}, index);\n        return sampleTexture(${r}, uv);\n      }\n  `}(n,t);case 4:return function XR(n,t){const e=n.shapeInfo.logicalShape,r=n.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),o=e[3],l=e[2]*o,u=e[1]*l,{newShape:d,keptDims:h}=St(e);if(d.length<e.length){const V=["row","col","depth","depth2"];return`\n      ${yp(bp(n,d),t)}\n      float ${s}(int row, int col, int depth, int depth2) {\n        return ${s}(${_p(V,h)});\n      }\n    `}if(n.shapeInfo.isUniform)return`\n      float ${s}(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4(${u}, ${l}, ${o}, 1)));\n        ${vp(n)}\n      }\n    `;const p=n.shapeInfo.flatOffset,g=n.shapeInfo.texShape,y=g[0],b=g[1],_=`int stride2 = ${r}Shape[3];`,I=`int stride1 = ${r}Shape[2] * stride2;`,S=`int stride0 = ${r}Shape[1] * stride1;`;if(b===u&&null==p)return t?`\n      float ${s}(int row, int col, int depth, int depth2) {\n        ${_}\n        ${I}\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(stride1, stride2, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n      float ${s}(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(${l}, ${o}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${b}.0, ${y}.0);\n        return sampleTexture(${r}, uv);\n      }\n    `;if(b===o&&null==p)return t?`\n      float ${s}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${r}Shape[1] * ${r}Shape[2], ${r}Shape[2], 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n      float ${s}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${e[1]*e[2]}, ${e[2]}, 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${b}.0, ${y}.0);\n        return sampleTexture(${r}, uv);\n      }\n    `;const T=wh(r);return t?`\n    float ${s}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      ${_}\n      ${I}\n      ${S}\n      int index = row * stride0 + col * stride1 +\n          depth * stride2 + depth2;\n      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index + ${T});\n      return sampleTexture(${r}, uv);\n    }\n  `:`\n    float ${s}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${u} + col * ${l} +\n          depth * ${o} + depth2;\n      vec2 uv = uvFromFlat(${y}, ${b}, index + ${T});\n      return sampleTexture(${r}, uv);\n    }\n  `}(n,t);case 5:return function YR(n){const t=n.shapeInfo.logicalShape,e=n.name,r="get"+e.charAt(0).toUpperCase()+e.slice(1),s=t[4],o=t[3]*s,l=t[2]*o,u=t[1]*l,{newShape:d,keptDims:h}=St(t);if(d.length<t.length){const S=["row","col","depth","depth2","depth3"];return`\n      ${yp(bp(n,d))}\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        return ${r}(${_p(S,h)});\n      }\n    `}if(n.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${u}, ${l}, ${o}, ${s})) +\n          depth3;\n        ${vp(n)}\n      }\n    `;const p=n.shapeInfo.flatOffset,g=n.shapeInfo.texShape,y=g[0],b=g[1];if(b===u&&null==p)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4(${l}, ${o}, ${s}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${b}.0, ${y}.0);\n        return sampleTexture(${e}, uv);\n      }\n    `;if(b===s&&null==p)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${t[1]*t[2]*t[3]},\n               ${t[2]*t[3]}, ${t[3]}, 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${b}.0, ${y}.0);\n        return sampleTexture(${e}, uv);\n      }\n    `;return`\n    float ${r}(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${u} + col * ${l} + depth * ${o} +\n          depth2 * ${s} + depth3 + ${wh(e)};\n      vec2 uv = uvFromFlat(${y}, ${b}, index);\n      return sampleTexture(${e}, uv);\n    }\n  `}(n);case 6:return function ZR(n){const t=n.shapeInfo.logicalShape,e=n.name,r="get"+e.charAt(0).toUpperCase()+e.slice(1),{newShape:s,keptDims:o}=St(t);if(s.length<t.length){const T=["row","col","depth","depth2","depth3","depth4"];return`\n      ${yp(bp(n,s))}\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return ${r}(${_p(T,o)});\n      }\n    `}const l=t[5],u=t[4]*l,d=t[3]*u,h=t[2]*d,p=t[1]*h;if(n.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4(${p}, ${h}, ${d}, ${u})) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(${l}, 1)));\n        ${vp(n)}\n      }\n    `;const g=n.shapeInfo.flatOffset,y=n.shapeInfo.texShape,b=y[0],_=y[1];if(_===p&&null==g)return`\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4(${h}, ${d}, ${u}, ${l})) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${_}.0, ${b}.0);\n        return sampleTexture(${e}, uv);\n      }\n    `;if(_===l&&null==g)return`\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4(${t[1]*t[2]*t[3]*t[4]},\n               ${t[2]*t[3]*t[4]},\n               ${t[3]*t[4]},\n               ${t[4]})) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${_}.0, ${b}.0);\n        return sampleTexture(${e}, uv);\n      }\n    `;return`\n    float ${r}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${p} + col * ${h} + depth * ${d} +\n          depth2 * ${u} + depth3 * ${l} + depth4 + ${wh(e)};\n      vec2 uv = uvFromFlat(${b}, ${_}, index);\n      return sampleTexture(${e}, uv);\n    }\n  `}(n);default:throw new Error(`${e.length}-D input sampling is not yet supported`)}}function wT(n,t){switch(n.shapeInfo.logicalShape.length){case 0:return function VR(n){const t=n.name;return`\n    vec4 ${"get"+t.charAt(0).toUpperCase()+t.slice(1)}() {\n      return ${Ss().texture2D}(${t}, halfCR);\n    }\n  `}(n);case 1:return function zR(n,t){const e=n.name,r="get"+e.charAt(0).toUpperCase()+e.slice(1),s=n.shapeInfo.texShape,o=Ss();if(t)return`\n    vec4 ${r}(int index) {\n      ivec2 packedTexShape = ivec2(ceil(float(${e}TexShape[0]) / 2.0), ceil(float(${e}TexShape[1]) / 2.0));\n      vec2 uv = packedUVfrom1D(\n        packedTexShape[0], packedTexShape[1], index);\n      return ${o.texture2D}(${e}, uv);\n    }\n  `;const l=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];return`\n    vec4 ${r}(int index) {\n      vec2 uv = packedUVfrom1D(\n        ${l[0]}, ${l[1]}, index);\n      return ${o.texture2D}(${e}, uv);\n    }\n  `}(n,t);case 2:return function WR(n,t){const e=n.shapeInfo.logicalShape,r=n.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),o=n.shapeInfo.texShape,l=o[0],u=o[1],d=Ss();if(null!=o&&un(e,o))return t?`\n      vec4 ${s}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n\n        return ${d.texture2D}(${r}, uv);\n      }\n    `:`\n      vec4 ${s}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${u}.0, ${l}.0);\n\n        return ${d.texture2D}(${r}, uv);\n      }\n    `;if(t)return`\n    vec4 ${s}(int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${r}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);\n      return ${d.texture2D}(${r}, uv);\n    }\n  `;const h=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)];return`\n    vec4 ${s}(int row, int col) {\n      vec2 uv = packedUVfrom2D(${Math.ceil(e[1]/2)}, ${h[0]}, ${h[1]}, row, col);\n      return ${d.texture2D}(${r}, uv);\n    }\n  `}(n,t);case 3:return function GR(n,t){const e=n.shapeInfo.logicalShape,r=n.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),o=n.shapeInfo.texShape,l=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)];if(1===e[0]){const b=[1,2],I=["b","row","col"];return`\n        ${wT(bp(n,e.slice(1)),t)}\n        vec4 ${s}(int b, int row, int col) {\n          return ${s}(${_p(I,b)});\n        }\n      `}const u=Ss();if(t)return`\n    vec4 ${s}(int b, int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${r}Shape[2]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${r}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom3D(\n        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);\n      return ${u.texture2D}(${r}, uv);\n    }\n  `;const d=l[0],h=l[1],p=Math.ceil(e[2]/2);return`\n    vec4 ${s}(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ${d}, ${h}, ${p*Math.ceil(e[1]/2)}, ${p}, b, row, col);\n      return ${u.texture2D}(${r}, uv);\n    }\n  `}(n,t);default:return function qR(n,t){const e=n.name,r="get"+e.charAt(0).toUpperCase()+e.slice(1),s=Ss();if(t)return`\n    vec4 ${r}(int b2, int b, int row, int col) {\n      int valuesPerRow = int(ceil(float(${e}Shape[3]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${e}Shape[2]) / 2.0));\n      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);\n      texelsInBatch *= ${e}Shape[1];\n      index = b2 * texelsInBatch + index;\n      ivec2 packedTexShape = ivec2(ceil(float(${e}TexShape[0]) / 2.0), ceil(float(${e}TexShape[1]) / 2.0));\n      int texR = index / packedTexShape[1];\n      int texC = index - texR * packedTexShape[1];\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${s.texture2D}(${e}, uv);\n    }\n  `;const o=n.shapeInfo.logicalShape,l=o.length,u=n.shapeInfo.texShape,d=[Math.ceil(u[0]/2),Math.ceil(u[1]/2)],h=d[0],p=d[1],g=Math.ceil(o[l-1]/2);let y=g*Math.ceil(o[l-2]/2),b="int b, int row, int col",_=`b * ${y} + (row / 2) * ${g} + (col / 2)`;for(let I=2;I<l-1;I++)b=`int b${I}, `+b,y*=o[l-I-1],_=`b${I} * ${y} + `+_;return`\n    vec4 ${r}(${b}) {\n      int index = ${_};\n      int texR = index / ${p};\n      int texC = index - texR * ${p};\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${p}, ${h});\n      return ${s.texture2D}(${e}, uv);\n    }\n  `}(n,t)}}const IR="\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",DR="\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",TR="\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",NR="\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n";function wh(n){return`offset${n}`}function vp(n){const t=n.name,e=Ee(n.shapeInfo.logicalShape);return e<2?`return ${t};`:`\n    for (int i = 0; i < ${e}; i++) {\n      if (i == index) {\n        return ${t}[i];\n      }\n    }\n  `}function ir(n){if(n<=1)return"int";if(2===n)return"ivec2";if(3===n)return"ivec3";if(4===n)return"ivec4";if(5===n)return"ivec5";if(6===n)return"ivec6";throw Error(`GPU for rank ${n} is not yet supported`)}function AE(n,t,e){const{newShape:r,keptDims:s}=St(t),o=t.length,l=n&&3===o&&1===t[0],u=l?t.slice(1):r,d=!n&&o>1&&!un(t,e)&&r.length<o||l;return{useSqueezeShape:d,uniformShape:d?u:t,keptDims:s}}function bp(n,t){const e=JSON.parse(JSON.stringify(n));return e.shapeInfo.logicalShape=t,e}function _p(n,t){return t.map(e=>n[e]).join(", ")}function ST(n,t,e){const r=[],s=[];let o,l,u,d=null,h=null;h=n.getUniformLocation(e,"NAN",!1),1===Q().getNumber("WEBGL_VERSION")&&(d=n.getUniformLocation(e,"INFINITY",!1));const p=!1;for(const g of t.variableNames){const y={name:g,uniform:n.getUniformLocation(e,g,p),offset:n.getUniformLocation(e,`offset${g}`,p)};t.enableShapeUniforms&&(y.shape=n.getUniformLocation(e,`${g}Shape`,p),y.texShape=n.getUniformLocation(e,`${g}TexShape`,p)),r.push(y)}if(t.enableShapeUniforms&&(o=n.getUniformLocation(e,"outShape",p),u=n.getUniformLocation(e,"outShapeStrides",p),l=n.getUniformLocation(e,"outTexShape",p)),t.customUniforms)for(const g of t.customUniforms)s.push(n.getUniformLocation(e,g.name,p));return{variablesLocations:r,customUniformLocations:s,infLoc:d,nanLoc:h,outShapeLocation:o,outShapeStridesLocation:u,outTexShapeLocation:l}}function ET(n,t){if(n.length!==t.length)throw Error(`Binary was compiled with ${n.length} inputs, but was executed with ${t.length} inputs`);n.forEach((e,r)=>{const s=e.logicalShape,o=t[r],l=o.shape;if(!un(s,l))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${s} and ${l} must match`);if(e.isUniform&&o.isUniform)return;const u=e.texShape,d=o.isUniform?null:o.texData.texShape;if(!un(u,d))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${u} and ${d} must match`)})}function to(n){return Q().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&n<=4}class r2{constructor(t){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=yh.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const e=Ss();this.outputShape=t,this.enableShapeUniforms=to(this.outputShape.length),this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${this.enableShapeUniforms?Z_(["r","c","d"],t):xh(["r","c","d"],t)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        ${e.output} = result;\n      }\n    `}}class s2{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=yh.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const e=Ss();this.outputShape=t,this.enableShapeUniforms=to(this.outputShape.length),this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${this.enableShapeUniforms?Z_(["r","c","d"],t):xh(["r","c","d"],t)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        ${e.output} = result;\n      }\n    `}}class o2{constructor(t){this.variableNames=["A"],this.outTexUsage=eo.DOWNLOAD;const e=Ss();this.outputShape=t,this.userCode=`\n      ${_T}\n\n      void main() {\n        float x = getAAtOutCoords();\n        ${e.output} = encode_float(x);\n      }\n    `}}class a2{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=eo.DOWNLOAD;const e=Ss();this.outputShape=t,this.userCode=`\n      ${_T}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        ${e.output} = encode_float(x);\n      }\n    `}}const l2={R:0,G:1,B:2,A:3};class IT{constructor(t,e=!1,r="RGBA"){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const s=Ss();this.outputShape=t,this.enableShapeUniforms=to(this.outputShape.length);let o="result";e&&(o="floor(result * 255. + 0.5)");let l="";for(let u=0;u<r.length;u++)l+=`\n          if(offset == ${u}) {\n            result = values[${l2[r[u]]}];\n          }`;this.userCode=`\n      ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":NE(t)}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int flatIndex = getFlatIndex(coords);\n        float result = 0.;\n        int offset = imod(flatIndex, ${r.length});\n\n        flatIndex = idiv(flatIndex, ${r.length}, 1.);\n\n        int r = flatIndex / texShape[1];\n        if (r < texShape[0]) {\n          int c = imod(flatIndex, texShape[1]);\n          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n          vec4 values = ${s.texture2D}(A, uv);\n          ${l}\n        }\n        ${s.output} = vec4(${o}, 0., 0., 0.);\n      }\n    `}}class c2{constructor(t,e=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const r=Ss();this.outputShape=t,this.enableShapeUniforms=to(this.outputShape.length);let s="",o="result";e&&(o="floor(result * 255. + 0.5)");for(let l=0;l<=1;l++)for(let u=0;u<=1;u++){const d=2*l+u;s+=`\n          localCoords = coords;\n          if(localCoords[2] + ${u} < ${this.enableShapeUniforms?"outShape[2]":`${t[2]}`}) {\n          localCoords[2] += ${u};\n          if (localCoords[1] + ${l} < ${this.enableShapeUniforms?"outShape[1]":`${t[1]}`}) {\n            localCoords[1] += ${l};\n\n            flatIndex = getFlatIndex(localCoords);\n            offset = imod(flatIndex, 4);\n\n            flatIndex = idiv(flatIndex, 4, 1.);\n\n            int r = flatIndex / texShape[1];\n            int c = imod(flatIndex, texShape[1]);\n            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n            values = ${r.texture2D}(A, uv);\n\n            if (offset == 0) {\n              result[${d}] = values[0];\n            } else if (offset == 1) {\n              result[${d}] = values[1];\n            } else if (offset == 2) {\n              result[${d}] = values[2];\n            } else {\n              result[${d}] = values[3];\n            }\n          }\n        }\n        `}this.userCode=`\n        ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":NE(t)}\n\n        void main() {\n          ivec3 coords = getOutputCoords();\n\n          vec4 result = vec4(0.);\n          int flatIndex, r, c, offset;\n          ivec3 localCoords;\n          vec2 uv;\n          vec4 values;\n\n          ${s}\n\n          ${r.output} = ${o};\n        }\n    `}}function Ry(n,t,e,r,s,o){!function yT(n,t){const e=Q().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(n<=0||t<=0)throw new Error(`Requested texture size [${n}x${t}] is invalid.`);if(n>e||t>e)throw new Error(`Requested texture size [${n}x${t}] greater than WebGL maximum on this browser / GPU [${e}x${e}].`)}(t,e);const l=function gT(n){return R(n,()=>n.createTexture(),"Unable to create WebGLTexture.")}(n),u=n.TEXTURE_2D;return At(n,()=>n.bindTexture(u,l)),At(n,()=>n.texParameteri(u,n.TEXTURE_WRAP_S,n.CLAMP_TO_EDGE)),At(n,()=>n.texParameteri(u,n.TEXTURE_WRAP_T,n.CLAMP_TO_EDGE)),At(n,()=>n.texParameteri(u,n.TEXTURE_MIN_FILTER,n.NEAREST)),At(n,()=>n.texParameteri(u,n.TEXTURE_MAG_FILTER,n.NEAREST)),1===Q().getNumber("WEBGL_VERSION")?At(n,()=>n.texImage2D(u,0,r,t,e,0,s,o,null)):At(n,()=>n.texStorage2D(u,1,r,t,e)),At(n,()=>n.bindTexture(n.TEXTURE_2D,null)),{texture:l,texShape:[e,t]}}function DT(n){return n.internalFormatFloat}function TT(n){return n.internalFormatHalfFloat}function NT(n){return n.downloadTextureFormat}function kT(n){return n.internalFormatPackedFloat}function AT(n){return n.internalFormatPackedHalfFloat}class RE{constructor(t){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];const e=Q().getNumber("WEBGL_VERSION");if(null!=t?(this.gl=t,function pp(n,t){Kl[n]=t}(e,t)):this.gl=ha(e),t=this.gl,2===Q().getNumber("WEBGL_VERSION")){const o=t;this.createVertexArray=()=>At(o,()=>o.createVertexArray()),this.bindVertexArray=l=>At(o,()=>o.bindVertexArray(l)),this.deleteVertexArray=l=>At(o,()=>o.deleteVertexArray(l)),this.getVertexArray=()=>At(o,()=>o.getParameter(o.VERTEX_ARRAY_BINDING))}else if(null!=t){const o=t.getExtension("OES_vertex_array_object");if(null==o)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>At(t,()=>o.createVertexArrayOES()),this.bindVertexArray=l=>At(t,()=>o.bindVertexArrayOES(l)),this.deleteVertexArray=l=>At(t,()=>o.deleteVertexArrayOES(l)),this.getVertexArray=()=>At(t,()=>t.getParameter(o.VERTEX_ARRAY_BINDING_OES))}let r="WEBGL_color_buffer_float";const s="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),1===Q().getNumber("WEBGL_VERSION")){const l="OES_texture_half_float";if(this.textureFloatExtension=Dy(this.gl,"OES_texture_float"),Cs(this.gl,l))this.textureHalfFloatExtension=Dy(this.gl,l);else if(Q().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(r),Cs(this.gl,s))this.colorBufferHalfFloatExtension=Dy(this.gl,s);else if(Q().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(r="EXT_color_buffer_float",Cs(this.gl,r))this.colorBufferFloatExtension=this.gl.getExtension(r);else{if(!Cs(this.gl,s))throw new Error("GL context does not support color renderable floats");this.colorBufferHalfFloatExtension=this.gl.getExtension(s)}this.vertexBuffer=function d2(n){return function fT(n,t){const e=R(n,()=>n.createBuffer(),"Unable to create WebGLBuffer");return At(n,()=>n.bindBuffer(n.ARRAY_BUFFER,e)),At(n,()=>n.bufferData(n.ARRAY_BUFFER,t,n.STATIC_DRAW)),e}(n,new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]))}(this.gl),this.indexBuffer=function h2(n){return function pT(n,t){const e=R(n,()=>n.createBuffer(),"Unable to create WebGLBuffer");return At(n,()=>n.bindBuffer(n.ELEMENT_ARRAY_BUFFER,e)),At(n,()=>n.bufferData(n.ELEMENT_ARRAY_BUFFER,t,n.STATIC_DRAW)),e}(n,new Uint16Array([0,1,2,2,1,3]))}(this.gl),this.framebuffer=function vT(n){return R(n,()=>n.createFramebuffer(),"Unable to create WebGLFramebuffer.")}(this.gl),this.textureConfig=mp(this.gl,this.textureHalfFloatExtension)}get debug(){return Q().getBool("DEBUG")}dispose(){if(this.disposed)return;null!=this.program&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),null!=this.outputTexture&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const t=this.gl;At(t,()=>t.finish()),At(t,()=>t.bindFramebuffer(t.FRAMEBUFFER,null)),At(t,()=>t.deleteFramebuffer(this.framebuffer)),At(t,()=>t.bindBuffer(t.ARRAY_BUFFER,null)),At(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,null)),At(t,()=>t.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(t,e){return this.throwIfDisposed(),function f2(n,t,e,r){const[s,o]=vh(t,e);return Ry(n,s,o,DT(r),r.textureFormatFloat,n.FLOAT)}(this.gl,t,e,this.textureConfig)}createFloat16MatrixTexture(t,e){return this.throwIfDisposed(),function p2(n,t,e,r){const[s,o]=vh(t,e);return Ry(n,s,o,TT(r),r.textureFormatFloat,r.textureTypeHalfFloat)}(this.gl,t,e,this.textureConfig)}createUnsignedBytesMatrixTexture(t,e){return this.throwIfDisposed(),function m2(n,t,e,r){const[s,o]=vh(t,e);return Ry(n,s,o,NT(r),n.RGBA,n.UNSIGNED_BYTE)}(this.gl,t,e,this.textureConfig)}uploadPixelDataToTexture(t,e){this.throwIfDisposed(),function _2(n,t,e){At(n,()=>n.bindTexture(n.TEXTURE_2D,t)),e.data instanceof Uint8Array?2===Q().getNumber("WEBGL_VERSION")?At(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,e.width,e.height,n.RGBA,n.UNSIGNED_BYTE,e.data)):At(n,()=>n.texImage2D(n.TEXTURE_2D,0,n.RGBA,e.width,e.height,0,n.RGBA,n.UNSIGNED_BYTE,e.data)):2===Q().getNumber("WEBGL_VERSION")?At(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,n.RGBA,n.UNSIGNED_BYTE,e)):At(n,()=>n.texImage2D(n.TEXTURE_2D,0,n.RGBA,n.RGBA,n.UNSIGNED_BYTE,e)),At(n,()=>n.bindTexture(n.TEXTURE_2D,null))}(this.gl,t,e)}uploadDenseMatrixToTexture(t,e,r,s){this.throwIfDisposed(),function b2(n,t,e,r,s,o){let l,u,d;At(n,()=>n.bindTexture(n.TEXTURE_2D,t)),s instanceof Uint8Array?(l=new Uint8Array(e*r*4),u=n.UNSIGNED_BYTE,d=n.RGBA):(l=new Float32Array(e*r*4),u=n.FLOAT,d=o.internalFormatPackedFloat),l.set(s),2===Q().getNumber("WEBGL_VERSION")?At(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,e,r,n.RGBA,u,l)):At(n,()=>n.texImage2D(n.TEXTURE_2D,0,d,e,r,0,n.RGBA,u,l)),At(n,()=>n.bindTexture(n.TEXTURE_2D,null))}(this.gl,t,e,r,s,this.textureConfig)}createFloat16PackedMatrixTexture(t,e){return this.throwIfDisposed(),function y2(n,t,e,r){const[s,o]=td(t,e);return Ry(n,s,o,AT(r),n.RGBA,r.textureTypeHalfFloat)}(this.gl,t,e,this.textureConfig)}createPackedMatrixTexture(t,e){return this.throwIfDisposed(),function g2(n,t,e,r){const[s,o]=td(t,e);return Ry(n,s,o,kT(r),n.RGBA,n.FLOAT)}(this.gl,t,e,this.textureConfig)}deleteMatrixTexture(t){this.throwIfDisposed(),this.outputTexture===t&&(v(this.gl,this.framebuffer),this.outputTexture=null),At(this.gl,()=>this.gl.deleteTexture(t))}downloadByteEncodedFloatMatrixFromOutputTexture(t,e,r){return this.downloadMatrixDriver(t,()=>function C2(n,t,e,r){const[s,o]=vh(t,e),u=new Uint8Array(function _E(n,t){return n*t}(t*e,4));return At(n,()=>n.readPixels(0,0,s,o,r.downloadTextureFormat,n.UNSIGNED_BYTE,u)),new Float32Array(u.buffer)}(this.gl,e,r,this.textureConfig))}downloadPackedMatrixFromBuffer(t,e,r,s,o,l){return function S2(n,t,e,r,s,o,l,u){const d=n,h=new Float32Array(function CE(n,t){const[e,r]=td(n,t);return e*r*4}(o,l));return d.bindBuffer(d.PIXEL_PACK_BUFFER,t),d.getBufferSubData(d.PIXEL_PACK_BUFFER,0,h),d.bindBuffer(d.PIXEL_PACK_BUFFER,null),h}(this.gl,t,0,0,0,o,l)}downloadFloat32MatrixFromBuffer(t,e){return function w2(n,t,e){const r=n,s=new Float32Array(e);return r.bindBuffer(r.PIXEL_PACK_BUFFER,t),r.getBufferSubData(r.PIXEL_PACK_BUFFER,0,s),r.bindBuffer(r.PIXEL_PACK_BUFFER,null),s}(this.gl,t,e)}createBufferFromTexture(t,e,r){this.bindTextureToFrameBuffer(t);const s=function x2(n,t,e,r){const s=n.createBuffer();At(n,()=>n.bindBuffer(n.PIXEL_PACK_BUFFER,s));const u=16*t*e;return At(n,()=>n.bufferData(n.PIXEL_PACK_BUFFER,u,n.STREAM_READ)),At(n,()=>n.readPixels(0,0,e,t,n.RGBA,n.FLOAT,0)),At(n,()=>n.bindBuffer(n.PIXEL_PACK_BUFFER,null)),s}(this.gl,e,r);return this.unbindTextureToFrameBuffer(),s}createAndWaitForFence(){const t=this.createFence(this.gl);return this.pollFence(t)}createFence(t){let e,r;if(Q().getBool("WEBGL_FENCE_API_ENABLED")){const s=t,o=s.fenceSync(s.SYNC_GPU_COMMANDS_COMPLETE,0);t.flush(),r=()=>{const l=s.clientWaitSync(o,0,0);return l===s.ALREADY_SIGNALED||l===s.CONDITION_SATISFIED},e=o}else Q().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(e=this.beginQuery(),this.endQuery(),r=()=>this.isQueryAvailable(e,Q().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):r=()=>!0;return{query:e,isFencePassed:r}}downloadMatrixFromPackedTexture(t,e,r){return this.downloadMatrixDriver(t,()=>function E2(n,t,e){const r=new Float32Array(t*e*4);return At(n,()=>n.readPixels(0,0,e,t,n.RGBA,n.FLOAT,r)),r}(this.gl,e,r))}createProgram(t){this.throwIfDisposed();const e=this.gl;null==this.vertexShader&&(this.vertexShader=function u2(n){const t=Ss();return function uT(n,t){const e=R(n,()=>n.createShader(n.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(At(n,()=>n.shaderSource(e,t)),At(n,()=>n.compileShader(e)),!1===n.getShaderParameter(e,n.COMPILE_STATUS))throw console.log(n.getShaderInfoLog(e)),new Error("Failed to compile vertex shader.");return e}(n,`${t.version}\n    precision highp float;\n    ${t.attribute} vec3 clipSpacePos;\n    ${t.attribute} vec2 uv;\n    ${t.varyingVs} vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }`)}(e));const r=function dT(n){return R(n,()=>n.createProgram(),"Unable to create WebGLProgram.")}(e);At(e,()=>e.attachShader(r,this.vertexShader)),At(e,()=>e.attachShader(r,t)),function hT(n,t){if(At(n,()=>n.linkProgram(t)),!Q().get("ENGINE_COMPILE_ONLY")&&!1===n.getProgramParameter(t,n.LINK_STATUS))throw console.log(n.getProgramInfoLog(t)),new Error("Failed to link vertex and fragment shaders.")}(e,r);const s=Object.assign(r,{vao:this.createVertexArray()});return this.debug&&Y_(e,s),s}buildVao(t){this.setProgram(t),this.bindVertexArray(t.vao);const e=this.gl;At(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,this.indexBuffer)),function v2(n,t,e){At(n,()=>n.bindBuffer(n.ARRAY_BUFFER,e)),TE(n,t,"clipSpacePos",e,3,20,0)&&TE(n,t,"uv",e,2,20,12)}(e,t,this.vertexBuffer)}deleteProgram(t){this.throwIfDisposed(),t===this.program&&(this.program=null),null!=t&&(At(this.gl,()=>this.gl.deleteProgram(t)),this.deleteVertexArray(t.vao))}setProgram(t){this.throwIfDisposed(),this.program=t,null!=this.program&&this.debug&&Y_(this.gl,this.program),At(this.gl,()=>this.gl.useProgram(t))}getUniformLocation(t,e,r=!0){return this.throwIfDisposed(),r?function i(n,t,e){return R(n,()=>n.getUniformLocation(t,e),'uniform "'+e+'" not present in program.')}(this.gl,t,e):function a(n,t,e){return n.getUniformLocation(t,e)}(this.gl,t,e)}getAttributeLocation(t,e){return this.throwIfDisposed(),At(this.gl,()=>this.gl.getAttribLocation(t,e))}getUniformLocationNoThrow(t,e){return this.throwIfDisposed(),this.gl.getUniformLocation(t,e)}setInputMatrixTexture(t,e,r){this.throwIfDisposed(),this.throwIfNoProgram(),c(this.gl,t,e,r)}setOutputMatrixTexture(t,e,r){this.setOutputMatrixTextureDriver(t,r,e)}setOutputPackedMatrixTexture(t,e,r){this.throwIfDisposed();const[s,o]=td(e,r);this.setOutputMatrixTextureDriver(t,s,o)}setOutputMatrixWriteRegion(t,e,r,s){this.setOutputMatrixWriteRegionDriver(r,t,s,e)}setOutputPackedMatrixWriteRegion(t,e,r,s){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){null!=this.program&&Y_(this.gl,this.program),w(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const t=this.gl;if(this.debug){const e=this.getVertexArray();console.assert(e===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}At(t,()=>t.drawElements(t.TRIANGLES,6,t.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),At(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return null==this.disjointQueryTimerExtension&&(this.disjointQueryTimerExtension=Dy(this.gl,2===Q().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(2===Q().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const r=this.gl,s=this.getQueryTimerExtensionWebGL2(),o=r.createQuery();return r.beginQuery(s.TIME_ELAPSED_EXT,o),o}const t=this.getQueryTimerExtensionWebGL1(),e=t.createQueryEXT();return t.beginQueryEXT(t.TIME_ELAPSED_EXT,e),e}endQuery(){if(2===Q().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const e=this.gl,r=this.getQueryTimerExtensionWebGL2();return void e.endQuery(r.TIME_ELAPSED_EXT)}const t=this.getQueryTimerExtensionWebGL1();t.endQueryEXT(t.TIME_ELAPSED_EXT)}waitForQueryAndGetTime(t){var e=this;return xe(function*(){return yield $r(()=>e.disposed||e.isQueryAvailable(t,Q().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),e.getQueryTime(t,Q().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))})()}getQueryTime(t,e){if(0===e)return null;if(2===e){const r=this.gl;return r.getQueryParameter(t,r.QUERY_RESULT)/1e6}{const r=this.getQueryTimerExtensionWebGL1();return r.getQueryObjectEXT(t,r.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(t,e){if(0===e)return!0;if(2===e){const r=this.gl,s=this.getQueryTimerExtensionWebGL2(),o=r.getQueryParameter(t,r.QUERY_RESULT_AVAILABLE);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(s.GPU_DISJOINT_EXT)),o&&!this.disjoint}{const r=this.getQueryTimerExtensionWebGL1(),s=r.getQueryObjectEXT(t,r.QUERY_RESULT_AVAILABLE_EXT);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(r.GPU_DISJOINT_EXT)),s&&!this.disjoint}}pollFence(t){return new Promise(e=>{this.addItemToPoll(()=>t.isFencePassed(),()=>e())})}pollItems(){const t=function I2(n){let t=0;for(;t<n.length&&n[t]();++t);return t-1}(this.itemsToPoll.map(e=>e.isDoneFn));for(let e=0;e<=t;++e){const{resolveFn:r}=this.itemsToPoll[e];r()}this.itemsToPoll=this.itemsToPoll.slice(t+1)}addItemToPoll(t,e){if(this.itemsToPoll.push({isDoneFn:t,resolveFn:e}),this.itemsToPoll.length>1)return;let r;"setTimeoutCustom"in Q().platform&&(r=Q().platform.setTimeoutCustom.bind(Q().platform)),$r(()=>(this.pollItems(),0===this.itemsToPoll.length),()=>0,null,r)}bindTextureToFrameBuffer(t){this.throwIfDisposed(),m(this.gl,t,this.framebuffer),this.debug&&w(this.gl)}unbindTextureToFrameBuffer(){null!=this.outputTexture?(m(this.gl,this.outputTexture,this.framebuffer),this.debug&&w(this.gl)):v(this.gl,this.framebuffer)}downloadMatrixDriver(t,e){this.bindTextureToFrameBuffer(t);const r=e();return this.unbindTextureToFrameBuffer(),r}setOutputMatrixTextureDriver(t,e,r){this.throwIfDisposed();const s=this.gl;m(s,t,this.framebuffer),this.debug&&w(s),this.outputTexture=t,At(s,()=>s.viewport(0,0,e,r)),At(s,()=>s.scissor(0,0,e,r))}setOutputMatrixWriteRegionDriver(t,e,r,s){this.throwIfDisposed(),At(this.gl,()=>this.gl.scissor(t,e,r,s))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(null==this.program)throw new Error("No GPU program is currently set.")}}function Xt(n,t){Array.isArray(n)||(n=[n]),n.forEach(e=>{null!=e&&G("complex64"!==e.dtype,()=>`${t} does not support complex64 tensors in the CPU backend.`)})}function RT(n){const t=new Float32Array(n.length);for(let e=0;e<n.length;++e)t[e]=Math.abs(n[e]);return t}const D2={kernelName:"Abs",backendName:"cpu",kernelFunc:n=>{const{x:t}=n.inputs,e=n.backend;Xt(t,"abs");let r=new Float32Array(Ee(t.shape));return r=RT(e.data.get(t.dataId).values),e.makeOutput(r,t.shape,t.dtype)}};function Zr(n){return(t,e,r,s,o)=>{const l=Nn(t,e),u=l.length,d=Wt(l),p=Rt(o,Ee(l)),g=t.length,y=e.length,b=Wt(t),_=Wt(e),I=Ec(t,l),S=Ec(e,l);if(I.length+S.length===0)for(let T=0;T<p.length;++T)p[T]=n(r[T%r.length],s[T%s.length]);else for(let T=0;T<p.length;++T){const O=Jr(T,u,d),V=O.slice(-g);I.forEach(se=>V[se]=0);const U=Qr(V,g,b),j=O.slice(-y);S.forEach(se=>j[se]=0);const te=Qr(j,y,_);p[T]=n(r[U],s[te])}return[p,l]}}function ci(n){const{inputs:t,backend:e}=n,{real:r,imag:s}=t,o=e.data.get(r.dataId).values,l=e.data.get(s.dataId).values,u=e.makeTensorInfo(r.shape,"complex64");return e.data.get(u.dataId).complexTensorInfos={real:e.makeTensorInfo(r.shape,"float32",o),imag:e.makeTensorInfo(s.shape,"float32",l)},u}const T2={kernelName:So,backendName:"cpu",kernelFunc:ci};function J_(n,t,e="float32"){if("complex64"===e)return ci({inputs:{real:J_(n,t,"float32"),imag:J_(n,t,"float32")},backend:n});const r=er(Ee(t),e);return n.makeTensorInfo(t,e,r)}function ql(n){const{inputs:t,backend:e}=n,{x:r}=t;return e.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}const N2={kernelName:Vi,backendName:"cpu",kernelFunc:ql};function Ch(n){const{inputs:t,backend:e}=n,{input:r}=t,s=e.data.get(r.dataId).complexTensorInfos.real,o=e.data.get(s.dataId).values;return e.makeTensorInfo(s.shape,s.dtype,o)}const k2={kernelName:lu,backendName:"cpu",kernelFunc:Ch};function MT(n,t,e,r){if("int32"===r)return[t,"int32",Int32Array.from(n)];if("bool"===r){const s=xi([0],e),[o,l]=Zr((u,d)=>u!==d?1:0)(t,[],n,s,"bool");return[l,"bool",o]}throw new Error(`Error in Cast: failed to cast ${e} to ${r}`)}function nd(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{dtype:o}=r;if("complex64"===o){if("complex64"===s.dtype)return ql({inputs:{x:s},backend:e});const p=J_(e,s.shape,s.dtype),g=nd({inputs:{x:s},backend:e,attrs:{dtype:"float32"}}),y=ci({inputs:{real:g,imag:p},backend:e});return e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(g),y}if("complex64"===s.dtype){const p=Ch({inputs:{input:s},backend:e}),g=nd({inputs:{x:p},backend:e,attrs:{dtype:o}});return e.disposeIntermediateTensorInfo(p),g}if(!An(s.dtype,o)){const p=ql({inputs:{x:s},backend:e});return{dataId:p.dataId,shape:p.shape,dtype:o}}const l=e.data.get(s.dataId).values,[u,d,h]=MT(l,s.shape,s.dtype,o);return e.makeTensorInfo(u,d,h)}const A2={kernelName:fs,backendName:"cpu",kernelFunc:nd};function Es(n,t,e,r){return null==e?({inputs:s,backend:o})=>{const{a:l,b:u}=s,d=o;Xt([l,u],n);const h=d.data.get(l.dataId).values,p=d.data.get(u.dataId).values,g="string"===l.dtype?po(h):h,y="string"===l.dtype?po(p):p,b=r||l.dtype,[_,I]=t(l.shape,u.shape,g,y,b);return d.makeTensorInfo(I,b,_)}:({inputs:s,backend:o})=>{const{a:l,b:u}=s,d=o;if("complex64"===l.dtype||"complex64"===u.dtype){const h=nd({inputs:{x:l},backend:d,attrs:{dtype:"complex64"}}),p=d.data.get(h.dataId),y=p.complexTensorInfos.imag,b=d.data.get(p.complexTensorInfos.real.dataId).values,_=d.data.get(y.dataId).values,I=nd({inputs:{x:u},backend:d,attrs:{dtype:"complex64"}}),S=d.data.get(I.dataId),O=S.complexTensorInfos.imag,V=d.data.get(S.complexTensorInfos.real.dataId).values,U=d.data.get(O.dataId).values,[j,te,se]=e(l.shape,u.shape,b,_,V,U),le=d.makeTensorInfo(se,"float32",j),Ce=d.makeTensorInfo(se,"float32",te),be=ci({inputs:{real:le,imag:Ce},backend:d});return d.disposeIntermediateTensorInfo(h),d.disposeIntermediateTensorInfo(I),d.disposeIntermediateTensorInfo(le),d.disposeIntermediateTensorInfo(Ce),be}{const h=d.data.get(l.dataId).values,p=d.data.get(u.dataId).values,g=r||l.dtype,[y,b]=t(l.shape,u.shape,h,p,g);return d.makeTensorInfo(b,g,y)}}}function ME(n){return(t,e,r,s,o,l)=>{const u=Nn(t,e),d=Ee(u),h=u.length,p=Wt(u),g=Rt("float32",d),y=Rt("float32",d),b=Ec(t,u),_=Ec(e,u),I=Qa(r,s),S=Qa(o,l),T=t.length,O=Wt(t),V=e.length,U=Wt(e);if(b.length+_.length===0)for(let j=0;j<g.length;j++){const te=j%I.length,se=j%S.length,le=n(I[2*te],I[2*te+1],S[2*se],S[2*se+1]);g[j]=le.real,y[j]=le.imag}else for(let j=0;j<g.length;j++){const te=Jr(j,h,p),se=te.slice(-T);b.forEach(He=>se[He]=0);const le=Qr(se,T,O),Ce=te.slice(-V);_.forEach(He=>Ce[He]=0);const be=Qr(Ce,V,U),Me=n(I[2*le],I[2*le+1],S[2*be],S[2*be+1]);g[j]=Me.real,y[j]=Me.imag}return[g,y,u]}}const OT=Zr((n,t)=>n+t),R2=ME((n,t,e,r)=>({real:n+e,imag:t+r})),xp=Es(Rs,OT,R2),M2={kernelName:Rs,backendName:"cpu",kernelFunc:xp};function OE(n,t,e,r,s){const o=Ee(r),l=er(s,e);for(let u=0;u<n.length;u++){const d=n[u];if(d<0)throw new Error("Input x must be non-negative!");d>=s||(l[d]+=o>0?t[u]:1)}return l}function FT(n,t,e,r=!1){const s=n.shape[0],o=n.shape[1],l=gn([s,e],t.dtype);for(let u=0;u<s;u++)for(let d=0;d<o;d++){const h=n.get(u,d);if(h<0)throw new Error("Input x must be non-negative!");h>=e||l.set(r?1:t.size>0?l.get(u,h)+t.get(u,d):l.get(u,h)+1,u,h)}return l}const $T=Zr((n,t)=>n&t),O2=Es($i,$T),F2={kernelName:$i,backendName:"cpu",kernelFunc:O2};function Xl(n){return(t,e,r)=>{const s=Ft(e,t.length);for(let o=0;o<t.length;++o)s[o]=n(t[o],r);return s}}function Qn(n,t,e){return rd(n,Xl(t),e)}function rd(n,t,e){return({inputs:r,attrs:s,backend:o})=>{const{x:l}=r;Xt(l,n);const u=o,d=u.data.get(l.dataId).values;let h;if("string"===l.dtype){if(!Array.isArray(d))throw new Error("String tensor's value was not an instance of Array");h=po(d)}else h=d;const p=e||l.dtype,g=t(h,p,s);return u.makeTensorInfo(l.shape,p,g)}}const PT=Xl(n=>Math.ceil(n)),$2=rd(Os,PT),P2={kernelName:Os,backendName:"cpu",kernelFunc:$2};function LT(n,t,e,r){const s=Ft(e,Ee(t));if(r&&"string"!==e){let o=0;n.forEach(l=>{const u=Ee(l.shape);s.set(l.vals,o),o+=u})}else{let o=0;n.forEach(l=>{const u="string"===e?po(l.vals):l.vals;let d=0;for(let h=0;h<l.shape[0];++h){const p=h*t[1]+o;for(let g=0;g<l.shape[1];++g)s[p+g]=u[d++]}o+=l.shape[1]})}return s}const BT=Zr((n,t)=>n===t?1:0),VT=Es(Pi,BT,null,"bool"),L2={kernelName:Pi,backendName:"cpu",kernelFunc:VT},UT=Xl(n=>Math.exp(n)),zT=rd(Ho,UT,"float32"),B2={kernelName:Ho,backendName:"cpu",kernelFunc:zT},HT=Xl(n=>Math.expm1(n)),V2=rd(wa,HT),U2={kernelName:wa,backendName:"cpu",kernelFunc:V2},WT=Xl(n=>Math.floor(n)),z2=rd(fi,WT),H2={kernelName:fi,backendName:"cpu",kernelFunc:z2},jT=Zr((n,t)=>Math.floor(n/t)),W2=Es(Li,jT,null,"int32"),j2={kernelName:Li,backendName:"cpu",kernelFunc:W2};function GT(n,t,e,r,s,o,l,u,d){const h=gn([r,o],e);for(let p=0;p<r;p++){const g=[];let y=0;for(let b=0;b<s;b++){const _=n[p*s+b];y+=_*l[b],g.push(_)}if(y<0||y>=d/o)throw new Error(`Invalid indices: ${g} does not index into ${u}`);for(let b=0;b<o;b++)h.values[p*o+b]=t.get(...t.indexToLoc(y*o+b))}return h}function KT(n,t,e){const r=gn(e,n.dtype);for(let s=0;s<r.size;++s){const l=r.indexToLoc(s).slice(),h=t.locToIndex([l[0],l[2]]);l[2]=t.values[h];const p=n.locToIndex(l);0<=p&&p<n.values.length&&(r.values[s]=n.values[p])}return r}const qT=Zr((n,t)=>n>t?1:0),G2=Es(cl,qT,null,"bool"),K2={kernelName:cl,backendName:"cpu",kernelFunc:G2},XT=Zr((n,t)=>n>=t?1:0),q2=Es(Bi,XT,null,"bool"),X2={kernelName:Bi,backendName:"cpu",kernelFunc:q2},YT=Zr((n,t)=>n<t?1:0),Y2=Es(eu,YT,null,"bool"),Z2={kernelName:eu,backendName:"cpu",kernelFunc:Y2},ZT=Zr((n,t)=>n<=t?1:0),Q2=Es(jn,ZT,null,"bool"),J2={kernelName:jn,backendName:"cpu",kernelFunc:Q2};function QT(n,t,e){const r=(t-n)/(e-1),s=er(e,"float32");s[0]=n;for(let o=1;o<s.length;o++)s[o]=s[o-1]+r;return s}const JT=Xl(n=>Math.log(n)),eM=rd(dl,JT),tM={kernelName:dl,backendName:"cpu",kernelFunc:eM};function eN(n,t,e,r){const s=Rt(r,Ee(e));for(let o=0;o<s.length;++o){const l=o*t;let u=n[l];for(let d=0;d<t;++d){const h=n[l+d];(Number.isNaN(h)||h>u)&&(u=h)}s[o]=u}return s}const tN=Zr((n,t)=>Math.max(n,t)),nM=Es(Da,tN),rM={kernelName:Da,backendName:"cpu",kernelFunc:nM},nN=Zr((n,t)=>Math.min(n,t)),sM=Es(Hi,nN),oM={kernelName:Hi,backendName:"cpu",kernelFunc:sM},FE=Zr((n,t)=>n*t),iM=ME((n,t,e,r)=>({real:n*e-t*r,imag:n*r+t*e})),ex=Es(pl,FE,iM),aM={kernelName:pl,backendName:"cpu",kernelFunc:ex};function rN(n,t,e){const r=_i(-1,e);return FE([],t,r,n,e)}const cM={kernelName:"Neg",backendName:"cpu",kernelFunc:function lM(n){const{inputs:t,backend:e}=n,{x:r}=t;Xt(r,"neg");const s=e.data.get(r.dataId).values,[o,l]=rN(s,r.shape,r.dtype);return e.makeTensorInfo(l,r.dtype,o)}},sN=Zr((n,t)=>n!==t?1:0),uM=Es(ur,sN,null,"bool"),dM={kernelName:ur,backendName:"cpu",kernelFunc:uM};function $E(n,t,e,r,s){const o=t.length,l=Ee(t),u=Wt(t),d=Wt(s),h=Rt(e,Ee(s));for(let p=0;p<l;++p){const g=Jr(p,o,u),y=new Array(g.length);for(let _=0;_<y.length;_++)y[_]=g[r[_]];h[Qr(y,o,d)]=n[p]}return h}function Vo(n){const{inputs:t,attrs:e,backend:r}=n,{x:s}=t,{perm:o}=e;Xt(s,"transpose");const u=new Array(s.shape.length);for(let g=0;g<u.length;g++)u[g]=s.shape[o[g]];const h=$E(r.data.get(s.dataId).values,s.shape,s.dtype,o,u);return{dataId:r.write(h,u,s.dtype),shape:u,dtype:s.dtype}}const hM={kernelName:Ps,backendName:"cpu",kernelFunc:Vo};function oN(n,t,e,r){const[s,o]=as(n,r),l=ye(t,"int32"),u=er(Ee(s),l),d=Ee(o);for(let h=0;h<u.length;++h){const p=h*d;let g=1;for(let y=0;y<d;++y)g*=e[p+y];u[h]=g}return{outVals:u,outShape:s,outDtype:l}}const pM={kernelName:Ys,backendName:"cpu",kernelFunc:function fM(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:o,keepDims:l}=r;Xt(s,"prod");const u=s.shape.length,d=Tt(o,s.shape),h=pr(d,u);let p=d,g=s;const y=[];null!=h&&(g=Vo({inputs:{x:s},backend:e,attrs:{perm:h}}),y.push(g),p=_r(p.length,u));const b=e.data.get(g.dataId).values,{outVals:_,outShape:I,outDtype:S}=oN(g.shape,g.dtype,b,p);let T=I;return l&&(T=Yr(I,d)),y.forEach(O=>e.disposeIntermediateTensorInfo(O)),e.makeTensorInfo(T,S,_)}};function iN(n,t){const e=n.slice(0,t);for(;e.length<t;)e.push(1);for(let r=t;r<n.length;r++)e[t-1]*=n[r];return e}function aN(n,t,e,r,s,o,l,u){if(0===n.length)throw new Error("paramsNestedSplits must be non empty");if(0===t[0].length)throw new Error("Split tensors must not be scalars");if(function mM(n,t,e){n.forEach((r,s)=>{if(r<0||r>=e){const o=Jr(s,t.length,Wt(t)).join(",");throw new Error(`indices[${o}] = ${r} is not in [0, ${e})`)}})}(o,l,t[0][0]-1),0===r.length)throw new Error("params.rank must be nonzero");const h=r[0],{outSplits:p,valueSlices:g,numValues:y}=function yM(n,t,e,r){const s=[];let o=0;const u=new Array(t.length-1+e.length).fill(null).map(()=>[0]);!function gM(n,t){for(let e=0;e<n.length;++e){const r=n[e],s=e===n.length-1?t:n[e+1].length;if(0===r.length)throw new Error("Ragged splits may not be empty");if(r[0]<0)throw new Error("Ragged splits must be non-negative");if(r[r.length-1]>s)throw new Error("Ragged splits must not point past values");for(let o=1;o<r.length;++o)if(r[o-1]>r[o])throw new Error("Ragged splits must be sorted in ascending order")}}(e,r);let d=1;for(let h=0;h<t.length-1;++h){d*=t[h];const p=t[h+1];for(let g=1;g<d+1;++g)u[h].push(g*p)}for(let h=0;h<n.length;++h){let p=n[h],g=n[h]+1;for(let y=0;y<e.length;++y){const b=e[y],_=y+t.length-1;if(_>=0){const I=u[_],S=I[I.length-1]-b[p];for(let T=p;T<g;++T)u[_].push(b[T+1]+S)}p=b[p],g=b[g]}g!==p&&(s.push([p,g]),o+=g-p)}return{outSplits:u,valueSlices:s,numValues:o}}(o,l,n,h),b=function vM(n){const t=[];for(let e=0;e<n.length;++e){const s=Ft("int32",n[e].length);t.push(s),n[e].forEach((o,l)=>s[l]=o)}return t}(p),_=function _M(n,t,e,r,s){const o=t.slice();o[0]=s;const l=Ft(e,Ee(o)),u=n.length;return function bM(n,t,e,r,s,o){const l=iN(t,2)[1],u=iN(o,2)[1];let d=0;for(const h of e)for(let p=h[0];p<h[1];++p){for(let g=0;g<r;++g)s[d*u+g]=n[p*l+g];++d}}(n,t,r,0===u?0:u/t[0],l,o),[l,o]}(e,r,s,g,y);return[b,_[0],_[1]]}const lN=2147483647;function cN(n,t,e,r,s,o,l){if(t.length>1)throw new Error("starts must be a scalar or vector");if(s.length>1)throw new Error("limits must be a scalar or vector");if(l.length>1)throw new Error("deltas must be a scalar or vector");const u=0===t.length,d=0===s.length,h=0===l.length,p=[];u||p.push(t[0]),d||p.push(s[0]),h||p.push(l[0]);for(let S=1;S<p.length;++S)if(p[S]!==p[S-1])throw new Error("starts, limits, and deltas must have the same shape");const g=0===p.length?1:p[0],y=Ft("int32",g+1);y[0]=0;for(let S=0;S<g;++S){const T=u?n[0]:n[S],O=d?r[0]:r[S],V=h?o[0]:o[S];if(0===V)throw new Error("Requires delta != 0");let U;if(V>0&&O<T||V<0&&O>T)U=0;else if(U=Math.ceil(Math.abs((O-T)/V)),U>lN)throw new Error(`Requires ((limit - start) / delta) <= ${lN}`);y[S+1]=y[S]+U}const _=Ft(e,y[g]);let I=0;for(let S=0;S<g;++S){const T=y[S+1]-y[S];let O=u?n[0]:n[S];const V=h?o[0]:o[S];for(let U=0;U<T;++U)_[I++]=O,O+=V}return[y,_]}var fa=Bo;class tx{constructor(t,e,r,s,o,l,u,d,h,p){this.shape=t,this.shapeShape=e,this.values=r,this.valuesShape=s,this.valuesDType=o,this.defaultValue=l,this.defaultValueShape=u,this.rowPartitionValues=d,this.rowPartitionValuesShapes=h,this.rowPartitionTypes=Fg(p),this.raggedRank=$g(this.rowPartitionTypes)}getRowPartitionTypeByDimension(t){return this.rowPartitionTypes[0]===fa.FIRST_DIM_SIZE?this.rowPartitionTypes[t+1]:this.rowPartitionTypes[t]}getRowPartitionTensor(t){return this.rowPartitionTypes[0]===fa.FIRST_DIM_SIZE?this.rowPartitionValues[t+1]:this.rowPartitionValues[t]}getMaxWidth(t){const e=this.getRowPartitionTensor(t-1);switch(this.getRowPartitionTypeByDimension(t-1)){case fa.VALUE_ROWIDS:return tx.getMaxWidthValueRowID(e);case fa.ROW_SPLITS:return tx.getMaxWidthRowSplit(e);default:throw new Error(`Cannot handle partition type ${fa[this.getRowPartitionTypeByDimension(t-1)]}`)}}static getMaxWidthRowSplit(t){const e=t.length;if(0===e||1===e)return 0;let r=0;for(let s=0;s<e-1;++s){const o=t[s+1]-t[s];o>r&&(r=o)}return r}static getMaxWidthValueRowID(t){const e=t.length;if(0===e)return 0;let r=0,s=t[0],o=0;for(let l=1;l<e;++l){const u=t[l];u!==s&&(s=u,o=Math.max(l-r,o),r=l)}return Math.max(e-r,o)}tensorShapeFromTensor(t,e,r=!0){if(0===e.length){if(-1===t[0])return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return dN(t,r)}calculateOutputSize(t){const e=this.valuesShape;Pg(this.defaultValueShape,e);const s=this.tensorShapeFromTensor(this.shape,this.shapeShape),l=Og(this.raggedRank,s,e);l[0]<0&&(l[0]=t);for(let u=1;u<=this.raggedRank;++u)l[u]<0&&(l[u]=this.getMaxWidth(u));return l}calculateFirstParentOutputIndex(t,e,r){const s=Math.min(t,r),o=[];let l=0;for(let u=0;u<s;++u,l+=e)o.push(l);for(let u=s;u<t;++u)o.push(-1);return G(o.length===t,()=>"Final length of result must be equal to firstDimension."),o}calculateOutputIndexRowSplit(t,e,r,s){const o=t.length,l=[];for(let u=0;u<o-1;++u){const d=t[u+1]-t[u];let h=Math.min(s,d),p=e[u];-1===p&&(h=0);for(let g=0;g<h;++g)l.push(p),p+=r;for(let g=0;g<d-h;++g)l.push(-1)}if(o>0&&l.length!==t[o-1])throw new Error("Invalid row split size.");return l}calculateOutputIndexValueRowID(t,e,r,s){const o=t.length,l=[];if(0===o)return[];let u=0,d=t[0];if(d>=e.length)throw new Error(`Got currentValueRowId=${d}, which is not less than ${e.length}`);let h=e[d];l.push(h);for(let p=1;p<o;++p){const g=t[p];if(g===d)h>=0&&(++u,u<s?h+=r:h=-1);else{if(u=0,d=g,g>=e.length)throw new Error(`Got nextValueRowId=${g} which is not less than ${e.length}`);h=e[g]}l.push(h)}if(l.length!==t.length)throw new Error("Invalid row ids.");return l}calculateOutputIndex(t,e,r,s){const o=this.getRowPartitionTensor(t),l=this.getRowPartitionTypeByDimension(t);switch(l){case fa.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(o,e,r,s);case fa.ROW_SPLITS:if(o.length-1>e.length)throw new Error(`Row partition size is greater than output size: ${o.length-1} > ${e.length}`);return this.calculateOutputIndexRowSplit(o,e,r,s);default:throw new Error(`Unsupported partition type: ${fa[l]}`)}}getFirstDimensionSize(){const t=this.rowPartitionValues[0];if(0===this.rowPartitionTypes.length)throw new Error("No row_partition_types given.");const e=this.rowPartitionTypes[0];switch(e){case fa.FIRST_DIM_SIZE:return t[0];case fa.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case fa.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${fa[e]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");const e=this.getFirstDimensionSize(),r=this.calculateOutputSize(e),s=new Array(this.raggedRank+1);s[s.length-1]=1;for(let d=s.length-2;d>=0;--d)s[d]=s[d+1]*r[d+1];const o=dN(r,!1),l=Ft(this.valuesDType,Ee(o));if(s[0]*r[0]>0){let d=this.calculateFirstParentOutputIndex(e,s[0],r[0]);for(let h=1;h<=this.raggedRank;++h)d=this.calculateOutputIndex(h-1,d,s[h],r[h]);this.setOutput(this.raggedRank,d,l,o)}return[o,l]}setOutput(t,e,r,s){if(0===r.length)return;const o=this.values,l=r;let u=s.slice();u=u.slice(t+1);const d=Ee(u),h=e.length;let p=this.defaultValue;if(p.length!==d&&1!==p.length){const _=this.defaultValueShape;En(()=>{const I=tt(p,_);p=zd(I,u).dataSync()})}let g=0,y=0,b=0;for(let _=0;_<=h;++_){let I=_<h?e[_]:-1;if(I!==b){if(y<b){const S=o.subarray(g*d);uN(l.subarray(y*d),S,(b-y)*d)}if(_>=h&&(I=Math.floor(r.length/d)),I>b)if(1===this.defaultValue.length)l.subarray(b*d,I*d).fill(this.defaultValue[0]),b=I;else for(;I>b;)uN(l.slice(b*d),p,d),++b;I<0?(g=_+1,y=b):(g=_,y=b,b=y+1)}else++b}}}function uN(n,t,e){for(let r=0;r<e;r++)n[r]=t[r]}function dN(n,t){const e=[];for(let r of n){if(r<0){if(!t)throw new Error(`Dimension ${r} must be >= 0`);if(r<-1)throw new Error(`Dimension ${r} must be >= -1`);r=-1}e.push(r)}return e}function hN(n,t,e,r,s,o,l,u,d,h){return new tx(n,t,e,r,s,o,l,u,d,h).compute()}function fN(n,t,e,r){if(n===t||n<t&&e<0||t<n&&e>1)return er(0,r);const d=er(Math.abs(Math.ceil((t-n)/e)),r);t<n&&1===e&&(e=-1),d[0]=n;for(let h=1;h<d.length;h++)d[h]=d[h-1]+e;return d}const pN=Xl(n=>1/Math.sqrt(n)),xM=rd(bl,pN),wM={kernelName:bl,backendName:"cpu",kernelFunc:xM};function Sh(n,t,e,r,s,o,l,u,d,h){const p=[r/s,s],g=n.values,y=t.values;if(0===r)return gn(e,t.dtype);const b=d instanceof zr?d:gn(p,t.dtype);"string"==typeof d||"number"==typeof d?b.values.fill(d):"boolean"==typeof d&&b.values.fill(+d);for(let _=0;_<o;_++){const I=[];let S=0;for(let T=0;T<l;T++){const O=g[_*l+T];I.push(O),S+=O*u[T]}if(S<0||S>=r/s)throw new Error(`Invalid indices: ${I} does not index into ${e}`);for(let T=0;T<s;T++)h?b.values[S*s+T]+=y[_*s+T]:b.values[S*s+T]=0===t.rank?y[0]:y[_*s+T]}return b}const CM=Xl(n=>1/(1+Math.exp(-n))),mN=Qn(dc,n=>1/(1+Math.exp(-n))),SM={kernelName:dc,backendName:"cpu",kernelFunc:mN};function gN(n,t,e,r,s){const o=Dc(r,t,e),l=Ee(e),u=Wt(r);if(o){const g=Em(t,u);return"string"===s?n.slice(g,g+l):n.subarray(g,g+l)}const h=gn(r,s,"string"===s?po(n):n),p=gn(e,s);for(let g=0;g<p.size;++g){const y=p.indexToLoc(g),b=y.map((_,I)=>_+t[I]);p.set(h.get(...b),...y)}return"string"===s?y_(p.values):p.values}function Eh(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{begin:o,size:l}=r;Xt(s,"slice");const[u,d]=Uv(s,o,l);Cm(s,u,d);const p=gN(e.data.get(s.dataId).values,u,d,s.shape,s.dtype);return e.makeTensorInfo(d,s.dtype,p)}const EM={kernelName:kr,backendName:"cpu",kernelFunc:Eh};function yN(n,t,e,r,s,o,l){const u=t[0],d=o[0],h=new Array(d),p=new Array(u),g=t[1];if(0===d){if(0!==u)throw new Error(f_(u));return[Ft(e,0),[0,g],Ft(s,0),h,p]}let y=!0,b=0;const _=new Array(d).fill(0);for(let S=0;S<u;++S){const T=n[S*g];if(T<0)throw new Error(p_(S,T));if(T>=d)throw new Error(Xg(S,T,d));++_[T],y=y&&T>=b,b=T}let I=!0;for(let S=0;S<d;++S){const T=0===_[S];h[S]=T,I=I&&!T,_[S]=Math.max(_[S],1),S>0&&(_[S]+=_[S-1])}if(I&&y){const S=n,T=r;for(let O=0;O<u;++O)p[O]=O;return[S,[u,g],T,h,p]}{const S=_[d-1],T=Ft(e,S*g),O=Ft(s,S),V=new Array(d).fill(0);for(let U=0;U<u;++U){const j=n[U*g],se=(0===j?0:_[j-1])+V[j];V[j]++;for(let le=0;le<g;++le)T[se*g+le]=n[U*g+le];O[se]=r[U],p[U]=se}for(let U=0;U<d;++U)if(0===V[U]){const te=0===U?0:_[U-1];T[te*g+0]=U;for(let se=1;se<g;++se)T[te*g+se]=0;O[te]=l}return[T,[S,g],O,h,p]}}function vN(n,t,e,r,s){const o=Ee(r),l=t[0],u=s.length,d=[];let h=1,p=-1;for(let S=0;S<u;++S){const T=s[S];if(-1===T){if(-1!==p)throw new Error(Xf(p,S));p=S,d.push(1)}else{if(T<0)throw new Error(Yg(S,T));h*=T,d.push(T)}}if(-1!==p){if(h<=0)throw new Error("reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero");const S=Math.trunc(o/h);if(h*S!==o)throw new Error(Qg(r,d));d[p]=S}if(Ee(d)!==o)throw new Error(Jg(r,d));const y=r.length,b=[];if(y>0){b[y-1]=1;for(let S=y-2;S>=0;--S)b[S]=b[S+1]*r[S+1]}const _=[];if(u>0){_[u-1]=1;for(let S=u-2;S>=0;--S)_[S]=_[S+1]*d[S+1]}const I=Ft(e,l*u);for(let S=0;S<l;++S){let T=0;for(let O=0;O<y;++O)T+=n[S*y+O]*b[O];for(let O=0;O<u;++O)I[S*u+O]=Math.trunc(T/_[O]),T%=_[O]}return[I,[l,u],d]}function PE(n,t,e,r,s,o=!1,l=0){const u=r.length,d=[t[0],n.length/t[0]],h=d[1],g=u>0?s[u-1]+1:0;if(g<0)throw new Error("segment ids must be >= 0");const y=t.slice();y[0]=g;const _=Ft(e,y.reduce((V,U)=>V*U,1));if(0===u)return g>0&&_.fill(l),[_,y];if(g<=0)throw new Error("segment ids must be >= 0");let I=0,S=1,T=0,O=s[I];for(;;){let V=0;if(S<u){if(V=s[S],O===V){++S;continue}if(O>=V)throw new Error("segment ids are not increasing")}if(O<0||O>=g)throw new Error(ny(O,g));O>T&&_.fill(l,T*h,O*h);for(let U=I;U<S;++U){const j=r[U];if(j<0||j>=d[0])throw new Error(m_(U,r[U],d[0]));for(let te=0;te<h;te++)_[O*h+te]+=n[j*h+te]}if(o)for(let U=0;U<h;U++)_[O*h+U]/=S-I;if(I=S,++S,T=O+1,O=V,S>u)break}return T<g&&_.fill(l,T*h,g*h),[_,y]}const IM=Xl(n=>Math.sqrt(n)),DM=Qn(hc,n=>Math.sqrt(n)),TM={kernelName:hc,backendName:"cpu",kernelFunc:DM},bN=Zr((n,t)=>{const e=n-t;return e*e}),NM=Es(M,bN),kM={kernelName:M,backendName:"cpu",kernelFunc:NM},_N=Xl((n,t)=>{const{pattern:e,replaceGlobal:r,rewrite:s}=t;return n.replace(new RegExp(e,r?"g":""),s)}),AM=rd(oe,_N),RM={kernelName:oe,backendName:"cpu",kernelFunc:AM};function xN(n,t,e,r){const s=gn(n,t.dtype);for(let o=0;o<s.size;o++){const l=s.indexToLoc(o),u=new Array(l.length);for(let d=0;d<u.length;d++)u[d]=l[d]*e[d]+r[d];s.set(t.get(...u),...l)}return s}class MM{constructor(t,e,r,s,o,l){this.separator=oo(t),this.nGramWidths=e,this.leftPad=oo(r),this.rightPad=oo(s),this.padWidth=o,this.preserveShort=l}getPadWidth(t){return Math.min(this.padWidth<0?t-1:this.padWidth,t-1)}getNumNGrams(t,e){const r=this.getPadWidth(e);return Math.max(0,t+2*r-e+1)}createNGrams(t,e,r,s,o,l){for(let u=0;u<o;++u){const d=this.getPadWidth(l),h=Math.max(0,d-u),p=Math.max(0,d-(o-(u+1))),g=l-(h+p),y=e+(h>0?0:u-d);let b=0;b+=h*this.leftPad.length;for(let O=0;O<g;++O)b+=t[y+O].length;b+=p*this.rightPad.length,b+=(h+p+g-1)*this.separator.length,r[s+u]=new Uint8Array(b);const I=r[s+u];let S=0;const T=O=>O.forEach(V=>I[S++]=V);for(let O=0;O<h;++O)T(this.leftPad),T(this.separator);for(let O=0;O<g-1;++O)T(t[y+O]),T(this.separator);if(g>0){T(t[y+g-1]);for(let O=0;O<p;++O)T(this.separator),T(this.rightPad)}else{for(let O=0;O<p-1;++O)T(this.rightPad),T(this.separator);T(this.rightPad)}}}compute(t,e){const r=t.length,s=e.length;if(s>0){let d=e[0];if(0!==d)throw new Error(`First split value must be 0, got ${d}`);for(let h=1;h<s;++h){let p=e[h]>=d;if(p=p&&e[h]<=r,!p)throw new Error(`Invalid split value ${e[h]}, must be in [${d}, ${r}]`);d=e[h]}if(d!==r)throw new Error(`Last split value must be data size. Expected ${r}, got ${d}`)}const o=s-1,l=Ft("int32",s);if(0===r||0===s){const d=new Array(r);for(let h=0;h<=o;++h)l[h]=0;return[d,l]}l[0]=0;for(let d=1;d<=o;++d){const h=e[d]-e[d-1];let p=0;this.nGramWidths.forEach(g=>{p+=this.getNumNGrams(h,g)}),this.preserveShort&&h>0&&0===p&&(p=1),l[d]=l[d-1]+p}const u=new Array(l[o]);for(let d=0;d<o;++d){const h=e[d];let p=l[d];if(this.nGramWidths.forEach(g=>{const b=this.getNumNGrams(e[d+1]-e[d],g);this.createNGrams(t,h,u,p,b,g),p+=b}),this.preserveShort&&p===l[d]){const g=e[d+1]-e[d];if(0===g)continue;this.createNGrams(t,h,u,p,1,g+2*this.padWidth)}}return[u,l]}}function wN(n,t,e,r,s,o,l,u){return new MM(e,r,s,o,l,u).compute(n,t)}function OM(n,t,e,r){if(!n.length)return;if(0===t.length){for(let o=0;o<n.length;++o)r.push(n.subarray(o,o+1));return}if(1===t.length){const o=t[0];let l=n.indexOf(o);for(;-1!==l;){const u=n.subarray(0,l);(!e||0!==u.length)&&r.push(u),l=(n=n.subarray(l+1)).indexOf(o)}return void((!e||0!==n.length)&&r.push(n))}let s=0;for(let o=0;o<n.length+1;o++)if(o===n.length||-1!==t.indexOf(n[o])){const l=n.subarray(s,o);(!e||0!==l.length)&&r.push(l),s=o+1}}function CN(n,t,e){const r=n.length,s=[];let o=0,l=0;const u=new Array(r);for(let y=0;y<r;++y){const b=s.length;OM(n[y],t,e,s);const _=s.length-b;u[y]=_,o+=_,l=Math.max(l,_)}const d=Ft("int32",2*o),h=new Array(o),p=[r,l];let g=0;for(let y=0;y<r;++y)for(let b=0;b<u[y];++b)d[2*g]=y,d[2*g+1]=b,h[g]=s[g],++g;return[d,h,p]}function SN(n,t){const e=Ft("int32",n.length);for(let r=0;r<n.length;++r)e[r]=Gn(n[r]).modulo(t).getLowBitsUnsigned();return e}const EN=Zr((n,t)=>n-t),FM=ME((n,t,e,r)=>({real:n-e,imag:t-r})),LE=Es(Tn,EN,FM),$M={kernelName:Tn,backendName:"cpu",kernelFunc:LE};function IN(n,t){const e=new Array(n.rank);for(let s=0;s<e.length;s++)e[s]=n.shape[s]*t[s];const r=gn(e,n.dtype);for(let s=0;s<r.values.length;++s){const o=r.indexToLoc(s),l=new Array(n.rank);for(let d=0;d<l.length;d++)l[d]=o[d]%n.shape[d];const u=n.locToIndex(l);r.values[s]=n.values[u]}return r}const My=(n,t)=>{const e=t.value-n.value;return 0===e?n.index-t.index:e};function DN(n,t,e=0,r=n.length-1){for(;r>e;){if(r-e>600){const u=r-e+1,d=t-e+1,h=Math.log(u),p=.5*Math.exp(2*h/3),g=.5*Math.sqrt(h*p*(u-p)/u)*Math.sign(d-u/2);DN(n,t,Math.max(e,Math.floor(t-d*p/u+g)),Math.min(r,Math.floor(t+(u-d)*p/u+g)))}const s=n[t];let o=e,l=r;for(Pt(n,e,t),My(n[r],s)>0&&Pt(n,e,r);o<l;){for(Pt(n,o,l),o++,l--;My(n[o],s)<0;)o+=1;for(;My(n[l],s)>0;)l-=1}0===My(n[e],s)?Pt(n,e,l):(l+=1,Pt(n,l,r)),l<=t&&(e=l+1),t<=l&&(r=l-1)}}function TN(n,t,e,r,s){const o=t[t.length-1],[l,u]=[n.length/o,o],d=Rt(e,l*r),h=Rt("int32",l*r);for(let g=0;g<l;g++){const y=g*u,b=n.subarray(y,y+u);let _=new Array(b.length);b.forEach((O,V)=>_[V]={value:O,index:V}),r<_.length&&(DN(_,r),_=_.slice(0,r)),s&&_.sort(My);const I=g*r,S=d.subarray(I,I+r),T=h.subarray(I,I+r);for(let O=0;O<r;O++)S[O]=_[O].value,T[O]=_[O].index}const p=t.slice();return p[p.length-1]=r,[gn(p,e,d),gn(p,"int32",h)]}function NN(n,t,e,r){const s=Tt(t,e)[0],o=[1,e[0],1];for(let _=0;_<s;_++)o[0]*=e[_];o[1]=e[s];for(let _=s+1;_<e.length;_++)o[2]*=e[_];const l=new Map,u=new Int32Array(e[s]),d=new zr(o,r,n),h=[],p=1===o[0]&&1===o[2];for(let _=0;_<e[s];_++){let I;if(p)I=n[_].toString();else{const T=[];for(let O=0;O<o[0];O++)for(let V=0;V<o[2];V++)T.push(d.get(O,_,V));I=T.join(",")}const S=l.get(I);if(null!=S)u[_]=S;else{const T=l.size;l.set(I,T),u[_]=T,h.push(_)}}const g=o.slice();g[1]=l.size;const y=new zr(g,r);h.forEach((_,I)=>{for(let S=0;S<o[0];S++)for(let T=0;T<o[2];T++)y.set(d.get(S,_,T),S,I,T)});const b=e.slice();return b[s]=g[1],{outputValues:y.values,outputShape:b,indices:u}}const{addImpl:PM,bincountImpl:kN,bincountReduceImpl:LM,bitwiseAndImpl:BM,castImpl:VM,ceilImpl:UM,concatImpl:zM,equalImpl:HM,expImpl:WM,expm1Impl:jM,floorImpl:GM,gatherNdImpl:KM,gatherV2Impl:qM,greaterImpl:XM,greaterEqualImpl:YM,lessImpl:ZM,lessEqualImpl:QM,linSpaceImpl:JM,logImpl:eO,maxImpl:tO,maximumImpl:nO,minimumImpl:rO,multiplyImpl:sO,negImpl:oO,notEqualImpl:iO,prodImpl:aO,raggedGatherImpl:lO,raggedRangeImpl:cO,raggedTensorToTensorImpl:uO,rangeImpl:dO,rsqrtImpl:hO,scatterImpl:fO,sigmoidImpl:pO,simpleAbsImpl:AN,sliceImpl:mO,sparseFillEmptyRowsImpl:gO,sparseReshapeImpl:yO,sparseSegmentReductionImpl:RN,sqrtImpl:vO,staticRegexReplaceImpl:bO,stridedSliceImpl:_O,stringNGramsImpl:xO,stringSplitImpl:wO,stringToHashBucketFastImpl:CO,subImpl:SO,tileImpl:EO,topKImpl:IO,transposeImpl:BE,uniqueImpl:DO}=X;function MN(n,t){return["x","y","z","w","u","v"].slice(0,t).map(e=>`${n}.${e}`)}function yo(n,t){return 1===t?[n]:MN(n,t)}class NO{constructor(t){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=t,this.rank=t.length,this.enableShapeUniforms=to(this.outputShape.length),0===this.rank)this.userCode="\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      ";else{const e=yo("rc",this.rank),r=ir(this.rank),s=this.getOutOfBoundsCondition(e),o=this.getSetup(e),l=this.getOutput(e);this.userCode=`\n        void main() {\n          ${r} rc = getOutputCoords();\n\n          if(${s}) {\n            setOutput(vec4(0));\n          } else {\n            ${o}\n\n            setOutput(vec4(${l}));\n          }\n        }\n      `}}getSourceCoordsArr(t){const e=[];for(let r=0;r<=1;r++)for(let s=0;s<=1;s++){let o=`${0===r?"r":"rp1"}, ${0===s?"c":"cp1"}`;for(let l=2;l<this.rank;l++)o=`${t[t.length-1-l]},`+o;e.push(o)}return e}getOutOfBoundsCondition(t){if(1===this.rank)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let e="";for(let r=this.rank-2;r<this.rank;r++)e+=`${t[r]} >= ${this.enableShapeUniforms?`outShape[${r}]`:this.outputShape[r]}`,r<this.rank-1&&(e+="||");return e}getSetup(t){if(1===this.rank)return"";const e=t.slice(-2);return`\n      int r = ${e[0]};\n      int c = ${e[1]};\n      int rp1 = r + 1;\n      int cp1 = c + 1;\n\n      bool cEdge = cp1 >= ${this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1]};\n      bool rEdge = rp1 >= ${this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2]};\n    `}getOutput(t){const e=this.getSourceCoordsArr(t);return 1===this.rank?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${e[0]}),\n            cEdge ? 0. : getA(${e[1]}),\n            rEdge ? 0. : getA(${e[2]}),\n            rEdge || cEdge ? 0. : getA(${e[3]})`}}class ON{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=t,this.enableShapeUniforms=to(this.outputShape.length);let r="";for(let s=0;s<4;s++){let o="thisRC = rc;";s%2==1&&(o+="thisRC.z += 1;"),s>1&&(o+="thisRC.y += 1;"),r+=`\n        ${o}\n        ${s>0?"if(thisRC.y < rows && thisRC.z < cols){":""}\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[${s}] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        ${s>0?"}":""}\n      `}this.userCode=`\n      ${function kO(n,t){return`\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      ${t?function yR(n,t,e="index"){const s=function gR(n,t){const e=n.length,r=n.map(o=>`${t}[${o}]`),s=new Array(e-1);s[e-2]=r[e-1];for(let o=e-3;o>=0;--o)s[o]=`(${s[o+1]} * ${r[o+1]})`;return s}(n.map((o,l)=>l),t);return s.map((o,l)=>`int ${n[l]} = ${e} / ${s[l]}; ${l===s.length-1?`int ${n[l+1]} = ${e} - ${n[l]} * ${s[l]}`:`index -= ${n[l]} * ${s[l]}`};`).join("")}(["r","c","d"],"inputShape"):xh(["r","c","d"],n)}\n      return ivec3(r, c, d);\n    }\n  `}(e,this.enableShapeUniforms)}\n      ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":NE(t)}\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = ${this.enableShapeUniforms?"outShape[1]":t[1]};\n        int cols = ${this.enableShapeUniforms?"outShape[2]":t[2]};\n\n        ${r}\n\n        setOutput(result);\n      }\n    `}}class AO{constructor(t){this.gpgpu=t,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.usedTextures={},this.logEnabled=!1}acquireTexture(t,e,r){const s=$N(e,r),o=PN(t,s,r);o in this.freeTextures||(this.freeTextures[o]=[]),o in this.usedTextures||(this.usedTextures[o]=[]);const l=FN(t,s,this.gpgpu.gl,this.gpgpu.textureConfig,r);if(this.freeTextures[o].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=l,this.log();const d=this.freeTextures[o].pop();return this.usedTextures[o].push(d),d}let u;return s===cs.PACKED_2X2_FLOAT32?u=this.gpgpu.createPackedMatrixTexture(t[0],t[1]):s===cs.PACKED_2X2_FLOAT16?u=this.gpgpu.createFloat16PackedMatrixTexture(t[0],t[1]):s===cs.UNPACKED_FLOAT32?u=this.gpgpu.createFloat32MatrixTexture(t[0],t[1]):s===cs.UNPACKED_FLOAT16?u=this.gpgpu.createFloat16MatrixTexture(t[0],t[1]):s===cs.PACKED_4X1_UNSIGNED_BYTE&&(u=this.gpgpu.createUnsignedBytesMatrixTexture(t[0],t[1])),this.usedTextures[o].push(u),this.numUsedTextures++,this._numBytesAllocated+=l,this.log(),u}releaseTexture(t,e,r,s){if(null==this.freeTextures)return;const o=$N(r,s),l=PN(e,o,s);l in this.freeTextures||(this.freeTextures[l]=[]);const u=FN(e,o,this.gpgpu.gl,this.gpgpu.textureConfig,s),d=Q().getNumber("WEBGL_DELETE_TEXTURE_THRESHOLD");-1!==d&&this._numBytesAllocated>d?(this.gpgpu.deleteMatrixTexture(t.texture),this._numBytesAllocated-=u):(this.freeTextures[l].push(t),this.numFreeTextures++,this._numBytesFree+=u),this.numUsedTextures--;const h=this.usedTextures[l],p=h&&h.indexOf(t);if(null==p||p<0)throw new Error("Cannot release a texture that was never provided by this texture manager");h[p]=h[h.length-1],h.pop(),this.log()}log(){if(!this.logEnabled)return;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${this.numFreeTextures+this.numUsedTextures})`);const e=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*e)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(null!=this.freeTextures){for(const t in this.freeTextures)this.freeTextures[t].forEach(e=>{this.gpgpu.deleteMatrixTexture(e.texture)});for(const t in this.usedTextures)this.usedTextures[t].forEach(e=>{this.gpgpu.deleteMatrixTexture(e.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function FN(n,t,e,r,s){const o=function MO(n,t){switch(n){case cs.PACKED_2X2_FLOAT32:return kT(t);case cs.PACKED_2X2_FLOAT16:return AT(t);case cs.UNPACKED_FLOAT32:return DT(t);case cs.UNPACKED_FLOAT16:return TT(t);case cs.PACKED_4X1_UNSIGNED_BYTE:return NT(t);default:throw new Error(`Unknown physical texture type ${n}`)}}(t,r);let l;if(s){const[d,h]=td(n[0],n[1]);l=d*h}else{const[d,h]=vh(n[0],n[1]);l=d*h}const u=function RO(n,t){if(t===n.R32F)return 4;if(t===n.R16F)return 2;if(t===n.RGBA32F)return 16;if(t===n.RGBA)return 16;if(t===n.RGBA16F)return 8;if(t===n.RGBA8)return 4;throw new Error(`Unknown internal format ${t}`)}(e,o);return l*u}function $N(n,t){if(n===eo.UPLOAD)return cs.PACKED_2X2_FLOAT32;if(n===eo.RENDER||null==n)return function OO(n){return Q().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?n?cs.PACKED_2X2_FLOAT32:cs.UNPACKED_FLOAT32:n?cs.PACKED_2X2_FLOAT16:cs.UNPACKED_FLOAT16}(t);if(n===eo.DOWNLOAD||n===eo.PIXELS)return cs.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${n}`)}function PN(n,t,e){return`${n[0]}_${n[1]}_${t}_${e}`}class Yl{constructor(t,e){this.variableNames=["A"],this.outputShape=t,this.enableShapeUniforms=to(this.outputShape.length),this.userCode=`\n      float unaryOperation(float x) {\n        ${e}\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}const LN="return abs(x);",sd="return x;";class od{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.enableShapeUniforms=to(this.outputShape.length),this.userCode=`\n      vec4 unaryOperation(vec4 x) {\n        ${e}\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}class jO{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=t,this.enableShapeUniforms=to(this.outputShape.length);const e=t.length,r=yo("rc",e),s=ir(e),o=function TO(n,t){if(1===n)return"rc";let e="";for(let r=0;r<n;r++)e+=t[r],r<n-1&&(e+=",");return e}(e,r),l=r.slice(-2),u=e<=1?"rc":`vec2(${l.join(",")})`;this.userCode=`\n      void main() {\n        ${s} rc = getOutputCoords();\n        vec4 packedInput = getA(${o});\n\n        setOutput(getChannel(packedInput, ${u}));\n      }\n    `}}const GO=Za,nx={},YO=Q().getNumber("CPU_HANDOFF_SIZE_THRESHOLD");let JO=(()=>{class n extends ue{nextDataId(){return n.nextDataId++}constructor(e){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!Q().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let r;if(null!=e){if(e instanceof RE)r=e;else{const s=ha(Q().getNumber("WEBGL_VERSION"),e);r=new RE(s)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{const s=ha(Q().getNumber("WEBGL_VERSION"));r=new RE(s),this.binaryCache=function XO(n){return n in nx||(nx[n]={}),nx[n]}(Q().getNumber("WEBGL_VERSION")),this.gpgpuCreatedLocally=!0}this.gpgpu=r,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new AO(this.gpgpu),this.numMBBeforeWarning=function QO(){return null==Q().global.screen?1024:Q().global.screen.height*Q().global.screen.width*window.devicePixelRatio*600/1024/1024}(),this.texData=new ce(this,Qi())}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(e,r,s,o,l,u){const d=this.makeTensorInfo(r,s),h=this.texData.get(d.dataId);h.isPacked=!1,h.texture={texture:e,texShape:[o,l]},h.texShape=[o,l];const p=fe(r),g=new IT(p,!1,u),y=this.runWebGLProgram(g,[d],s,[[o,l]]);return y.shape=r,h.texture=null,this.disposeIntermediateTensorInfo(d),y.dataId}write(e,r,s){if((Q().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||Q().getBool("DEBUG"))&&this.checkNumericalProblems(e),"complex64"===s&&null!=e)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const o={id:this.nextDataId()};return this.texData.set(o,{shape:r,dtype:s,values:e,usage:eo.UPLOAD,refCount:1}),o}refCount(e){return this.texData.has(e)?this.texData.get(e).refCount:0}incRef(e){this.texData.get(e).refCount++}decRef(e){this.texData.has(e)&&this.texData.get(e).refCount--}move(e,r,s,o,l){if(Q().getBool("DEBUG")&&this.checkNumericalProblems(r),"complex64"===o)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:s,dtype:o,values:r,usage:eo.UPLOAD,refCount:l})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){const r=this.texData.get(e),{values:s,dtype:o,complexTensorInfos:l,slice:u,shape:d,isPacked:h}=r;if(null!=u){let b;b=h?new od(d,sd):new Yl(d,sd);const _=this.runWebGLProgram(b,[{dataId:e,shape:d,dtype:o}],o),I=this.readSync(_.dataId);return this.disposeIntermediateTensorInfo(_),I}if(null!=s)return this.convertAndCacheOnCPU(e);if("string"===o)return s;const p=null!=this.activeTimers;let g,y;return p&&(g=Oo()),y="complex64"===o?Qa(this.readSync(l.real.dataId),this.readSync(l.imag.dataId)):this.getValuesFromTexture(e),p&&(this.downloadWaitMs+=Oo()-g),this.convertAndCacheOnCPU(e,y)}read(e){var r=this;return xe(function*(){if(r.pendingRead.has(e)){const S=r.pendingRead.get(e);return new Promise(T=>S.push(T))}const s=r.texData.get(e),{values:o,shape:l,slice:u,dtype:d,complexTensorInfos:h,isPacked:p}=s;if(null!=u){let S;S=p?new od(l,sd):new Yl(l,sd);const T=r.runWebGLProgram(S,[{dataId:e,shape:l,dtype:d}],d),O=r.read(T.dataId);return r.disposeIntermediateTensorInfo(T),O}if(null!=o)return r.convertAndCacheOnCPU(e);if(Q().getBool("DEBUG")&&!Q().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&2===Q().getNumber("WEBGL_VERSION"))throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let y,b,g=null;if("complex64"!==d&&Q().get("WEBGL_BUFFER_SUPPORTED")){y=r.decode(e);const S=r.texData.get(y.dataId);g=r.gpgpu.createBufferFromTexture(S.texture.texture,...bh(l))}if(r.pendingRead.set(e,[]),"complex64"!==d&&(yield r.gpgpu.createAndWaitForFence()),"complex64"===d){const S=yield Promise.all([r.read(h.real.dataId),r.read(h.imag.dataId)]);b=Qa(S[0],S[1])}else if(null==g)b=r.getValuesFromTexture(e);else{const S=Ee(l);b=r.gpgpu.downloadFloat32MatrixFromBuffer(g,S)}if(null!=y&&r.disposeIntermediateTensorInfo(y),null!=g){const S=r.gpgpu.gl;At(S,()=>S.deleteBuffer(g))}const _=r.convertAndCacheOnCPU(e,b),I=r.pendingRead.get(e);return r.pendingRead.delete(e),I.forEach(S=>S(_)),r.pendingDisposal.has(e)&&(r.pendingDisposal.delete(e),r.disposeData(e)&&Qi().removeDataId(e,r),r.pendingDeletes--),_})()}readToGPU(e,r={}){const s=this.texData.get(e),{values:o,shape:l,slice:u,dtype:d,isPacked:h,texture:p}=s;if("complex64"===d)throw new Error("Does not support reading texture for complex64 dtype.");if(null!=u){let _;_=h?new od(l,sd):new Yl(l,sd);const I=this.runWebGLProgram(_,[{dataId:e,shape:l,dtype:d}],d),S=this.readToGPU(I,r);return this.disposeIntermediateTensorInfo(I),S}if(null==p)throw null!=o?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const g=this.decode(e,r.customTexShape),y=Qi().makeTensorFromTensorInfo(g),b=this.texData.get(g.dataId);return Object.assign({tensorRef:y},b.texture)}bufferSync(e){const r=this.readSync(e.dataId);if("string"===e.dtype)try{const s=r.map(o=>wi(o));return gn(e.shape,e.dtype,s)}catch(s){throw new Error("Failed to decode encoded string bytes into utf-8")}return gn(e.shape,e.dtype,r)}checkNumericalProblems(e){if(null!=e)for(let r=0;r<e.length;r++){const s=e[r];if(!SE(s))throw Q().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${s} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${s} cannot be represented on this device.`)}}getValuesFromTexture(e){const{shape:r,dtype:s,isPacked:o}=this.texData.get(e),l=Ee(r);if(Q().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const b=this.decode(e),_=this.texData.get(b.dataId),I=this.gpgpu.downloadMatrixFromPackedTexture(_.texture.texture,...bh(r)).subarray(0,l);return this.disposeIntermediateTensorInfo(b),I}const u=Q().getBool("WEBGL_PACK")&&!0===o,d=u?fe(r):r,h=u?new a2(d):new o2(d),p=this.runWebGLProgram(h,[{shape:d,dtype:s,dataId:e}],"float32"),g=this.texData.get(p.dataId),y=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(g.texture.texture,g.texShape[0],g.texShape[1]).subarray(0,l);return this.disposeIntermediateTensorInfo(p),y}timerAvailable(){return Q().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(e){var r=this;const s=this.activeTimers,o=[];let l=!1;null==this.programTimersStack?(this.programTimersStack=o,l=!0):this.activeTimers.push(o),this.activeTimers=o,e();const u=Pa(this.activeTimers.map(p=>p.query)).filter(p=>null!=p),d=Pa(this.activeTimers.map(p=>p.name)).filter(p=>null!=p);this.activeTimers=s,l&&(this.programTimersStack=null);const h={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return xe(function*(){if(Q().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const p=yield Promise.all(u);h.kernelMs=function qt(n){let t=0;for(let e=0;e<n.length;e++)t+=n[e];return t}(p),h.getExtraProfileInfo=()=>p.map((g,y)=>({name:d[y],ms:g})).map(g=>`${g.name}: ${g.ms}`).join(", ")}else h.kernelMs={error:"WebGL query timers are not supported in this environment."};return r.uploadWaitMs=0,r.downloadWaitMs=0,h})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return Q().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:Oo(),endMs:null}}endTimer(e){return Q().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=Oo(),e)}getQueryTime(e){var r=this;return xe(function*(){return Q().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?r.gpgpu.waitForQueryAndGetTime(e):e.endMs-e.startMs})()}disposeData(e,r=!1){if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(r?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!r&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);const{complexTensorInfos:s}=this.texData.get(e);return null!=s&&(this.disposeData(s.real.dataId,r),this.disposeData(s.imag.dataId,r)),this.texData.delete(e),!0}releaseGPUData(e){const{texture:r,dtype:s,texShape:o,usage:l,isPacked:u,slice:d}=this.texData.get(e),h=d&&d.origDataId||e,p=this.dataRefCount.get(h);p>1?this.dataRefCount.set(h,p-1):(this.dataRefCount.delete(h),null!=r&&(this.numBytesInGPU-=this.computeBytes(o,s),this.textureManager.releaseTexture(r,o,l,u)));const g=this.texData.get(e);g.texture=null,g.texShape=null,g.isPacked=!1,g.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture.texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e,r=YO){return Q().getBool("WEBGL_CPU_FORWARD")&&e.every(s=>null==this.texData.get(s.dataId).texture&&Ee(s.shape)<r)}getGPGPUContext(){return this.gpgpu}where(e){Js("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const r=e.dataSync();return GO(e.shape,r)}packedUnaryOp(e,r,s){const o=new od(e.shape,r),l=this.compileAndRun(o,[e],s);return Qi().makeTensorFromTensorInfo(l)}abs(e){if(this.shouldExecuteOnCPU([e])&&"complex64"!==e.dtype){const o=AN(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,o)}if(Q().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,LN,e.dtype);const r=new Yl(e.shape,LN),s=this.compileAndRun(r,[e]);return Qi().makeTensorFromTensorInfo(s)}makeTensorInfo(e,r,s){let o;if("string"===r&&null!=s&&s.length>0&&bo(s[0])){const l=s.map(u=>oo(u));o=this.write(l,e,r)}else o=this.write(s,e,r);return this.texData.get(o).usage=null,{dataId:o,shape:e,dtype:r}}makeOutput(e,r,s){return Qi().makeTensorFromTensorInfo(this.makeTensorInfo(e,r,s),this)}unpackTensor(e){const r=new jO(e.shape);return this.runWebGLProgram(r,[e],e.dtype)}packTensor(e){const r=new NO(e.shape);return this.runWebGLProgram(r,[e],e.dtype,null,!0)}packedReshape(e,r){const s=[W(e.shape),...J(e.shape)],o={dtype:e.dtype,shape:s,dataId:e.dataId},l=[W(r),...J(r)],u=new ON(l,s),p=this.runWebGLProgram(u,[o],e.dtype,[s],!0);return{dataId:p.dataId,shape:r,dtype:p.dtype}}decode(e,r){const s=this.texData.get(e),{isPacked:o,shape:l,dtype:u}=s;null!=r&&G(Ee(l)<=r[0]*r[1]*4,()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.");const d=fe(l);let h;h=o?new s2(d):new r2(d);const g=[null!=r?r:bh(d)];return{dtype:u,shape:l,dataId:this.runWebGLProgram(h,[{shape:d,dtype:u,dataId:e}],u,g,!0,r).dataId}}runWebGLProgram(e,r,s,o,l=!1,u){const d=this.makeTensorInfo(e.outputShape,s),h=this.texData.get(d.dataId);if(e.packedOutput&&(h.isPacked=!0),e.outPackingScheme===yh.DENSE){const O=null!=u?u:bh(e.outputShape);h.texShape=O.map(V=>2*V)}if(null!=e.outTexUsage&&(h.usage=e.outTexUsage),0===Ee(d.shape))return h.values=Rt(d.dtype,0),d;const p=[],g=r.map(O=>{if("complex64"===O.dtype)throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let V=this.texData.get(O.dataId);if(null==V.texture){if(!e.packedInputs&&Ee(O.shape)<=Q().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:O.shape,texData:null,isUniform:!0,uniformValues:V.values};e.packedInputs&&(V.isPacked=!0,V.shape=O.shape)}if(this.uploadToGPU(O.dataId),!!V.isPacked!=!!e.packedInputs)O=V.isPacked?this.unpackTensor(O):this.packTensor(O),p.push(O),V=this.texData.get(O.dataId);else if(V.isPacked&&!mt(V.shape,O.shape)){const U=O,j=O.shape;O.shape=V.shape,O=this.packedReshape(O,j),p.push(O),V=this.texData.get(O.dataId),U.shape=j}return{shape:O.shape,texData:V,isUniform:!1}});this.uploadToGPU(d.dataId);const y={shape:d.shape,texData:h,isUniform:!1},b=function n2(n,t,e){let r="";t.concat(e).forEach(l=>{const u=null!=l.texData&&null!=l.texData.slice&&l.texData.slice.flatOffset>0;if(n.enableShapeUniforms&&!l.isUniform){const d=l.texData.texShape,{useSqueezeShape:h,uniformShape:p,keptDims:g}=AE(n.packedInputs,l.shape,d);let y="",b="",_="";if(1===p.length&&n.packedInputs){const j=[Math.ceil(d[0]/2),Math.ceil(d[1]/2)];y=`${j[0]>1}_${j[1]>1}`}else if(2!==p.length||n.packedInputs){if(p.length>2&&!n.packedInputs){const j=Wt(p);_=`${j[0]===d[1]}_${j[j.length-1]===d[1]}`}}else b=`${p[0]>1}_${p[1]>1}`;const I=l.shape.length,S=2===p.length&&un(l.shape,d),T=1===Ee(l.shape),O=Ec(l.shape,e.shape),V=!n.packedInputs&&I===e.shape.length&&un(d,e.texData.texShape);r+=`${I}_${V}_${h?g:""}_${p.length}_${T}_${O}_${S}_${y}_${b}_${_}_${n.packedInputs||p.length>2?"":`${d[0]>1}_${d[1]>1}`}_${u}`}else r+=`${l.shape}_${l.isUniform?"uniform":l.texData.texShape}_${u}`});let o=n.constructor.name;return o+="_"+r+"_"+n.userCode+`${Q().getNumber("WEBGL_VERSION")}`,o}(e,g,y),_=this.getAndSaveBinary(b,()=>function e2(n,t,e,r){const s=e.map((p,g)=>{const y={logicalShape:p.shape,texShape:p.isUniform?null:p.texData.texShape,isUniform:p.isUniform,isPacked:!p.isUniform&&p.texData.isPacked,flatOffset:null};return null!=p.texData&&null!=p.texData.slice&&p.texData.slice.flatOffset>0&&(y.flatOffset=p.texData.slice.flatOffset),{name:t.variableNames[g],shapeInfo:y}}),o=s.map(p=>p.shapeInfo),l={logicalShape:r.shape,texShape:r.texData.texShape,isUniform:!1,isPacked:r.texData.isPacked,flatOffset:null},u=vR(s,l,t),d=function IE(n,t){const e=R(n,()=>n.createShader(n.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(At(n,()=>n.shaderSource(e,t)),At(n,()=>n.compileShader(e)),Q().get("ENGINE_COMPILE_ONLY"))return e;if(!1===n.getShaderParameter(e,n.COMPILE_STATUS))throw X_(t,n.getShaderInfoLog(e)),new Error("Failed to compile fragment shader.");return e}(n.gl,u),h=n.createProgram(d);return Q().get("ENGINE_COMPILE_ONLY")?{program:t,fragmentShader:d,source:u,webGLProgram:h,inShapeInfos:o,outShapeInfo:l,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:(n.buildVao(h),Object.assign({program:t,fragmentShader:d,source:u,webGLProgram:h,inShapeInfos:o,outShapeInfo:l},ST(n,t,h)))}(this.gpgpu,e,g,y)),I=null!=this.activeTimers;let S;I&&(S=this.startTimer()),Q().get("ENGINE_COMPILE_ONLY")||function t2(n,t,e,r,s){t.program.enableShapeUniforms||(ET(t.inShapeInfos,e),ET([t.outShapeInfo],[r]));const o=r.texData.texture,l=r.texData.texShape;r.texData.isPacked?n.setOutputPackedMatrixTexture(o.texture,l[0],l[1]):n.setOutputMatrixTexture(o.texture,l[0],l[1]),n.setProgram(t.webGLProgram),n.bindVertexArray(t.webGLProgram.vao),1===Q().getNumber("WEBGL_VERSION")&&null!==t.infLoc&&n.gl.uniform1f(t.infLoc,1/0),null!==t.nanLoc&&n.gl.uniform1f(t.nanLoc,NaN);for(let d=0;d<e.length;++d){const h=e[d],{uniform:p,offset:g,shape:y,texShape:b}=t.variablesLocations[d];if(y){const{uniformShape:_}=AE(t.program.packedInputs,h.shape,h.texData.texShape);switch(_.length){case 1:n.gl.uniform1iv(y,new Int32Array(_));break;case 2:n.gl.uniform2iv(y,new Int32Array(_));break;case 3:n.gl.uniform3iv(y,new Int32Array(_));break;case 4:n.gl.uniform4iv(y,new Int32Array(_))}}if(b&&n.gl.uniform2i(b,h.texData.texShape[0],h.texData.texShape[1]),null!=p){if(h.isUniform){if(Ee(h.shape)<2)n.gl.uniform1f(p,h.uniformValues[0]);else{let _=h.uniformValues;_ instanceof Float32Array||(_=new Float32Array(_)),n.gl.uniform1fv(p,_)}continue}null!=h.texData.slice&&null!=g&&n.gl.uniform1i(g,h.texData.slice.flatOffset),n.setInputMatrixTexture(h.texData.texture.texture,p,d)}}const u=t.outShapeLocation;if(u)switch(r.shape.length){case 1:n.gl.uniform1iv(u,new Int32Array(r.shape));break;case 2:n.gl.uniform2iv(u,new Int32Array(r.shape));break;case 3:n.gl.uniform3iv(u,new Int32Array(r.shape));break;case 4:n.gl.uniform4iv(u,new Int32Array(r.shape))}if(t.outShapeStridesLocation){const d=Wt(r.shape);switch(r.shape.length){case 2:n.gl.uniform1iv(t.outShapeStridesLocation,new Int32Array(d));break;case 3:n.gl.uniform2iv(t.outShapeStridesLocation,new Int32Array(d));break;case 4:n.gl.uniform3iv(t.outShapeStridesLocation,new Int32Array(d))}}if(t.outTexShapeLocation&&n.gl.uniform2i(t.outTexShapeLocation,r.texData.texShape[0],r.texData.texShape[1]),t.program.customUniforms&&s)for(let d=0;d<t.program.customUniforms.length;++d){const h=t.program.customUniforms[d],p=t.customUniformLocations[d],g=s[d];if("float"===h.type)n.gl.uniform1fv(p,g);else if("vec2"===h.type)n.gl.uniform2fv(p,g);else if("vec3"===h.type)n.gl.uniform3fv(p,g);else if("vec4"===h.type)n.gl.uniform4fv(p,g);else if("int"===h.type)n.gl.uniform1iv(p,g);else if("ivec2"===h.type)n.gl.uniform2iv(p,g);else if("ivec3"===h.type)n.gl.uniform3iv(p,g);else{if("ivec4"!==h.type)throw Error(`uniform type ${h.type} is not supported yet.`);n.gl.uniform4iv(p,g)}}n.executeProgram()}(this.gpgpu,_,g,y,o),p.forEach(O=>this.disposeIntermediateTensorInfo(O)),I&&(S=this.endTimer(S),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(S)}));const T=Q().getNumber("WEBGL_FLUSH_THRESHOLD");if(T>0){const O=Oo();O-this.lastGlFlushTime>T&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=O)}if(!Q().getBool("WEBGL_LAZILY_UNPACK")&&h.isPacked&&!1===l){const O=this.unpackTensor(d);return this.disposeIntermediateTensorInfo(d),O}return d}compileAndRun(e,r,s,o,l=!1){return this.runWebGLProgram(e,r,s=s||r[0].dtype,o,l)}getAndSaveBinary(e,r){return e in this.binaryCache||(this.binaryCache[e]=r()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(Q().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(r=>{this.gpgpu.deleteProgram(this.binaryCache[r].webGLProgram),delete this.binaryCache[r]}),this.textureManager.dispose(),null!=this.canvas&&"undefined"!=typeof HTMLCanvasElement&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return null==this.floatPrecisionValue&&(this.floatPrecisionValue=En(()=>{if(!Q().get("WEBGL_RENDER_FLOAT32_ENABLED")){const e=Q().getBool("DEBUG");Q().set("DEBUG",!1);const r=this.abs(xn(1e-8)).dataSync()[0];if(Q().set("DEBUG",e),r>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}uploadToGPU(e){const r=this.texData.get(e),{shape:s,dtype:o,values:l,texture:u,usage:d,isPacked:h}=r;if(null!=u)return;const p=null!=this.activeTimers;let g;p&&(g=Oo());let y=r.texShape;if(null==y&&(y=function Ne(n,t=!1){let e=Q().getNumber("WEBGL_MAX_TEXTURE_SIZE"),r=Q().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");r===1/0&&Q().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(r=e/2),t&&(e*=2,r*=2,1===(n=n.map((u,d)=>d>=n.length-2?xt(n[d]):n[d])).length&&(n=[2,n[0]])),2!==n.length&&(n=St(n).newShape);let s=Ee(n),o=null;n.length<=1&&s<=e?o=[1,s]:2===n.length&&n[0]<=e&&n[1]<=e?o=n:3===n.length&&n[0]*n[1]<=e&&n[2]<=e?o=[n[0]*n[1],n[2]]:3===n.length&&n[0]<=e&&n[1]*n[2]<=e?o=[n[0],n[1]*n[2]]:4===n.length&&n[0]*n[1]*n[2]<=e&&n[3]<=e?o=[n[0]*n[1]*n[2],n[3]]:4===n.length&&n[0]<=e&&n[1]*n[2]*n[3]<=e&&(o=[n[0],n[1]*n[2]*n[3]]);const l=null!=o&&Math.max(...o)>r&&Math.min(...o)<=(t?2:1)&&Math.min(...o)>0;if(null==o||l)if(t){const u=W(n);let d=2,h=2;n.length&&([d,h]=J(n)),s=u*(d/2)*(h/2),o=wr(s).map(p=>2*p)}else o=wr(s);return o}(s,h),r.texShape=y),null!=l){const b=fe(s);let _,I=y[1],S=y[0];const T=l instanceof Uint8Array||l instanceof Uint8ClampedArray;(h||!T)&&([I,S]=td(y[0],y[1])),_=h?new c2(b,T):new IT(b,T);const O=T?[S,I]:y,V=this.makeTensorInfo(O,o),U=this.texData.get(V.dataId);U.usage=T?eo.PIXELS:eo.UPLOAD,U.texShape=O,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(V.dataId),I,S,l);const se=this.runWebGLProgram(_,[V],o,[[S,I]],!0),le=this.texData.get(se.dataId);r.texShape=le.texShape,r.isPacked=le.isPacked,r.usage=le.usage,Q().get("ENGINE_COMPILE_ONLY")?this.disposeData(se.dataId):(r.texture=le.texture,r.values=null,this.texData.delete(se.dataId)),this.disposeIntermediateTensorInfo(V),p&&(this.uploadWaitMs+=Oo()-g)}else{const b=this.acquireTexture(y,d,o,h);r.texture=b}}convertAndCacheOnCPU(e,r){const s=this.texData.get(e),{dtype:o}=s;return null!=r&&(s.values=function eF(n,t){if("float32"===t||"complex64"===t)return n;if("int32"===t||"bool"===t){const e="int32"===t?new Int32Array(n.length):new Uint8Array(n.length);for(let r=0;r<e.length;++r)e[r]=Math.round(n[r]);return e}throw new Error(`Unknown dtype ${t}`)}(r,o)),s.values}acquireTexture(e,r,s,o){if(this.numBytesInGPU+=this.computeBytes(e,s),!this.warnedAboutMemory&&this.numBytesInGPU>1024*this.numMBBeforeWarning*1024){const l=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${l} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(e,r,o)}computeBytes(e,r){return e[0]*e[1]*Cr(r)}checkCompileCompletion(){for(const[,e]of Object.entries(this.binaryCache))this.checkCompletion_(e)}checkCompileCompletionAsync(){var e=this;return xe(function*(){const r=[];if(e.gpgpu.parallelCompilationExtension){for(const[,s]of Object.entries(e.binaryCache))r.push(e.checkCompletionAsync_(s));return Promise.all(r)}for(const[,s]of Object.entries(e.binaryCache)){const o=new Promise(l=>{try{e.checkCompletion_(s),l(!0)}catch(u){throw u}});r.push(o)}return Promise.all(r)})()}checkCompletionAsync_(e){var r=this;return xe(function*(){return r.gpgpu.gl.getProgramParameter(e.webGLProgram,r.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?r.checkCompletion_(e):(yield function $S(){return new Promise(n=>FS(()=>n()))}(),r.checkCompletionAsync_(e))})()}checkCompletion_(e){if(!1===this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.gl.LINK_STATUS))throw console.log(this.gpgpu.gl.getProgramInfoLog(e.webGLProgram)),!1===this.gpgpu.gl.getShaderParameter(e.fragmentShader,this.gpgpu.gl.COMPILE_STATUS)?(X_(e.source,this.gpgpu.gl.getShaderInfoLog(e.fragmentShader)),new Error("Failed to compile fragment shader.")):new Error("Failed to link vertex and fragment shaders.");return!0}getUniformLocations(){for(const e of Object.values(this.binaryCache)){this.gpgpu.buildVao(e.webGLProgram);const{variablesLocations:r,customUniformLocations:s,infLoc:o,nanLoc:l,outShapeLocation:u,outShapeStridesLocation:d,outTexShapeLocation:h}=ST(this.gpgpu,e.program,e.webGLProgram);e.variablesLocations=r,e.customUniformLocations=s,e.infLoc=o,e.nanLoc=l,e.outShapeLocation=u,e.outShapeStridesLocation=d,e.outTexShapeLocation=h}}createTensorFromGPUData(e,r,s){e.channels=e.channels||"RGBA";const{texture:o,height:l,width:u,channels:d}=e,h=Qi().backend;if(!h.gpgpu.gl.isTexture(o))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");const p=h.writeTexture(o,r,s,l,u,d);return Qi().makeTensorFromDataId(p,r,s,h)}}return n.nextDataId=0,n})();zp()&&Ux("webgl",()=>new JO,2);class Ih{constructor(t,e,r){this.variableNames=["A","B"],this.outputShape=Nn(e,r),this.enableShapeUniforms=to(this.outputShape.length),this.userCode=`\n      float binaryOperation(float a, float b) {\n        ${t}\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    `}}const Dh="\n  result.r = isNaN.r ? NAN : result.r;\n  result.g = isNaN.g ? NAN : result.g;\n  result.b = isNaN.b ? NAN : result.b;\n  result.a = isNaN.a ? NAN : result.a;\n";class wp{constructor(t,e,r,s=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=Nn(e,r);const o=this.outputShape.length;this.enableShapeUniforms=to(o);let l="";if(s)if(0===o||1===Ee(this.outputShape))l="\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        ";else if(l=`\n          ${ir(o)} coords = getOutputCoords();\n        `,1===o)l+=this.enableShapeUniforms?"\n            result.y = (coords + 1) >= outShape ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          ":`\n            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          `;else{const d=yo("coords",o);l+=this.enableShapeUniforms?`\n            bool nextRowOutOfBounds =\n              (${d[o-2]} + 1) >= outShape[${o} - 2];\n            bool nextColOutOfBounds =\n              (${d[o-1]} + 1) >= outShape[${o} - 1];\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `:`\n            bool nextRowOutOfBounds =\n              (${d[o-2]} + 1) >= ${this.outputShape[o-2]};\n            bool nextColOutOfBounds =\n              (${d[o-1]} + 1) >= ${this.outputShape[o-1]};\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `}this.userCode=`\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        ${t}\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        ${l}\n\n        setOutput(result);\n      }\n    `}}function ui(n){const{inputs:t,backend:e}=n,{x:r}=t;return e.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}const nF={kernelName:Vi,backendName:"webgl",kernelFunc:ui};function id(n){const{inputs:t,backend:e}=n,{real:r,imag:s}=t,o=e.makeTensorInfo(r.shape,"complex64"),l=e.texData.get(o.dataId),u=ui({inputs:{x:r},backend:e}),d=ui({inputs:{x:s},backend:e});return l.complexTensorInfos={real:u,imag:d},o}const rF={kernelName:So,backendName:"webgl",kernelFunc:id},BN="return (a < 0.) ? b * a : a;",VN="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n",oF={kernelName:pi,backendName:"webgl",kernelFunc:function sF(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{alpha:o}=r,l=e.makeTensorInfo([],"float32",_i(o,"float32")),u=Q().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new wp(VN,s.shape,l.shape):new Ih(BN,s.shape,l.shape),d=e.runWebGLProgram(u,[s,l],"float32");return e.disposeIntermediateTensorInfo(l),d}},UN="return (a < 0.) ? b * a : a;",zN="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n",aF={kernelName:Nr,backendName:"webgl",kernelFunc:function iF(n){const{inputs:t,backend:e}=n,{x:r,alpha:s}=t,o=Q().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new wp(zN,r.shape,s.shape):new Ih(UN,r.shape,s.shape);return e.runWebGLProgram(o,[r,s],"float32")}};function Ln({opSnippet:n,packedOpSnippet:t,cpuKernelImpl:e,dtype:r}){return({inputs:s,backend:o})=>{const{x:l}=s,u=o,d=r||l.dtype;if(u.shouldExecuteOnCPU([l])&&null!=e){const g=u.texData.get(l.dataId),y=e(g.values,d);return u.makeTensorInfo(l.shape,d,y)}let p;return p=Q().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&null!=t?new od(l.shape,t):new Yl(l.shape,n),u.runWebGLProgram(p,[l],d)}}function Ws({opSnippet:n,packedOpSnippet:t,checkOutOfBounds:e=!1,supportsComplex:r=!1,cpuKernelImpl:s,dtype:o}){return({inputs:l,backend:u})=>{const{a:d,b:h}=l,p=u;if(r&&"complex64"===d.dtype){const _=p.texData.get(d.dataId),I=p.texData.get(h.dataId),[S,T]=[[_.complexTensorInfos.real,I.complexTensorInfos.real],[_.complexTensorInfos.imag,I.complexTensorInfos.imag]].map(V=>{const[U,j]=V,te={dataId:U.dataId,dtype:U.dtype,shape:d.shape},se={dataId:j.dataId,dtype:j.dtype,shape:h.shape},le=new Ih(n,d.shape,h.shape);return p.runWebGLProgram(le,[te,se],ye(U.dtype,j.dtype))}),O=id({inputs:{real:S,imag:T},backend:p});return p.disposeIntermediateTensorInfo(S),p.disposeIntermediateTensorInfo(T),O}const g=o||ye(d.dtype,h.dtype);if(("string"===d.dtype||"string"===h.dtype||p.shouldExecuteOnCPU([d,h]))&&null!=s){const _=p.texData.get(d.dataId).values,I=p.texData.get(h.dataId).values,S="string"===d.dtype?po(_):_,T="string"===d.dtype?po(I):I,[O,V]=s(d.shape,h.shape,S,T,g),U=p.makeTensorInfo(V,g);return p.texData.get(U.dataId).values=O,U}let b;return b=Q().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&null!=t?new wp(t,d.shape,h.shape,e):new Ih(n,d.shape,h.shape),p.runWebGLProgram(b,[d,h],g)}}function Oy(n,t=!1){if("linear"===n)return"return x;";if("relu"===n)return t?"\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n":"if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : x;\n";if("elu"===n)return t?"\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n":"return (x >= 0.0) ? x : (exp(x) - 1.0);";if("relu6"===n)return t?"\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n":"if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n";if("prelu"===n)return t?zN:UN;if("leakyrelu"===n)return t?VN:BN;if("sigmoid"===n)return"return 1.0 / (1.0 + exp(-1.0 * x));";throw new Error(`Activation ${n} has not been implemented for the WebGL backend.`)}class HN{constructor(t,e,r,s=!1,o=!1,l=!1,u=null,d=!1,h=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=r,this.enableShapeUniforms=to(this.outputShape.length);const g=Math.ceil((s?t[1]:t[2])/2),y=s?"i * 2, rc.y":"rc.y, i * 2",b=o?"rc.z, i * 2":"i * 2, rc.z",_=s?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],I=o?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let S="",T="";u&&(S=d?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${u}\n        }`:h?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${u}\n        }`:`vec4 activation(vec4 x) {\n          ${u}\n        }`,T="result = activation(result);");const O=l?"result += getBiasAtOutCoords();":"";l&&this.variableNames.push("bias"),d&&this.variableNames.push("preluActivationWeights"),h&&this.variableNames.push("leakyreluAlpha");let V="rc.x",U="rc.x";t[0]<e[0]?V=`imod(rc.x, ${t[0]})`:e[0]<t[0]&&(U=`imod(rc.x, ${e[0]})`),this.userCode=`\n      ${S}\n      // Don't use uniform for sharedDimensionPacked for performance.\n      const float sharedDimension = ${g}.0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        int batchA = ${V};\n        int batchB = ${U};\n        for (int i = 0; i < ${g}; i++) {\n          vec4 a = getMatrixA(batchA, ${y});\n          vec4 b = getMatrixB(batchB, ${b});\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += (${_[0]} * ${I[0]});\n          result += (${_[1]} * ${I[1]});\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        ${O}\n\n        ${T}\n\n        setOutput(result);\n      }\n    `}}class jN{constructor(t,e,r){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=Nn(e,r),this.userCode=`\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        ${t}\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    `}}const GN="return a * b;";function UE(n){const{inputs:t,backend:e}=n,{a:r,b:s}=t,o=ye(r.dtype,s.dtype);if("complex64"===r.dtype){const u=e.texData.get(r.dataId),d=e.texData.get(s.dataId),h=new jN("return areal * breal - aimag * bimag;",r.shape,s.shape),p=new jN("return areal * bimag + aimag * breal;",r.shape,s.shape),g=[{dataId:u.complexTensorInfos.real.dataId,dtype:u.complexTensorInfos.real.dtype,shape:r.shape},{dataId:u.complexTensorInfos.imag.dataId,dtype:u.complexTensorInfos.imag.dtype,shape:r.shape},{dataId:d.complexTensorInfos.real.dataId,dtype:d.complexTensorInfos.real.dtype,shape:s.shape},{dataId:d.complexTensorInfos.imag.dataId,dtype:d.complexTensorInfos.imag.dtype,shape:s.shape}],y=e.runWebGLProgram(h,g,"float32"),b=e.runWebGLProgram(p,g,"float32"),_=id({inputs:{real:y,imag:b},backend:e});return e.disposeIntermediateTensorInfo(y),e.disposeIntermediateTensorInfo(b),_}if(e.shouldExecuteOnCPU([r,s])){const u=e.texData.get(r.dataId),d=e.texData.get(s.dataId),[h,p]=sO(r.shape,s.shape,u.values,d.values,o),g=e.makeTensorInfo(p,o);return e.texData.get(g.dataId).values=h,g}let l;return l=Q().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new wp(GN,r.shape,s.shape):new Ih(GN,r.shape,s.shape),e.runWebGLProgram(l,[r,s],o)}const lF={kernelName:pl,backendName:"webgl",kernelFunc:UE};function Mt(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{shape:o}=r,l=e,u=Ee(s.shape),d=Dr(o,u),h=Ee(d);G(u===h,()=>`The new shape (${d}) has ${h} elements and the old shape (${s.shape}) has ${u} elements. The new shape and old shape must have the same number of elements.`);const p=l.texData.get(s.dataId);return!p.isPacked||mt(s.shape,d)||null!==p.texture&&mt(p.shape,d)?(l.incRef(s.dataId),{dataId:s.dataId,shape:d,dtype:s.dtype}):function cF(n,t,e){const r=[W(n.shape),...J(n.shape)],s={dtype:n.dtype,shape:r,dataId:n.dataId},o=[W(t),...J(t)],l=new ON(o,r),h=e.runWebGLProgram(l,[s],n.dtype,[r],!0);return{dataId:h.dataId,shape:t,dtype:h.dtype}}(s,d,l)}const uF={kernelName:gi,backendName:"webgl",kernelFunc:Mt};class KN{constructor(t,e){this.variableNames=["x"];const{windowSize:r,batchSize:s,inSize:o,outSize:l}=t;this.outputShape=[s,l];const u=4*Math.floor(r/4),d=r%4;let h="sumValue += dot(values, ones);";if(null!=e){const g=1/e;h=`sumValue += dot(values * ${kn(g)?g.toPrecision(2):g}, ones);`}let p="";o%r>0&&(p=`\n        if (inIdx < 0 || inIdx >= ${o}) {\n          return 0.0;\n        }\n      `),this.userCode=`\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${p}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${r};\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${u}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${h}\n        }\n\n        int inIdx = inOffset + ${u};\n        if (${1===d}) {\n          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);\n\n          ${h}\n        } else if (${2===d}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1), 0.0, 0.0);\n\n          ${h}\n        } else if (${3===d}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2), 0.0);\n\n          ${h}\n        }\n        setOutput(sumValue);\n      }\n    `}}class dF{constructor(t,e){this.variableNames=["x"];const{windowSize:r,batchSize:s,inSize:o,outSize:l}=t;this.outputShape=[s,l];let u="0.0",d="";"prod"===e?u="1.0":"min"===e?(u="1.0 / 1e-20",d="min"):"max"===e&&(u="-1.0 / 1e-20",d="max");let h=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"sum"===e?h="sumValue":"prod"===e?h="prodValue":"all"===e?h="allValue":"any"===e&&(h="anyValue");const p=4*Math.floor(r/4),g=r%4;let y=`\n      if (${"sum"===e}) {\n        sumValue += dot(values, ones);\n      } else if (${"prod"===e}) {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = ${d}(values, minMaxValue);\n        if (${"min"===e} || ${"max"===e}) {\n          minMaxValue = ${d}(values, minMaxValue);\n          bvec4 isNaN = isnan(values);\n          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {\n            minMaxValue = vec4(NAN);\n          }\n        }\n      }\n    `,b="vec4";"all"===e?(u="1.0",y="\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      ",b="bvec4"):"any"===e&&(u="0.0",y="\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      ",b="bvec4");let _="";o%r>0&&(_=`\n        if (inIdx < 0 || inIdx >= ${o}) {\n          return initializationValue;\n        }\n      `),this.userCode=`\n      const float initializationValue = ${u};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${_}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${r};\n\n        vec4 minMaxValue = vec4(${u});\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < ${p}; i += 4) {\n          int inIdx = inOffset + i;\n          ${b} values = ${b}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${y}\n        }\n\n        int inIdx = inOffset + ${p};\n        if (${1===g}) {\n          ${b} values = ${b}(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          ${y}\n        } else if (${2===g}) {\n          ${b} values = ${b}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          ${y}\n        } else if (${3===g}) {\n          ${b} values = ${b}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          ${y}\n        }\n        setOutput(${h});\n      }\n    `}}function Th(n,t,e,r){const s=function hF(n){const t=[];for(;0===t.length||1!==t[t.length-1].outSize;){const e=t.length?t[t.length-1].outSize:n[1],r=jf(e);t.push({inSize:e,windowSize:r,outSize:Math.ceil(e/r)})}return t}(n.shape);let o=n;for(let l=0;l<s.length;l++){const{inSize:u,windowSize:d,outSize:h}=s[l];let p,g;p="mean"===e?0===l?new KN({windowSize:d,inSize:u,batchSize:n.shape[0],outSize:h},u):new KN({windowSize:d,inSize:u,batchSize:n.shape[0],outSize:h}):new dF({windowSize:d,inSize:u,batchSize:n.shape[0],outSize:h},e),g=o,o=r.runWebGLProgram(p,[o],t),g.dataId!==n.dataId&&r.disposeIntermediateTensorInfo(g)}return o}class fF{constructor(t,e){this.variableNames=["A"];const r=new Array(t.length);for(let l=0;l<r.length;l++)r[l]=t[e[l]];this.outputShape=r,this.rank=r.length;const s=ir(this.rank),o=function pF(n){const t=n.length;if(t>6)throw Error(`Transpose for rank ${t} is not yet supported`);const e=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],r=new Array(t);for(let s=0;s<n.length;s++)r[n[s]]=e[s];return r.join()}(e);this.userCode=`\n    void main() {\n      ${s} resRC = getOutputCoords();\n      setOutput(getA(${o}));\n    }\n    `}}class mF{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const r=new Array(t.length);for(let p=0;p<r.length;p++)r[p]=t[e[p]];if(this.outputShape=r,this.rank=r.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const s=ir(this.rank),o=MN("rc",this.rank),l=new Array(this.rank);for(let p=0;p<e.length;p++)l[e[p]]=o[p];const u=`vec2(${l.slice(-2).join()})`,d=`++${o[this.rank-1]} < ${r[this.rank-1]}`,h=`getChannel(getA(${l.join()}), ${u})`;this.userCode=`\n    void main() {\n      ${s} rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = ${h};\n      if(${d}) {\n        result[1] = ${h};\n      }\n      --${o[this.rank-1]};\n      if(++${o[this.rank-2]} < ${r[this.rank-2]}) {\n        result[2] = ${h};\n        if(${d}) {\n          result[3] = ${h};\n        }\n      }\n      setOutput(result);\n    }\n    `}}function rx(n,t,e){const r=Q().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new mF(n.shape,t):new fF(n.shape,t);return e.runWebGLProgram(r,[n],n.dtype)}function sx(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:o,keepDims:l}=r;return function gF(n,t,e,r){const o=n.shape.length,l=Tt(t,n.shape);let u=l;const d=pr(u,o),h=null!=d;let p=n;h&&(p=rx(n,d,r),u=_r(u.length,o)),_s("sum",u,o);const[g,y]=as(p.shape,u);let b=g;e&&(b=Yr(g,l));const _=Ee(y),T=Mt({inputs:{x:p},attrs:{shape:[Ee(n.shape)/_,_]},backend:r}),V=Th(T,lt(n.dtype),"sum",r),U=Mt({inputs:{x:V},attrs:{shape:b},backend:r});return r.disposeIntermediateTensorInfo(T),r.disposeIntermediateTensorInfo(V),h&&r.disposeIntermediateTensorInfo(p),U}(s,o,l,e)}const yF={kernelName:"Sum",backendName:"webgl",kernelFunc:sx};function vo(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{perm:o}=r,l=e,d=new Array(s.shape.length);for(let p=0;p<d.length;p++)d[p]=s.shape[o[p]];let h;if(l.shouldExecuteOnCPU([s])){const g=l.texData.get(s.dataId).values,y=BE(g,s.shape,s.dtype,o,d);h=l.makeTensorInfo(d,s.dtype),l.texData.get(h.dataId).values=y}else h=rx(s,o,l);return h}const vF={kernelName:Ps,backendName:"webgl",kernelFunc:vo};function ox({a:n,b:t,transposeA:e,transposeB:r,backend:s,bias:o=null,preluActivationWeights:l=null,leakyreluAlpha:u=0,activation:d=null}){const h=n.shape.length,p=t.shape.length,g=e?n.shape[h-2]:n.shape[h-1],y=r?t.shape[p-1]:t.shape[p-2],b=e?n.shape[h-1]:n.shape[h-2],_=r?t.shape[p-2]:t.shape[p-1],I=n.shape.slice(0,-2),S=t.shape.slice(0,-2),T=Ee(I),O=Ee(S),U=Nn(n.shape.slice(0,-2),t.shape.slice(0,-2)).concat([b,_]);G(g===y,()=>`Error in matMul: inner shapes (${g}) and (${y}) of Tensors with shapes ${n.shape} and ${t.shape} and transposeA=${e} and transposeB=${r} must match.`);const j=e?[T,g,b]:[T,b,g],te=r?[O,_,y]:[O,y,_],se=Mt({inputs:{x:n},backend:s,attrs:{shape:j}}),le=Mt({inputs:{x:t},backend:s,attrs:{shape:te}}),Ce=[se,le],be=Math.max(T,O),Me=e?se.shape[1]:se.shape[2],He=null!=o,We=null!=l,je="leakyrelu"===d,Ke=null!=d?Oy(d,!0):null;let ke;if((1===b||1===_)&&Me>1e3&&!1===(He||We||je||null!=Ke)){let Be=se,rt=le;e&&(Be=vo({inputs:{x:se},backend:s,attrs:{perm:[0,2,1]}}),Ce.push(Be)),r&&(rt=vo({inputs:{x:le},backend:s,attrs:{perm:[0,2,1]}}),Ce.push(rt));const wt=1===_;let gt=Be;1!==_&&(gt=Mt({inputs:{x:Be},backend:s,attrs:{shape:[be,Me,1]}}),Ce.push(gt));const yt=1===_?2:1;let It=rt;wt&&(It=Mt({inputs:{x:rt},backend:s,attrs:{shape:[be,1,Me]}}),Ce.push(It));const zt=UE({inputs:{a:gt,b:It},backend:s});ke=sx({inputs:{x:zt},backend:s,attrs:{axis:yt,keepDims:!0}}),Ce.push(zt)}else{const Be=ye(n.dtype,t.dtype),rt=new HN(j,te,[be,b,_],e,r,He,Ke,We,je),pt=[se,le];if(null!=o&&pt.push(o),We&&pt.push(l),je){const wt=s.makeTensorInfo([],"float32",_i(u,"float32"));pt.push(wt),Ce.push(wt)}ke=s.runWebGLProgram(rt,pt,Be)}const De=Mt({inputs:{x:ke},backend:s,attrs:{shape:U}});Ce.push(ke);for(const Be of Ce)s.disposeIntermediateTensorInfo(Be);return De}const _F={kernelName:pc,backendName:"webgl",kernelFunc:function bF(n){const{inputs:t,backend:e,attrs:r}=n,{a:s,b:o,bias:l,preluActivationWeights:u}=t,{transposeA:d,transposeB:h,activation:p,leakyreluAlpha:g}=r;return ox({a:s,b:o,transposeA:d,transposeB:h,backend:e,bias:l,preluActivationWeights:u,leakyreluAlpha:g,activation:p})}},XN="return abs(x);",wF={kernelName:"Abs",backendName:"webgl",kernelFunc:function xF(n){const{inputs:t,backend:e}=n,{x:r}=t;if(e.shouldExecuteOnCPU([r])&&"complex64"!==r.dtype){const o=e.texData.get(r.dataId),l=AN(o.values);return e.makeTensorInfo(r.shape,r.dtype,l)}let s;return s=Q().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new od(r.shape,XN):new Yl(r.shape,XN),e.runWebGLProgram(s,[r],r.dtype)}},SF=Ln({opSnippet:"if (isnan(x)) return x;\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n"}),EF={kernelName:lr,backendName:"webgl",kernelFunc:SF},DF=Ln({opSnippet:"if (isnan(x)) return x;\n  if (x < 1.0) return NAN;\nreturn log(x + sqrt(x * x - 1.0));"}),TF={kernelName:As,backendName:"webgl",kernelFunc:DF},YN="return a + b;",NF=Ws({opSnippet:YN,packedOpSnippet:YN,supportsComplex:!0,cpuKernelImpl:PM}),kF={kernelName:Rs,backendName:"webgl",kernelFunc:NF};class AF{constructor(t,e){this.outputShape=[],this.outputShape=t,this.variableNames=e.map((o,l)=>`T${l}`);const r=[];this.variableNames.forEach(o=>{r.push(`float v${o} = get${o}AtOutCoords();`)});const s=this.variableNames.map(o=>`v${o}`).join(" + ");this.userCode=`\n      void main() {\n        ${r.join("\n        ")}\n\n        float result = ${s};\n        setOutput(result);\n      }\n    `}}class RF{constructor(t,e){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.variableNames=e.map((o,l)=>`T${l}`);const r=[];this.variableNames.forEach(o=>{r.push(`vec4 v${o} = get${o}AtOutCoords();`)});const s=this.variableNames.map(o=>`v${o}`).join(" + ");this.userCode=`\n      void main() {\n        ${r.join("\n        ")}\n\n        vec4 result = ${s};\n        setOutput(result);\n      }\n    `}}const MF={kernelName:Ks,backendName:"webgl",kernelFunc:function ix(n){const{inputs:t,backend:e}=n,r=t;if(1===r.length)return ui({inputs:{x:r[0]},backend:e});if(r.length>Q().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){const d=Math.floor(r.length/2),h=ix({inputs:r.slice(0,d),backend:e}),p=ix({inputs:r.slice(d),backend:e});return ix({inputs:[h,p],backend:e})}const s=r.map(d=>d.dtype).reduce((d,h)=>ye(d,h)),o=r.map(d=>d.shape),u=Q().getBool("WEBGL_PACK")?new RF(r[0].shape,o):new AF(r[0].shape,o);return e.runWebGLProgram(u,r,s)}},FF={kernelName:"All",backendName:"webgl",kernelFunc:function OF(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:o,keepDims:l}=r,u=s.shape.length,d=Tt(o,s.shape);let h=d;const p=pr(h,u);let g=s;null!=p&&(g=vo({inputs:{x:s},backend:e,attrs:{perm:p}}),h=_r(h.length,u)),_s("all",h,u);const[y,b]=as(g.shape,h),I=Mt({inputs:{x:g},backend:e,attrs:{shape:[-1,Ee(b)]}}),S=Th(I,I.dtype,"all",e);let T;return T=Mt(l?{inputs:{x:S},backend:e,attrs:{shape:Yr(y,d)}}:{inputs:{x:S},backend:e,attrs:{shape:y}}),e.disposeIntermediateTensorInfo(I),e.disposeIntermediateTensorInfo(S),null!=p&&e.disposeIntermediateTensorInfo(g),T}},PF={kernelName:"Any",backendName:"webgl",kernelFunc:function $F(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:o,keepDims:l}=r,u=s.shape.length,d=Tt(o,s.shape);let h=d;const p=pr(h,u);let g=s;null!=p&&(g=vo({inputs:{x:s},backend:e,attrs:{perm:p}}),h=_r(h.length,u)),_s("any",h,u);const[y,b]=as(g.shape,h),I=Mt({inputs:{x:g},backend:e,attrs:{shape:[-1,Ee(b)]}}),S=Th(I,I.dtype,"any",e);let T;return T=Mt(l?{inputs:{x:S},backend:e,attrs:{shape:Yr(y,d)}}:{inputs:{x:S},backend:e,attrs:{shape:y}}),e.disposeIntermediateTensorInfo(I),e.disposeIntermediateTensorInfo(S),null!=p&&e.disposeIntermediateTensorInfo(g),T}};class LF{constructor(t,e,r){this.variableNames=["A"];const{windowSize:s,batchSize:o,outSize:l}=t;r||this.variableNames.push("bestIndicesA"),this.outputShape=[o,l],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${s};\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < ${s}; i++) {\n          int inIdx = ${r?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));"};\n          float candidate = getA(batch, inIdx);\n          if (candidate ${"max"===e?">":"<"} bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    `}}class BF{constructor(t,e,r,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,G(t.length>2,()=>`Packed arg${r.charAt(0).toUpperCase()+r.slice(1)} supports only inputs with rank above 2.`);const l=Math.ceil(t[t.length-1]/e);this.outputShape=t.slice(0,-1),l>1&&this.outputShape.push(l),s||this.variableNames.push("bestIndicesA");const u=this.outputShape,d=u.length,h=ir(d),p=yo("coords",d);let g,y;if(1===l){y=d+1;const le=ir(y);g=`\n        ${le} sourceLocR = ${le}(${p.join()}, 0);\n        ++${p[d-1]};\n        ${le} sourceLocG = ${le}(${p.join()}, 0);\n        ++${p[d-2]};\n        ${le} sourceLocA = ${le}(${p.join()}, 0);\n        --${p[d-1]};\n        ${le} sourceLocB = ${le}(${p.join()}, 0);\n        --${p[d-2]};`}else y=d,g=`\n        ${h} sourceLocR = coords;\n        ++${p[d-1]};\n        ${h} sourceLocG = coords;\n        ++${p[d-2]};\n        ${h} sourceLocA = coords;\n        --${p[d-1]};\n        ${h} sourceLocB = coords;\n        --${p[d-2]};`;const b=["x","y","z","w","u","v"].slice(0,y),_="."+b[y-1],I=b.map(le=>"int "+le),S=yo("sourceLocR",y-1).concat("inIdx.r"),T=yo("sourceLocG",y-1).concat("inIdx.g"),O=yo("sourceLocB",y-1).concat("inIdx.b"),V=yo("sourceLocA",y-1).concat("inIdx.a"),U="max"===r?"greaterThan":"lessThan",j=s?"":`\n          inIdx = round(vec4(getBestIndicesAChannel(${S.join()}),\n                             getBestIndicesAChannel(${T.join()}),\n                             getBestIndicesAChannel(${O.join()}),\n                             getBestIndicesAChannel(${V.join()})));`,te=`vec4(\n            getAChannel(${S.join()}),\n            hasNextCol ? getAChannel(${T.join()}) : 0.,\n            hasNextRow ? getAChannel(${O.join()}) : 0.,\n            hasNextRow && hasNextCol ? getAChannel(${V.join()}) : 0.)`,se=s?"":`\n      float getBestIndicesAChannel(${I.join()}) {\n        return getChannel(getBestIndicesA(${b.join()}),\n                                          vec2(${b.slice(-2).join()}));\n      }`;this.userCode=`\n      float getAChannel(${I.join()}) {\n        return getChannel(getA(${b.join()}),\n                               vec2(${b.slice(-2).join()}));\n      }\n      ${se}\n      void main() {\n        ${h} coords = getOutputCoords();\n        bool hasNextCol = ${p[d-1]} < ${u[d-1]-1};\n        bool hasNextRow = ${p[d-2]} < ${u[d-2]-1};\n        ${g}\n        ivec4 srcIdx = ivec4(sourceLocR${_}, sourceLocG${_},\n          sourceLocB${_}, sourceLocA${_}) * ${e};\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = ${te};\n\n        for (int i = 0; i < ${e}; i++) {\n          inIdx = srcIdx;\n          ${j}\n          vec4 candidate = ${te};\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4(${U}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    `}}function ZN(n,t,e,r=null){let s=t.shape[0],o=t.shape[1];null!=r&&(s=r.shape[0],o=r.shape[1]);const l=jf(o),u={windowSize:l,inSize:o,batchSize:s,outSize:Math.ceil(o/l)},d=new LF(u,e,null==r),h=[t];null!=r&&h.push(r);const p=n.runWebGLProgram(d,h,"int32");if(1===p.shape[1])return p;const g=ZN(n,t,e,p);return n.disposeIntermediateTensorInfo(p),g}function QN(n,t,e,r=null){const s=null!=r?r.shape:t.shape,l=jf(s[s.length-1]),u=new BF(s,l,e,null==r),h=n.runWebGLProgram(u,null==r?[t]:[t,r],"int32");if(h.shape.length===t.shape.length){const p=QN(n,t,e,h);return n.disposeIntermediateTensorInfo(h),p}return h}function JN(n,t,e,r){const s=[e];if(_s("arg"+r.charAt(0).toUpperCase()+r.slice(1),s,t.shape.length),!Q().getBool("WEBGL_PACK_REDUCE")||t.shape.length<=2){const o=[],l=n.texData.get(t.dataId);let d=t;null!==l&&l.isPacked&&(d=n.unpackTensor(t),o.push(d));const[h,p]=as(d.shape,s),g=Ee(p),y=Mt({inputs:{x:d},backend:n,attrs:{shape:[-1,g]}});o.push(y);const b=ZN(n,y,r);o.push(b);const _=Mt({inputs:{x:b},backend:n,attrs:{shape:h}});return o.forEach(I=>n.disposeIntermediateTensorInfo(I)),_}return QN(n,t,r)}const UF={kernelName:Lr,backendName:"webgl",kernelFunc:function VF(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:o}=r;let l=Tt(o,s.shape);const u=pr(l,s.shape.length);let d=s;const h=[];null!=u&&(d=vo({inputs:{x:s},backend:e,attrs:{perm:u}}),h.push(d),l=_r(l.length,d.shape.length)),_s("argMax",[l[0]],d.shape.length);const p=JN(e,d,l[0],"max");return h.forEach(g=>e.disposeIntermediateTensorInfo(g)),p}},HF={kernelName:kt,backendName:"webgl",kernelFunc:function zF(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:o}=r;let l=Tt(o,s.shape);const u=pr(l,s.shape.length);let d=s;const h=[];null!=u&&(d=vo({inputs:{x:s},backend:e,attrs:{perm:u}}),h.push(d),l=_r(l.length,d.shape.length)),_s("argMin",[l[0]],d.shape.length);const p=JN(e,d,l[0],"min");return h.forEach(g=>e.disposeIntermediateTensorInfo(g)),p}},jF=Ln({opSnippet:"if (isnan(x)) return x;\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n"}),GF={kernelName:an,backendName:"webgl",kernelFunc:jF},qF=Ln({opSnippet:"if (isnan(x)) return x;return log(x + sqrt(x * x + 1.0));"}),XF={kernelName:Bn,backendName:"webgl",kernelFunc:qF},ZF=Ln({opSnippet:"if (isnan(x)) return x;\n  return atan(x);\n"}),QF={kernelName:Wr,backendName:"webgl",kernelFunc:ZF},t$=Ws({opSnippet:"\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return atan(a, b);\n",packedOpSnippet:"\n  vec4 result = atan(a, b);\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  \n  result.r = isNaN.r ? NAN : result.r;\n  result.g = isNaN.g ? NAN : result.g;\n  result.b = isNaN.b ? NAN : result.b;\n  result.a = isNaN.a ? NAN : result.a;\n\n  return result;\n"}),n$={kernelName:tr,backendName:"webgl",kernelFunc:t$},s$=Ln({opSnippet:"if (isnan(x)) return x;\n  if ((x < -1.0) || (x > 1.0)) return NAN;\nreturn (log(1.0 + x) - log(1.0 - x)) / 2.0;"}),o$={kernelName:xo,backendName:"webgl",kernelFunc:s$};class Fy{constructor(t,e,r,s=!1,o=!1){if(this.variableNames=["x"],"avg"===e&&r)throw new Error("Cannot compute positions for average pool.");const l=t.filterWidth,u=t.strideHeight,d=t.strideWidth,h=t.dilationHeight,p=t.dilationWidth,g=t.effectiveFilterHeight,y=t.effectiveFilterWidth,b=t.padInfo.top,_=t.padInfo.left;this.outputShape=t.outShape;const I="avg"===e;let O="0.0";if(I||(O="-1.0 / 1e-20"),r)return void(this.userCode=`\n        const ivec2 strides = ivec2(${u}, ${d});\n        const ivec2 pads = ivec2(${b}, ${_});\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < ${g};\n              wR += ${h}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${y};\n                wC += ${p}) {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= ${t.inWidth}) {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value >= currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = ${s?o?`((batch  * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + d`:`(xR * ${t.inWidth} + xC) * ${t.inChannels} + d`:`wR * ${y} + wC`};\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `);let U=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===e&&(U="avgValue / max(count, 1.0)");const j=4*Math.floor(l/4),te=l%4,se=`\n      if (${I}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec2 strides = ivec2(${u}, ${d});\n      const ivec2 pads = ivec2(${b}, ${_});\n      const float initializationValue = ${O};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= ${t.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${O});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < ${g};\n            wR += ${h}) {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= ${t.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${j}; wC += 4) {\n            int xC = xCCorner + wC * ${p};\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${p}, d),\n              getValue(batch, xR, xC + 2 * ${p}, d),\n              getValue(batch, xR, xC + 3 * ${p}, d)\n            );\n\n            ${se}\n          }\n\n          int xC = xCCorner + ${j};\n          if (${1===te}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            ${se}\n          } else if (${2===te}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${p}, d),\n              initializationValue,\n              initializationValue\n            );\n\n            ${se}\n          } else if (${3===te}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${p}, d),\n              getValue(batch, xR, xC + 2 * ${p}, d),\n              initializationValue\n            );\n\n            ${se}\n          }\n        }\n        setOutput(${U});\n      }\n    `}}class zE{constructor(t,e,r,s=!1,o=!1){if(this.variableNames=["x"],"avg"===e&&r)throw new Error("Cannot compute positions for average pool.");const l=t.filterWidth,u=t.strideDepth,d=t.strideHeight,h=t.strideWidth,p=t.dilationDepth,g=t.dilationHeight,y=t.dilationWidth,b=t.effectiveFilterDepth,_=t.effectiveFilterHeight,I=t.effectiveFilterWidth,S=t.padInfo.front,T=t.padInfo.top,O=t.padInfo.left;this.outputShape=t.outShape;const V="avg"===e;let U="0.0";if(V||(U="-1.0 / 1e-20"),r)return void(this.userCode=`\n        const ivec3 strides =\n            ivec3(${u}, ${d}, ${h});\n        const ivec3 pads = ivec3(${S}, ${T}, ${O});\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < ${b};\n              wD += ${p}) {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= ${t.inDepth}) {\n              continue;\n            }\n\n            for (int wR = 0; wR < ${_};\n                wR += ${g}) {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= ${t.inHeight}) {\n                continue;\n              }\n\n              for (int wC = 0; wC < ${I};\n                  wC += ${y}) {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= ${t.inWidth}) {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value >= currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition = ${s?o?`(((batch * ${t.inDepth} + xD) * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + ch`:`((xD * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + ch`:`wD * ${_} * ${I} +\n                      wR * ${I} + wC`};\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `);let te=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===e&&(te="avgValue / max(count, 1.0)");const se=4*Math.floor(l/4),le=l%4,Ce=`\n      if (${V}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec3 strides =\n        ivec3(${u}, ${d}, ${h});\n      const ivec3 pads = ivec3(${S}, ${T}, ${O});\n      const float initializationValue = ${U};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= ${t.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${U});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < ${b};\n            wD += ${p}) {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= ${t.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${_};\n            wR += ${g}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${se}; wC += 4) {\n              int xC = xCCorner + wC * ${y};\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${y}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${y}, ch),\n                getValue(batch, xD, xR, xC + 3 * ${y}, ch)\n              );\n\n              ${Ce}\n            }\n\n            int xC = xCCorner + ${se};\n            if (${1===le}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              ${Ce}\n            } else if (${2===le}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${y}, ch),\n                initializationValue,\n                initializationValue\n              );\n\n              ${Ce}\n            } else if (${3===le}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${y}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${y}, ch),\n                initializationValue\n              );\n\n              ${Ce}\n            }\n          }\n        }\n        setOutput(${te});\n      }\n    `}}const a$={kernelName:Ms,backendName:"webgl",kernelFunc:function i$(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t;Wc(s,"avgPool");const{filterSize:o,strides:l,pad:u,dimRoundingMode:d}=r;G(Ns(l,1),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${l} and dilations '1'`);const p=$o(s.shape,o,l,1,u,d);if(1===p.filterWidth&&1===p.filterHeight&&un(p.inShape,p.outShape))return ui({inputs:{x:s},backend:e});const g=new Fy(p,"avg",!1);return e.runWebGLProgram(g,[s],"float32")}},c$={kernelName:hs,backendName:"webgl",kernelFunc:function l$(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{filterSize:o,strides:l,pad:u,dimRoundingMode:d,dataFormat:h}=r,g=Ka(s.shape,o,l,[1,1,1],u,d,h),y=new zE(g,"avg",!1);return e.runWebGLProgram(y,[s],"float32")}};class u${constructor(t){this.variableNames=["dy"],this.outputShape=t.inShape;const d=t.effectiveFilterHeight,h=t.effectiveFilterWidth;this.userCode=`\n      const ivec2 pads = ivec2(${d-1-t.padInfo.top}, ${h-1-t.padInfo.left});\n      const float avgMultiplier = float(${1/(t.filterHeight*t.filterWidth)});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${d};\n            wR += ${t.dilationHeight}) {\n          float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${h};\n            wC+= ${t.dilationWidth}) {\n            float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class d${constructor(t){this.variableNames=["dy"],this.outputShape=t.inShape;const g=t.effectiveFilterDepth,y=t.effectiveFilterHeight,b=t.effectiveFilterWidth;this.userCode=`\n      const ivec3 pads = ivec3(${g-1-t.padInfo.front}, ${y-1-t.padInfo.top}, ${b-1-t.padInfo.left});\n      const float avgMultiplier = float(${1/(t.filterDepth*t.filterHeight*t.filterWidth)});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${g};\n            wD += ${t.dilationDepth}) {\n          float dyD = float(dyDCorner + wD) / ${t.strideDepth}.0;\n\n          if (dyD < 0.0 || dyD >= ${t.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${y};\n              wR += ${t.dilationHeight}) {\n            float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${b};\n                wC += ${t.dilationWidth}) {\n              float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const f$={kernelName:wo,backendName:"webgl",kernelFunc:function h$(n){const{inputs:t,backend:e,attrs:r}=n,{dy:s,input:o}=t,l=o,{filterSize:u,strides:d,pad:h,dimRoundingMode:p}=r,y=Ka(l.shape,u,d,[1,1,1],h,p),b=new d$(y);return e.runWebGLProgram(b,[s],l.dtype)}},m$={kernelName:nr,backendName:"webgl",kernelFunc:function p$(n){const{inputs:t,backend:e,attrs:r}=n,{dy:s,input:o}=t,l=o;Wc([s,o],"avgPoolGrad");const{filterSize:u,strides:d,pad:h}=r,p=$o(l.shape,u,d,1,h),g=new u$(p);return e.runWebGLProgram(g,[s],l.dtype)}},y$={kernelName:mn,backendName:"webgl",kernelFunc:function g$(n){const{inputs:t,backend:e,attrs:r}=n,{a:s,b:o}=t,{transposeA:l,transposeB:u}=r;return ox({a:s,b:o,transposeA:l,transposeB:u,backend:e})}};class v${constructor(t,e,r,s,o,l){this.outputShape=[],this.variableNames=["x","mean","variance"],Nn(t,e),Nn(t,r);let u="0.0";null!=s&&(Nn(t,s),this.variableNames.push("offset"),u="getOffsetAtOutCoords()");let d="1.0";null!=o&&(Nn(t,o),this.variableNames.push("scale"),d="getScaleAtOutCoords()"),this.outputShape=t,this.userCode=`\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = ${u};\n        float scale = ${d};\n        float inv = scale * inversesqrt(variance + float(${l}));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    `}}class b${constructor(t,e,r,s,o,l){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],Nn(t,e),Nn(t,r);let u="vec4(0.0)";null!=s&&(Nn(t,s),this.variableNames.push("offset"),u="getOffsetAtOutCoords()");let d="vec4(1.0)";null!=o&&(Nn(t,o),this.variableNames.push("scale"),d="getScaleAtOutCoords()"),this.outputShape=t,this.userCode=`\n      void main() {\n        vec4 offset = ${u};\n        vec4 scale = ${d};\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4(${l}));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    `}}const _$={kernelName:ic,backendName:"webgl",kernelFunc:({inputs:n,backend:t,attrs:e})=>{const{x:r,mean:s,variance:o,offset:l,scale:u}=n;G(s.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),G(null==l||s.shape.length===l.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),G(null==u||s.shape.length===u.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:d}=e;null==d&&(d=.001);const h=[r,s,o];let p=null;null!=l&&(p=l.shape,h.push(l));let g=null;null!=u&&(g=u.shape,h.push(u));const y=Q().getBool("WEBGL_PACK_NORMALIZATION")?new b$(r.shape,s.shape,o.shape,p,g,d):new v$(r.shape,s.shape,o.shape,p,g,d);return t.runWebGLProgram(y,h,h[0].dtype)}};class x${constructor(t){this.variableNames=["source"],this.outputShape=t,this.rank=t.length;const e=ir(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const r=function w$(n){if(1===n)return"sourceLoc";if(n<=6)return HE.slice(0,n).map(t=>"sourceLoc."+t).join(",");throw Error(`Slicing for rank ${n} is not yet supported`)}(this.rank);let s;s=`\n        ${e} sourceLoc;\n        ${e} coords = getOutputCoords();\n        ${t.map((l,u)=>`sourceLoc.${HE[u]} = start[${u}] + coords.${HE[u]};`).join("\n")}\n      `,this.userCode=`\n      void main() {\n        ${s}\n        setOutput(getSource(${r}));\n      }\n    `}}const HE=["x","y","z","w","u","v"];class C${constructor(t){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.rank=t.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const e=ir(this.rank),r=yo("coords",this.rank),s=yo("sourceLoc",this.rank),o=1===this.rank?"sourceLoc":`vec2(${s.slice(-2).join()})`,l=`getChannel(getSource(${s.join()}), ${o})`,u=`\n      result.x = ${l};\n      if (++${r[this.rank-1]} < ${t[this.rank-1]}) {\n        ++${s[this.rank-1]};\n        result.y = ${l};\n        --${s[this.rank-1]};\n      }\n    `,d=1===this.rank?"":`\n      --${r[this.rank-1]};\n      if (++${r[this.rank-2]} < ${t[this.rank-2]}) {\n        ++${s[this.rank-2]};\n        result.z = ${l};\n        if (++${r[this.rank-1]} < ${t[this.rank-1]}) {\n          ++${s[this.rank-1]};\n          result.w = ${l};\n        }\n      }\n    `,h=this.rank<=4?`sourceLoc = coords +\n            ${e}(${t.map((p,g)=>`start[${g}]`).join()});`:t.map((p,g)=>`${s[g]} = ${r[g]} + start[${g}];`).join("\n");this.userCode=`\n      void main() {\n        ${e} coords = getOutputCoords();\n        ${e} sourceLoc;\n        ${h}\n        vec4 result = vec4(0.);\n        ${u}\n        ${d}\n        setOutput(result);\n      }\n    `}}function Sp(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{begin:o,size:l}=r,[u,d]=Uv(s,o,l);if(Cm(s,u,d),0===Ee(d))return e.makeTensorInfo(d,s.dtype,[]);if(e.shouldExecuteOnCPU([s])||"string"===s.dtype){const g=e.texData.get(s.dataId),y=mO(g.values,u,d,s.shape,s.dtype);return e.makeTensorInfo(d,s.dtype,y)}const{isPacked:h}=e.texData.get(s.dataId),p=Dc(s.shape,u,d);if(h||!p){const g=Q().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new C$(d):new x$(d);return e.runWebGLProgram(g,[s],s.dtype,[u])}return e.uploadToGPU(s.dataId),function S$(n,t,e,r){const s=r.texData.get(n.dataId),o=r.makeTensorInfo(e,n.dtype),l=r.texData.get(o.dataId);Object.assign(l,s),l.refCount=1,l.shape=e,l.dtype=n.dtype;let u=Em(t,Wt(n.shape));s.slice&&(u+=s.slice.flatOffset),l.slice={flatOffset:u,origDataId:s.slice&&s.slice.origDataId||n.dataId};const d=r.dataRefCount.get(l.slice.origDataId)||1;return r.dataRefCount.set(l.slice.origDataId,d+1),o}(s,u,d,e)}const E$={kernelName:kr,backendName:"webgl",kernelFunc:Sp},I$={kernelName:Fi,backendName:"webgl",kernelFunc:n=>{const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{blockShape:o,crops:l}=r;G(s.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");const u=o.reduce((O,V)=>O*V),d=rh(s.shape,o,u),h=sh(d.length,o.length),p=oh(s.shape,o,u),g=Bg(l,o.length),y=Vg(p,l,o.length),b=[],_=Mt({inputs:{x:s},backend:e,attrs:{shape:d}}),I=vo({inputs:{x:_},backend:e,attrs:{perm:h}}),S=Mt({inputs:{x:I},backend:e,attrs:{shape:p}}),T=Sp({inputs:{x:S},backend:e,attrs:{begin:g,size:y}});return b.push(_),b.push(I),b.push(S),b.forEach(O=>e.disposeIntermediateTensorInfo(O)),T}},T$={kernelName:Co,backendName:"webgl",kernelFunc:function D$(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,weights:o}=t,{size:l}=r,u=e.readSync(s.dataId),d=e.readSync(o.dataId),h=kN(u,d,o.dtype,o.shape,l);return e.makeTensorInfo([l],o.dtype,h)}},R$={kernelName:$i,backendName:"webgl",kernelFunc:function A$(n){const{inputs:t,backend:e}=n,{a:r,b:s}=t,o=Q().getBool("WEBGL_PACK_BINARY_OPERATIONS"),l=Q().getNumber("WEBGL_VERSION");if(e.shouldExecuteOnCPU([r,s])||1===l){const d=e.texData.get(r.dataId).values,h=e.texData.get(s.dataId).values,[p,g]=BM(r.shape,s.shape,d,h,r.dtype),y=e.makeTensorInfo(g,r.dtype);return e.texData.get(y.dataId).values=p,y}let u;return u=o?new wp("\n  int r = int(a.r) & int(b.r);\n  int g = int(a.g) & int(b.g);\n  int rb = int(a.b) & int(b.b);\n  int ra = int(a.a) & int(b.a);\n  return vec4(r, g, rb, ra);\n",r.shape,s.shape,!1):new Ih("\n  return float(int(a.r) & int(b.r));\n",r.shape,s.shape),e.runWebGLProgram(u,[r,s],r.dtype)}},O$={kernelName:cr,backendName:"webgl",kernelFunc:function M$(n){const{inputs:t,backend:e}=n,{s0:r,s1:s}=t,o=e.readSync(r.dataId),l=e.readSync(s.dataId),u=Nn(Array.from(o),Array.from(l));return e.makeTensorInfo([u.length],"int32",Int32Array.from(u))}},ek=Ws({opSnippet:"return float(a != b);",cpuKernelImpl:iO,dtype:"bool"}),F$={kernelName:ur,backendName:"webgl",kernelFunc:ek};function $y(n){const{inputs:t,backend:e}=n,{input:r}=t;return ui({inputs:{x:e.texData.get(r.dataId).complexTensorInfos.real},backend:e})}const $$={kernelName:lu,backendName:"webgl",kernelFunc:$y},B$={kernelName:fs,backendName:"webgl",kernelFunc:function WE(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{dtype:o}=r;if("complex64"===o){if("complex64"===s.dtype)return ui({inputs:{x:s},backend:e});const l=Mc(s.shape),u=WE({inputs:{x:s},backend:e,attrs:{dtype:"float32"}}),d=id({inputs:{real:u,imag:l},backend:e});return l.dispose(),e.disposeIntermediateTensorInfo(u),d}if("complex64"===s.dtype){const l=$y({inputs:{input:s},backend:e}),u=WE({inputs:{x:l},backend:e,attrs:{dtype:o}});return e.disposeIntermediateTensorInfo(l),u}if(!An(s.dtype,o)){const l=ui({inputs:{x:s},backend:e});return{dataId:l.dataId,shape:l.shape,dtype:o}}if(e.shouldExecuteOnCPU([s])){const l=e.texData.get(s.dataId).values,[u,d,h]=VM(l,s.shape,s.dtype,o);return e.makeTensorInfo(u,d,h)}if("int32"===o)return function L$(n,t){const e=new Yl(n.shape,"return float(int(x));"),r=t.runWebGLProgram(e,[n],"int32");return{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}(s,e);if("bool"===o){const l=e.makeTensorInfo([],"bool",Rt("bool",1)),d=ek({inputs:{a:s,b:l},backend:e});return e.disposeIntermediateTensorInfo(l),d}throw new Error(`Error in Cast: failed to cast ${s.dtype} to ${o}`)}},tk="return ceil(x);",V$=Ln({opSnippet:tk,packedOpSnippet:tk,cpuKernelImpl:UM}),U$={kernelName:Os,backendName:"webgl",kernelFunc:V$};class z${constructor(t){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=t,this.userCode="\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    "}}class H${constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=t,this.userCode="\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    "}}const j$={kernelName:Br,backendName:"webgl",kernelFunc:function W$(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{clipValueMin:o,clipValueMax:l}=r;let u;return u=Q().getBool("WEBGL_PACK_CLIP")?new H$(s.shape):new z$(s.shape),e.runWebGLProgram(u,[s],s.dtype,[[o],[l]])}};class G${constructor(t){this.variableNames=["real","imag"],this.outputShape=t,this.userCode="\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    "}}function nk(n,t){return{dataId:t.dataId,dtype:t.dtype,shape:n.shape}}const q$={kernelName:Eo,backendName:"webgl",kernelFunc:function K$(n){const{inputs:t,backend:e}=n,{x:r}=t,s=e.texData.get(r.dataId),o=new G$(r.shape),l=[nk(r,s.complexTensorInfos.real),nk(r,s.complexTensorInfos.imag)];return e.runWebGLProgram(o,l,l[0].dtype)}};class X${constructor(t){this.outputShape=[],this.outputShape=fo(t,1),this.variableNames=t.map((l,u)=>`T${u}`);const e=new Array(t.length-1);e[0]=t[0][1];for(let l=1;l<e.length;l++)e[l]=e[l-1]+t[l][1];const r=[`if (yC < ${e[0]}) setOutput(getT0(yR, yC));`];for(let l=1;l<e.length;l++)r.push(`else if (yC < ${e[l]}) setOutput(getT${l}(yR, yC-${e[l-1]}));`);r.push(`else setOutput(getT${e.length}(yR, yC-${e[e.length-1]}));`),this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        ${r.join("\n        ")}\n      }\n    `}}class Y${constructor(t,e){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=fo(t,e);const r=this.outputShape,s=r.length,o=ir(s),l=yo("coords",s),u=["x","y","z","w","u","v"].slice(0,s);this.variableNames=t.map((I,S)=>`T${S}`);const d=new Array(t.length-1);d[0]=t[0][e];for(let I=1;I<d.length;I++)d[I]=d[I-1]+t[I][e];const h=u[e],p=u.slice(-2),g=u.join();let y=`if (${h} < ${d[0]}) {\n        return getChannel(\n            getT0(${g}), vec2(${p.join()}));\n        }`;for(let I=1;I<d.length;I++){const S=d[I-1];y+=`\n        if (${h} < ${d[I]}  && ${h} >= ${d[I-1]}) {\n          return getChannel(\n            getT${I}(${ax(u,h,S)}),\n            vec2(${ax(p,h,S)}));\n        }`}const _=d[d.length-1];y+=`\n        return getChannel(\n          getT${d.length}(${ax(u,h,_)}),\n          vec2(${ax(p,h,_)}));`,this.userCode=`\n      float getValue(${u.map(I=>"int "+I)}) {\n        ${y}\n      }\n\n      void main() {\n        ${o} coords = getOutputCoords();\n        vec4 result = vec4(getValue(${l}), 0., 0., 0.);\n\n        ${l[s-1]} = ${l[s-1]} + 1;\n        if (${l[s-1]} < ${r[s-1]}) {\n          result.g = getValue(${l});\n        }\n\n        ${l[s-2]} = ${l[s-2]} + 1;\n        if (${l[s-2]} < ${r[s-2]}) {\n          result.a = getValue(${l});\n        }\n\n        ${l[s-1]} = ${l[s-1]} - 1;\n        if (${l[s-2]} < ${r[s-2]} &&\n            ${l[s-1]} < ${r[s-1]}) {\n          result.b = getValue(${l});\n        }\n        setOutput(result);\n      }\n    `}}function ax(n,t,e){const r=n.indexOf(t);return n.map((o,l)=>l===r?`${o} - ${e}`:o).join()}function lx(n){const{inputs:t,backend:e}=n,{input:r}=t;return ui({inputs:{x:e.texData.get(r.dataId).complexTensorInfos.imag},backend:e})}const Z$={kernelName:ts,backendName:"webgl",kernelFunc:lx};function Py(n,t,e){const r=n[0].dtype;if("complex64"===r){const b=n.map(O=>$y({inputs:{input:O},backend:e})),_=n.map(O=>lx({inputs:{input:O},backend:e})),I=Py(b,t,e),S=Py(_,t,e),T=id({inputs:{real:I,imag:S},backend:e});return b.forEach(O=>e.disposeIntermediateTensorInfo(O)),_.forEach(O=>e.disposeIntermediateTensorInfo(O)),e.disposeIntermediateTensorInfo(I),e.disposeIntermediateTensorInfo(S),T}let s=e.shouldExecuteOnCPU(n);if("string"===r&&(s=!0),s){const b=n.map(U=>{const j=Ee(U.shape.slice(t));return Mt({inputs:{x:U},backend:e,attrs:{shape:[-1,j]}})}),_=b.map(U=>({vals:e.readSync(U.dataId),shape:U.shape})),I=fo(b.map(U=>U.shape),1),T=zM(_,I,r,1===b[0].shape[0]),O=fo(n.map(U=>U.shape),t),V=e.makeTensorInfo(O,r,T);return b.forEach(U=>e.disposeIntermediateTensorInfo(U)),V}const o=n.filter(b=>Ee(b.shape)>0),l=Q().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&o[0].shape.length>1;if(1===o.length){const b=l?new Yl(n[0].shape,sd):new od(n[0].shape,sd);return e.runWebGLProgram(b,n,r)}const u=Q().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(o.length>u){const b=[];for(let I=0;I<o.length;I+=u){const S=o.slice(I,I+u);b.push(Py(S,t,e))}const _=Py(b,t,e);for(const I of b)e.disposeIntermediateTensorInfo(I);return _}if(l){const b=new Y$(o.map(_=>_.shape),t);return e.runWebGLProgram(b,o,r)}const{tensors2D:d,outShape:h}=function Q$(n,t,e){const r=fo(n.map(o=>o.shape),t);return{tensors2D:n.map(o=>Mt({inputs:{x:o},attrs:{shape:[-1,Ee(o.shape.slice(t))]},backend:e})),outShape:r}}(o,t,e),p=new X$(d.map(b=>b.shape)),g=e.runWebGLProgram(p,d,r);d.forEach(b=>e.disposeIntermediateTensorInfo(b));const y=Mt({inputs:{x:g},attrs:{shape:h},backend:e});return e.disposeIntermediateTensorInfo(g),y}function rk(n){const{inputs:t,backend:e,attrs:r}=n,{axis:s}=r,o=Tt(s,t[0].shape)[0];Mg(t.map(h=>h.shape),o);const u=fo(t.map(h=>h.shape),o);if(0===Ee(u))return e.makeTensorInfo(u,t[0].dtype,[]);const d=t.filter(h=>Ee(h.shape)>0);return 1===d.length?ui({inputs:{x:d[0]},backend:e}):Py(d,o,e)}const J$={kernelName:Vn,backendName:"webgl",kernelFunc:rk};class sk{constructor(t,e=!1,r=null,s=!1,o=!1){this.variableNames=["x","W"],this.outputShape=t.outShape;const l=t.padInfo.top,u=t.padInfo.left,d=t.strideHeight,h=t.strideWidth,p=t.dilationHeight,g=t.dilationWidth,y=t.filterHeight,b=t.filterWidth,_=4*Math.floor(t.inChannels/4),I=t.inChannels%4,S="channelsLast"===t.dataFormat,T=S?1:2,O=S?2:3,V=S?3:1;let U="",j="";r&&(U=s?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${r}\n        }`:o?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${r}\n        }`:`\n          float activation(float x) {\n            ${r}\n          }\n        `,j="result = activation(result);");const te=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),o&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${U}\n\n      const ivec2 strides = ivec2(${d}, ${h});\n      const ivec2 pads = ivec2(${l}, ${u});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[${V}];\n\n        ivec2 xRCCorner =\n            ivec2(coords[${T}], coords[${O}]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${y}; wR++) {\n          int xR = xRCorner + wR * ${p};\n\n          if (xR < 0 || xR >= ${t.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${b}; wC++) {\n            int xC = xCCorner + wC * ${g};\n\n            if (xC < 0 || xC >= ${t.inWidth}) {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < ${_}; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if (${S}) {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if (${1===I}) {\n\n              if (${S}) {\n                dotProd +=\n                    getX(batch, xR, xC, ${_}) *\n                    getW(wR, wC, ${_}, d2);\n              } else {\n                dotProd +=\n                    getX(batch, ${_}, xR, xC) *\n                    getW(wR, wC, ${_}, d2);\n              }\n\n            } else if (${2===I}) {\n              vec2 wValues = vec2(\n                getW(wR, wC, ${_}, d2),\n                getW(wR, wC, ${_} + 1, d2)\n              );\n\n              if (${S}) {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, ${_}),\n                  getX(batch, xR, xC, ${_} + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, ${_}, xR, xC),\n                  getX(batch, ${_} + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if (${3===I}) {\n              vec3 wValues = vec3(\n                getW(wR, wC, ${_}, d2),\n                getW(wR, wC, ${_} + 1, d2),\n                getW(wR, wC, ${_} + 2, d2)\n              );\n\n              if (${S}) {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, ${_}),\n                  getX(batch, xR, xC, ${_} + 1),\n                  getX(batch, xR, xC, ${_} + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, ${_}, xR, xC),\n                  getX(batch, ${_} + 1, xR, xC),\n                  getX(batch, ${_} + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        ${te}\n        ${j}\n        setOutput(result);\n      }\n    `}}class eP{constructor(t){this.variableNames=["x","W"],this.outputShape=t.outShape;const e=t.padInfo.front,r=t.padInfo.top,s=t.padInfo.left,o=t.strideDepth,l=t.strideHeight,u=t.strideWidth,d=t.dilationDepth,h=t.dilationHeight,p=t.dilationWidth,g=t.filterDepth,y=t.filterHeight,b=t.filterWidth,_=4*Math.floor(t.inChannels/4),I=t.inChannels%4;this.userCode=`\n      const ivec3 strides = ivec3(${o}, ${l}, ${u});\n      const ivec3 pads = ivec3(${e}, ${r}, ${s});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${g}; wF++) {\n          int xF = xFCorner + wF * ${d};\n\n          if (xF < 0 || xF >= ${t.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${y}; wR++) {\n            int xR = xRCorner + wR * ${h};\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${b}; wC++) {\n              int xC = xCCorner + wC * ${p};\n\n              if (xC < 0 || xC >= ${t.inWidth}) {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < ${_}; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (${1===I}) {\n                dotProd +=\n                  getX(batch, xF, xR, xC, ${_}) *\n                  getW(wF, wR, wC, ${_}, d2);\n              } else if (${2===I}) {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, ${_}),\n                  getX(batch, xF, xR, xC, ${_} + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, ${_}, d2),\n                  getW(wF, wR, wC, ${_} + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (${3===I}) {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, ${_}),\n                  getX(batch, xF, xR, xC, ${_} + 1),\n                  getX(batch, xF, xR, xC, ${_} + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, ${_}, d2),\n                  getW(wF, wR, wC, ${_} + 1, d2),\n                  getW(wF, wR, wC, ${_} + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class ok{constructor(t,e=!1,r=null,s=!1,o=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=t.outShape,this.enableShapeUniforms=to(this.outputShape.length);const l=t.padInfo.left,u=t.strideWidth,d=t.dilationWidth,h=t.filterHeight,p=t.filterWidth,g=p;let y="\n       int xR; int xC; int xCOffset;\n       vec4 wTexel; vec4 previous; vec4 final;";for(let S=0;S<p;S++)y+=`\n           vec4 xTexelC${2*S};\n           int xTexelC${2*S}Ready;\n           vec4 xTexelC${2*S+1};\n           int xTexelC${2*S+1}Ready;\n           vec4 xC${S};`;y+=`\n     for (int r = 0; r < ${h}; r++) {\n      for (int d1 = 0; d1 < ${t.inChannels}; d1 += 2) {\n       `;for(let S=0;S<p;S++)y+=`\n           xTexelC${2*S} = vec4(0.0);\n           xTexelC${2*S}Ready = 0;\n           xTexelC${2*S+1} = vec4(0.0);\n           xTexelC${2*S+1}Ready = 0;\n           xC${S} = vec4(0.0);`;y+="\n         xR = xRCorner + r * dilations[0];\n         if (xR >=0 && xR < inDims[0]) {\n       ";for(let S=0;S<(g+1)/2;S++){const T=2*S;if(y+=`\n           xC = xCCorner + ${T*d};\n           `,1===u){if(T<p&&(l%2==1?(y+=`\n                 xCOffset = xC + 1;\n                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${T}Ready == 0) {\n                   xTexelC${T} = getX(batch, xR, xCOffset, d1);\n\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${T}.zw = vec2(0.0);\n                   }\n                   xTexelC${T}Ready = 1;\n                 }\n               `,y+=1===d&&T>0?`\n                 xC${T} = vec4(xTexelC${T-2}.zw, xTexelC${T}.xy);\n                 `:`\n                   xCOffset = xC + 1 - 2;\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       previous.zw = vec2(0.0);\n                     }\n\n                     xC${T} = vec4(previous.zw, xTexelC${T}.xy);\n                   } else {\n                     xC${T} = vec4(0.0, 0.0, xTexelC${T}.xy);\n                   }\n                   `):y+=`\n                 if (xC >= 0 && xC < inDims[1] && xTexelC${T}Ready == 0) {\n                   xTexelC${T} = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC${T}.zw = vec2(0.0);\n                   }\n                   xTexelC${T}Ready = 1;\n                 }\n\n                 xC${T} = xTexelC${T};\n                 `,T+1<p)){const O=l%2==0?xt(d):d;d%2==0&&l%2==1||d%2!=0&&l%2!=1?(y+=`\n                   xCOffset = xC + imod(pads[1], 2) + ${O};\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${T+1}Ready == 0) {\n                     xTexelC${T+1} = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       xTexelC${T+1}.zw = vec2(0.0);\n                     }\n                     xTexelC${T+1}Ready = 1;\n                   }\n                   `,y+=d>1?`\n                     xCOffset -= 2;\n                     if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                      previous = getX(batch, xR, xCOffset, d1);\n                      xC${T+1} = vec4(previous.zw, xTexelC${T+1}.xy);\n                     } else {\n                      xC${T+1} = vec4(0.0, 0.0, xTexelC${T+1}.xy);\n                     }\n                     `:`\n                     xC${T+1} = vec4(xTexelC${T}.zw, xTexelC${T+1}.xy);\n                     `):y+=1===O?`\n                     xC${T+1} = xTexelC${T};\n                     `:`\n                     xCOffset = xC + ${O};\n\n                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${T+1}Ready == 0) {\n                       xTexelC${T+1} = getX(batch, xR, xCOffset, d1);\n                       if (xCOffset + 1 >= inDims[1]) {\n                         xTexelC${T+1}.zw = vec2(0.0);\n                       }\n                       xTexelC${T+1}Ready = 1;\n                     }\n\n                     xC${T+1} = xTexelC${T+1};\n                     `}}else T<p&&(l%2==1?(y+=`\n                 xCOffset = xC + 1 - strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${T}Ready == 0) {\n                   xTexelC${T} = getX(batch, xR, xCOffset, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${T}.zw = vec2(0.0);\n                   }\n                   xTexelC${T}Ready = 1;\n                 }\n\n                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${T+1}Ready == 0) {\n                   xTexelC${T+1} = getX(batch, xR, xC + 1, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xC + 2 >= inDims[1]) {\n                     xTexelC${T+1}.zw = vec2(0.0);\n                   }\n                   xTexelC${T+1}Ready = 1;\n                 }\n\n                 xC${T} = vec4(xTexelC${T}.zw, xTexelC${T+1}.zw);\n               `,T+1<p&&(y+=`\n                   final = vec4(0.0);\n                   xCOffset = xC + 1 + strides[1];\n                   if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                     final = getX(batch, xR, xCOffset, d1);\n                   }\n                   xC${T+1} = vec4(xTexelC${T+1}.xy, final.xy);\n                 `)):(y+=`\n                 if(xC >= 0 && xC < inDims[1] && xTexelC${T}Ready == 0) {\n                   xTexelC${T} = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC${T}.zw = vec2(0.0);\n                   }\n                   xTexelC${T}Ready = 1;\n                 }\n\n                 xCOffset = xC + strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${T+1}Ready == 0) {\n                   xTexelC${T+1} = getX(batch, xR, xCOffset, d1);\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${T+1}.zw = vec2(0.);\n                   }\n                   xTexelC${T+1}Ready = 1;\n                 }\n\n                 xC${T} = vec4(\n                   xTexelC${T}.xy, xTexelC${T+1}.xy);\n               `,T+1<p&&(y+=`\n                   xC${T+1} = vec4(xTexelC${T}.zw, xTexelC${T+1}.zw);\n                 `)));T<p&&(y+=`\n             wTexel = getW(r, ${T}, d1, d2);\n             dotProd += xC${T}.xxzz * vec4(wTexel.xy, wTexel.xy);\n             if(d1 + 1 < ${t.inChannels}) {\n               dotProd += xC${T}.yyww * vec4(wTexel.zw, wTexel.zw);\n             }\n           `,T+1<p&&(y+=`\n               wTexel = getW(r, ${T+1}, d1, d2);\n               dotProd += xC${T+1}.xxzz * vec4(wTexel.xy, wTexel.xy);\n               if(d1 + 1 < ${t.inChannels}) {\n                 dotProd += xC${T+1}.yyww * vec4(wTexel.zw, wTexel.zw);\n               }\n             `))}y+="\n     }\n   ",y+="\n     }\n   ",y+="\n     }\n   ";let b="",_="";r&&(b=s?`vec4 activation(vec4 a) {\n           vec4 b = getPreluActivationWeightsAtOutCoords();\n           ${r}\n         }`:o?`vec4 activation(vec4 a) {\n           vec4 b = getLeakyreluAlphaAtOutCoords();\n           ${r}\n         }`:`vec4 activation(vec4 x) {\n           ${r}\n         }`,_="result = activation(result);");const I=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),o&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n       ${b}\n\n       void main() {\n         ivec4 coords = getOutputCoords();\n         int batch = coords.x;\n         ivec2 xRCCorner = coords.yz * strides - pads;\n         int d2 = coords.w;\n         int xRCorner = xRCCorner.x;\n         int xCCorner = xRCCorner.y;\n\n         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n         vec4 dotProd = vec4(0.000000000000001);\n\n         ${y}\n\n         vec4 result = dotProd - vec4(0.000000000000001);\n         ${I}\n         ${_}\n         setOutput(result);\n       }\n     `}}class tP{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=t,this.enableShapeUniforms=to(this.outputShape.length);const{dataFormat:r}=e,s=Ss(),o="channelsLast"===r,l=o?1:2,u=o?2:3,d=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${t[2]} && pos < ${t[1]}) {`;let h="";for(let p=0;p<=1;p++)for(let g=0;g<=1;g++)h+=`\n          blockIndex = rc.z + ${g};\n          pos = rc.y + ${p};\n\n          ${d}\n            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];\n            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);\n\n            if(d0 < inputShape[${l}] && d0 >= 0) {\n              // Use custom imod instead mod. On Intel GPU, mod may generate\n              // unexpected value.\n              // https://github.com/tensorflow/tfjs/issues/5447\n              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];\n              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /\n                  inChannels);\n\n              if(d1 < inputShape[${u}] && d1 >= 0) {\n\n                ch = imod(pos, inChannels);\n\n                if (${o}) {\n                  innerDims = vec2(d1, ch);\n                  result[${2*p+g}] = getChannel(\n                    getA(rc.x, d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result[${2*p+g}] = getChannel(\n                    getA(rc.x, ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        `;this.userCode=`\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        ${h}\n\n        ${s.output} = result;\n      }\n    `}}function cx(n,t){const e=n.length;return e>=3?t?[...n.slice(0,-3),n[e-3]*n[e-2],n[e-1]]:[...n.slice(0,-3),n[e-3],n[e-2]*n[e-1]]:!t&&1===e&&n[0]>1?[n[0],1]:null}function ik({x:n,filter:t,convInfo:e,backend:r,bias:s=null,preluActivationWeights:o=null,leakyreluAlpha:l=0,activation:u=null}){const d=n.shape,h=r.texData.get(n.dataId),p=e.inChannels,g=d[0]*d[1]*d[2],y=e.outChannels,b="channelsLast"===e.dataFormat;let S;const T=[];if(null!=o){const U=cx(o.shape,b);null!=U&&(o=Mt({inputs:{x:o},backend:r,attrs:{shape:U}}),T.push(o))}if(null!=s){const U=cx(s.shape,b);null!=U&&(s=Mt({inputs:{x:s},backend:r,attrs:{shape:U}}),T.push(s))}if((1!==g&&1!==y||!(p>1e3))&&h.isPacked&&b&&null!=h.texture&&d[2]%2!=0&&un(h.shape.slice(-3),d.slice(-3))){const j={dataId:n.dataId,shape:[1,d[0]*d[1]*(d[2]+1),e.inChannels],dtype:n.dtype},te=h.shape;h.shape=h.shape.slice(),h.shape[h.shape.length-2]++,G(mt(h.shape,j.shape),()=>`packed reshape ${h.shape} to ${j.shape} isn't free`);const se=Mt({inputs:{x:t},backend:r,attrs:{shape:[1,e.inChannels,e.outChannels]}});T.push(se);const le=ox({a:j,b:se,backend:r,transposeA:!1,transposeB:!1,bias:s,activation:u,preluActivationWeights:o,leakyreluAlpha:l}),Ce=r.texData.get(le.dataId);G(Ce.isPacked,()=>"batchMatMul result is expected to be packed"),h.shape=te,Ce.shape=e.outShape,S=ui({inputs:{x:le},backend:r}),S.shape=e.outShape,T.push(le)}else{const U=e.outHeight*e.outWidth,j=Mt({inputs:{x:n},backend:r,attrs:{shape:b?[e.batchSize,U,e.inChannels]:[e.batchSize,e.inChannels,U]}}),te=Mt({inputs:{x:t},backend:r,attrs:{shape:[1,e.inChannels,e.outChannels]}}),se=ox({a:b?j:te,b:b?te:j,transposeA:!b,transposeB:!1,backend:r,bias:s,activation:u,preluActivationWeights:o,leakyreluAlpha:l});S=Mt({inputs:{x:se},backend:r,attrs:{shape:e.outShape}}),T.push(j),T.push(te),T.push(se)}for(const U of T)r.disposeIntermediateTensorInfo(U);return S}function ak({x:n,filter:t,convInfo:e,backend:r,bias:s=null,preluActivationWeights:o=null,leakyreluAlpha:l=0,activation:u=null}){const{filterWidth:d,filterHeight:h,inChannels:p,outWidth:g,outHeight:y,dataFormat:b}=e,_="channelsLast"===b,I=d*h*p,S=y*g,T=[e.batchSize,I,S],U=[];if(null!=o){const De=cx(o.shape,_);null!=De&&(o=Mt({inputs:{x:o},backend:r,attrs:{shape:De}}),U.push(o))}if(null!=s){const De=cx(s.shape,_);null!=De&&(s=Mt({inputs:{x:s},backend:r,attrs:{shape:De}}),U.push(s))}const j=Mt({inputs:{x:t},backend:r,attrs:{shape:[1,I,Ee(t.shape)/I]}});U.push(j);const te=new tP(T,e),le=r.runWebGLProgram(te,[n],"float32",[n.shape,[e.padInfo.top,e.padInfo.left],[e.strideHeight,e.strideWidth],[e.dilationHeight,e.dilationWidth],[e.inChannels],[e.filterWidth*e.inChannels],[e.outWidth]]),Ce=Mt({inputs:{x:le},backend:r,attrs:{shape:T}});U.push(le),U.push(Ce);const be=null!=s,Me=null!=o,He="leakyrelu"===u,We=u?Oy(u,!0):null,je=new HN(_?Ce.shape:j.shape,_?j.shape:Ce.shape,_?[e.batchSize,S,e.outChannels]:[e.batchSize,e.outChannels,S],!0,!1,be,We,Me,He),Ke=_?[Ce,j]:[j,Ce];if(s&&Ke.push(s),Me&&Ke.push(o),He){const De=r.makeTensorInfo([],"float32",_i(l,"float32"));Ke.push(De),U.push(De)}const Se=r.runWebGLProgram(je,Ke,"float32"),ke=Mt({inputs:{x:Se},backend:r,attrs:{shape:e.outShape}});U.push(Se);for(const De of U)r.disposeIntermediateTensorInfo(De);return ke}const rP={kernelName:sl,backendName:"webgl",kernelFunc:function nP(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,filter:o}=t,{strides:l,pad:u,dataFormat:d,dilations:h,dimRoundingMode:p}=r,g=sn(d),y=Xr(s.shape,o.shape,l,h,u,p,!1,g);let b;if(1!==y.filterHeight||1!==y.filterWidth||1!==y.dilationHeight||1!==y.dilationWidth||1!==y.strideHeight||1!==y.strideWidth||"SAME"!==y.padInfo.type&&"VALID"!==y.padInfo.type)if(y.strideWidth<=2&&"channelsLast"===g&&Q().getBool("WEBGL_EXP_CONV")){const I=new ok(y);b=e.runWebGLProgram(I,[s,o],"float32",[[y.padInfo.top,y.padInfo.left],[y.strideHeight,y.strideWidth],[y.dilationHeight,y.dilationWidth],[y.inHeight,y.inWidth]])}else if(Q().getBool("WEBGL_CONV_IM2COL"))b=ak({x:s,filter:o,convInfo:y,backend:e});else{const I=new sk(y);b=e.runWebGLProgram(I,[s,o],"float32")}else b=ik({x:s,filter:o,convInfo:y,backend:e});const _=Mt({inputs:{x:b},backend:e,attrs:{shape:y.outShape}});return e.disposeIntermediateTensorInfo(b),_}};class sP{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${t.batchSize}; b++) {\n          for (int yR = 0; yR < ${t.outHeight}; yR++) {\n            int xR = wR + yR * ${t.strideHeight} - ${t.padInfo.top};\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${t.outWidth}; yC++) {\n              int xC = wC + yC * ${t.strideWidth} - ${t.padInfo.left};\n\n              if (xC < 0 || xC >= ${t.inWidth}) {\n                continue;\n              }\n\n              ${"channelsLast"===t.dataFormat?"float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);":"float dyValue = getDy(b, d2, yR, yC);\n              float xValue = getX(b, d1, xR, xC);\n              dotProd += (xValue * dyValue);"}\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class oP{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const e=t.filterHeight,r=t.filterWidth,l="channelsLast"===t.dataFormat;this.userCode=`\n      const ivec2 pads = ivec2(${e-1-t.padInfo.top}, ${r-1-t.padInfo.left});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[${l?3:1}];\n\n        ivec2 dyCorner = ivec2(coords[${l?1:2}], coords[${l?2:3}]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${e}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${e} - 1 - wR;\n\n          for (int wC = 0; wC < ${r}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${r} - 1 - wC;\n\n            for (int d2 = 0; d2 < ${t.outChannels}; d2++) {\n\n              if (${l}) {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class iP{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape,this.userCode=`\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${t.batchSize}; b++) {\n          for (int yF = 0; yF < ${t.outDepth}; yF++) {\n            int xF = wF + yF * ${t.strideDepth} - ${t.padInfo.front};\n\n            if (xF < 0 || xF >= ${t.inDepth}) {\n              continue;\n            }\n\n            for (int yR = 0; yR < ${t.outHeight}; yR++) {\n              int xR = wR + yR * ${t.strideHeight} - ${t.padInfo.top};\n\n              if (xR < 0 || xR >= ${t.inHeight}) {\n                continue;\n              }\n\n              for (int yC = 0; yC < ${t.outWidth}; yC++) {\n                int xC = wC + yC * ${t.strideWidth} - ${t.padInfo.left};\n\n                if (xC < 0 || xC >= ${t.inWidth}) {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class aP{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const e=t.filterDepth,r=t.filterHeight,s=t.filterWidth;this.userCode=`\n      const ivec3 pads = ivec3(${e-1-t.padInfo.front}, ${r-1-t.padInfo.top}, ${s-1-t.padInfo.left});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${e}; wF++) {\n          float dyF = float(dyFCorner + wF) / ${t.strideDepth}.0;\n\n          if (dyF < 0.0 || dyF >= ${t.outDepth}.0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = ${e} - 1 - wF;\n\n          for (int wR = 0; wR < ${r}; wR++) {\n            float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = ${r} - 1 - wR;\n\n            for (int wC = 0; wC < ${s}; wC++) {\n              float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = ${s} - 1 - wC;\n\n              for (int d2 = 0; d2 < ${t.outChannels}; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const cP={kernelName:ol,backendName:"webgl",kernelFunc:function lP(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,dy:o}=t,{strides:l,pad:u,dataFormat:d,dimRoundingMode:h,filterShape:p}=r,g=sn(d),y=Xr(s.shape,p,l,1,u,h,!1,g),b=new sP(y);return e.runWebGLProgram(b,[s,o],"float32")}};class uP{constructor(t){this.variableNames=["dy","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"strides",type:"vec2"}],this.outputShape=t.inShape,this.enableShapeUniforms=to(this.outputShape.length);const e=t.filterHeight,r=t.filterWidth;this.userCode=`\n      const ivec2 pads = ivec2(${e-1-t.padInfo.top}, ${r-1-t.padInfo.left});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n\n        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        vec4 result = vec4(0.);\n        for (int wR = 0; wR < ${e}; wR++) {\n          float dyR = float(dyRCorner + wR) / strides[0];\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n          int wRPerm = ${e} - 1 - wR;\n\n          for (int wC = 0; wC < ${r}; wC++) {\n            int wCPerm = ${r} - 1 - wC;\n\n            float dyC = float(dyCCorner + wC) / strides[1];\n            bool idyCVal = (dyC >= 0.0) && (dyC < ${t.outWidth}.0)\n              && (fract(dyC) == 0.0);\n            int idyC = int(dyC);\n\n            float dyC2 = float(dyCCorner + wC + 1) / strides[1];\n            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ${t.outWidth}.0)\n              && (fract(dyC2) == 0.0);\n            int idyC2 = int(dyC2);\n\n            if (idyCVal && idyCVal2) {\n              for (int d2 = 0; d2 < ${t.outChannels}; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC, d2);\n                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?\n                  dySample : getDy(batch, idyR, idyC2, d2);\n\n                vec2 dyValue = mod(float(idyC), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.xy += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n\n                dyValue = mod(float(idyC2), 2.) == 0. ?\n                  dySample2.xy : dySample2.zw;\n                result.zw += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            } else if (idyCVal) {\n              for (int d2 = 0; d2 < ${t.outChannels}; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC, d2);\n                vec2 dyValue = mod(float(idyC), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.xy += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            } else if (idyCVal2) {\n              for (int d2 = 0; d2 < ${t.outChannels}; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC2, d2);\n                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.zw += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            }\n          }\n        }\n        setOutput(result);\n      }\n    `}}const hP={kernelName:jr,backendName:"webgl",kernelFunc:function dP(n){const{inputs:t,backend:e,attrs:r}=n,{dy:s,filter:o}=t,{inputShape:l,strides:u,pad:d,dataFormat:h,dimRoundingMode:p}=r,g=sn(h),y=Xr(l,o.shape,u,1,d,p,!1,g);if(Q().getBool("WEBGL_PACK_CONV2DTRANSPOSE")&&"channelsLast"===g){const b=[[y.strideHeight,y.strideWidth]],_=new uP(y);return e.runWebGLProgram(_,[s,o],"float32",b)}{const b=new oP(y);return e.runWebGLProgram(b,[s,o],"float32")}}},pP={kernelName:es,backendName:"webgl",kernelFunc:function fP(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,filter:o}=t,{strides:l,pad:u,dilations:d}=r,h=Ml(s.shape,o.shape,l,d,u),p=new eP(h);return e.runWebGLProgram(p,[s,o],"float32")}},gP={kernelName:hi,backendName:"webgl",kernelFunc:function mP(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,dy:o}=t,{strides:l,pad:u,filterShape:d}=r,h=Ml(s.shape,d,l,1,u),p=new iP(h);return e.runWebGLProgram(p,[s,o],"float32")}},vP={kernelName:Gr,backendName:"webgl",kernelFunc:function yP(n){const{inputs:t,backend:e,attrs:r}=n,{dy:s,filter:o}=t,{pad:l,strides:u,inputShape:d}=r,h=Ml(d,o.shape,u,1,l),p=new aP(h);return e.runWebGLProgram(p,[s,o],"float32")}},xP=Ln({opSnippet:"if (isnan(x)) return x;\n  return cos(x);\n",packedOpSnippet:`\n  vec4 result = cos(x);\n  bvec4 isNaN = isnan(x);\n  ${Dh}\n  return result;\n`}),wP={kernelName:Io,backendName:"webgl",kernelFunc:xP},CP=Ln({opSnippet:"\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n"}),SP={kernelName:ps,backendName:"webgl",kernelFunc:CP};class EP{constructor(t,e,r,s,o){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[l,u,d,h]=t,[p]=e,[g,y]=r;this.outputShape=[p,g,y,h];const b="bilinear"===s?1:0,[_,I]=[u-1+".0",d-1+".0"],[S,T,O]=g>1?[""+(u-1)/(g-1),"(y2-y1) * height_ratio",`y1*${_} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${_}`],[V,U,j]=y>1?[""+(d-1)/(y-1),"(x2-x1) * width_ratio",`x1*${I} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${I}`];this.userCode=`\n      const float height_ratio = float(${S});\n      const float width_ratio = float(${V});\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= ${l}) {\n          return;\n        }\n\n        float height_scale = ${T};\n        float width_scale = ${U};\n\n        float in_y = ${O};\n        if( in_y < 0.0 || in_y > ${_} ) {\n          setOutput(float(${o}));\n          return;\n        }\n        float in_x = ${j};\n        if( in_x < 0.0 || in_x > ${I} ) {\n          setOutput(float(${o}));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(${b} == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    `}}const IP={kernelName:qs,backendName:"webgl",kernelFunc:n=>{const{inputs:t,backend:e,attrs:r}=n,{image:s,boxes:o,boxInd:l}=t,{cropSize:u,method:d,extrapolationValue:h}=r,p=new EP(s.shape,o.shape,u,d,h);return e.runWebGLProgram(p,[s,o,l],"float32")}};var Ep=(()=>{return(n=Ep||(Ep={})).Prod="*",n.Sum="+",Ep;var n})();class lk{constructor(t,e,r,s){this.op=t,this.outputShape=e,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];const o=this.outputShape.length,u=r?this.op===Ep.Prod?"1.0":"0.0":`getX(${ck(o,"coords",this.op)})`,d=this.outputShape[this.outputShape.length-1];let h="",p="";r?(h=s?"end != "+(d-1):"end != 0",p=s?"end + 1":"end - 1"):(h=s?`end + pow2 < ${d}`:"end >= pow2",p=s?"end + pow2":"end - pow2"),this.userCode=`\n      void main() {\n        ${ir(o)} coords = getOutputCoords();\n        int end = ${uk(o,"coords",this.op)};\n        float val = ${u};\n        int pow2 = int(pow(2.0, index));\n        if (${h}) {\n          int idx = ${p};\n          ${uk(o,"coords",this.op)} = idx;\n          val ${this.op}= getX(${ck(o,"coords",this.op)});\n        }\n        setOutput(val);\n      }\n    `}}function ck(n,t,e){if(1===n)return`${t}`;if(2===n)return`${t}.x, ${t}.y`;if(3===n)return`${t}.x, ${t}.y, ${t}.z`;if(4===n)return`${t}.x, ${t}.y, ${t}.z, ${t}.w`;throw new Error(`Cumulative ${e} for rank ${n} is not yet supported`)}function uk(n,t,e){if(1===n)return`${t}`;if(2===n)return`${t}.y`;if(3===n)return`${t}.z`;if(4===n)return`${t}.w`;throw new Error(`Cumulative ${e} for rank ${n} is not yet supported`)}function dk(n,t,e,r,s,o){const l=t.shape.length,u=pr([r],l);let d=t;null!=u&&(d=vo({inputs:{x:t},backend:e,attrs:{perm:u}}));const h=_r(1,l)[0];if(h!==l-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${t.shape.length-1} but got axis=${r}`);const p=d.shape[h];let g=ui({inputs:{x:d},backend:e});for(let y=0;y<=Math.ceil(Math.log2(p))-1;y++){const b=new lk(n,d.shape,!1,o),I=g;g=e.runWebGLProgram(b,[g],g.dtype,[[y]]),e.disposeIntermediateTensorInfo(I)}if(s){const y=new lk(n,d.shape,s,o),b=g;g=e.runWebGLProgram(y,[g],g.dtype),e.disposeIntermediateTensorInfo(b)}if(null!=u){const b=vo({inputs:{x:g},backend:e,attrs:{perm:na(u)}});return e.disposeIntermediateTensorInfo(g),e.disposeIntermediateTensorInfo(d),b}return g}const TP={kernelName:il,backendName:"webgl",kernelFunc:function DP(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:o,exclusive:l,reverse:u}=r;return dk(Ep.Prod,s,e,o,l,u)}},kP={kernelName:tc,backendName:"webgl",kernelFunc:function NP(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:o,exclusive:l,reverse:u}=r;return dk(Ep.Sum,s,e,o,l,u)}},RP={kernelName:ba,backendName:"webgl",kernelFunc:function AP(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,weights:o}=t,{size:l,binaryOutput:u}=r;if(1===s.shape.length){const d=e.readSync(s.dataId),h=e.readSync(o.dataId),p=kN(d,h,o.dtype,o.shape,l);return e.makeTensorInfo([l],o.dtype,p)}if(2===s.shape.length){const d=e.bufferSync(s),h=e.bufferSync(o),p=LM(d,h,l,u);return e.makeTensorInfo(p.shape,o.dtype,p.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${s.shape.length}.`)}};class MP{constructor(t,e,r){this.variableNames=["x"],this.outputShape=[],this.outputShape=t,this.blockSize=e,this.dataFormat=r,this.userCode=`\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = ${this.getHeightCoordString()};\n      int w = ${this.getWidthCoordString()};\n      int d = ${this.getDepthCoordString()};\n\n      int in_h = h / ${e};\n      int offset_h = imod(h, ${e});\n      int in_w = w / ${e};\n      int offset_w = imod(w, ${e});\n      int offset_d = (offset_h * ${e} + offset_w) *\n        ${this.getOutputDepthSize()};\n      int in_d = d + offset_d;\n\n      float result = ${this.getInputSamplingString()};\n      setOutput(result);\n    }\n  `}getHeightCoordString(){return"NHWC"===this.dataFormat?"coords[1]":"coords[2]"}getWidthCoordString(){return"NHWC"===this.dataFormat?"coords[2]":"coords[3]"}getDepthCoordString(){return"NHWC"===this.dataFormat?"coords[3]":"coords[1]"}getOutputDepthSize(){return"NHWC"===this.dataFormat?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return"NHWC"===this.dataFormat?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}const FP={kernelName:zo,backendName:"webgl",kernelFunc:function OP(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{blockSize:o,dataFormat:l}=r,u=s.shape[0],g=("NHWC"===l?s.shape[1]:s.shape[2])*o,y=("NHWC"===l?s.shape[2]:s.shape[3])*o,b=("NHWC"===l?s.shape[3]:s.shape[1])/(o*o),I=new MP("NHWC"===l?[u,g,y,b]:[u,b,g,y],o,l);return e.runWebGLProgram(I,[s],s.dtype)}};class hk{constructor(t,e=!1,r=null,s=!1,o=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=t.outShape,this.enableShapeUniforms=to(this.outputShape.length);const l=t.filterHeight,u=t.filterWidth,d=t.outChannels/t.inChannels;let h="",p="";r&&(h=s?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${r}\n        }`:o?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${r}\n        }`:`\n          float activation(float x) {\n            ${r}\n          }\n        `,p="result = activation(result);");const g=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),o&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${h}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${d};\n        int q = d2 - d1 * ${d};\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < ${l}; wR++) {\n          int xR = xRCorner + wR * dilations[0];\n\n          if (xR < 0 || xR >= inDims[0]) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${u}; wC++) {\n            int xC = xCCorner + wC * dilations[1];\n\n            if (xC < 0 || xC >= inDims[1]) {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        ${g}\n        ${p}\n        setOutput(result);\n      }\n    `}}class fk{constructor(t,e=!1,r=null,s=!1,o=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=t.outShape,this.enableShapeUniforms=to(this.outputShape.length);const l=t.outChannels/t.inChannels,u=t.padInfo.left,d=t.strideWidth,h=t.dilationWidth,p=t.filterHeight,g=t.filterWidth,y=g;let b="\n      int xR; int xC; int xCOffset;\n      vec4 wTexel; vec4 previous; vec4 final;";for(let T=0;T<g;T++)b+=`\n          vec4 xTexelC${2*T};\n          int xTexelC${2*T}Ready;\n          vec4 xTexelC${2*T+1};\n          int xTexelC${2*T+1}Ready;\n          vec4 xC${T};`;b+=`\n    for (int r = 0; r < ${p}; r++) {\n      `;for(let T=0;T<g;T++)b+=`\n          xTexelC${2*T} = vec4(0.0);\n          xTexelC${2*T}Ready = 0;\n          xTexelC${2*T+1} = vec4(0.0);\n          xTexelC${2*T+1}Ready = 0;\n          xC${T} = vec4(0.0);`;b+="\n        xR = xRCorner + r * dilations[0];\n        if (xR >=0 && xR < inDims[0]) {\n      ";for(let T=0;T<(y+1)/2;T++){const O=2*T;if(b+=`\n          xC = xCCorner + ${O*h};\n          `,1===d){if(O<g&&(u%2==1?(b+=`\n                xCOffset = xC + 1;\n                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${O}Ready == 0) {\n                  xTexelC${O} = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${O}.zw = vec2(0.0);\n                  }\n                  xTexelC${O}Ready = 1;\n                }\n              `,b+=1===h&&O>0?`\n                xC${O} = vec4(xTexelC${O-2}.zw, xTexelC${O}.xy);\n                `:`\n                  xCOffset = xC + 1 - 2;\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                    previous = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      previous.zw = vec2(0.0);\n                    }\n\n                    xC${O} = vec4(previous.zw, xTexelC${O}.xy);\n                  } else {\n                    xC${O} = vec4(0.0, 0.0, xTexelC${O}.xy);\n                  }\n                  `):b+=`\n                if (xC >= 0 && xC < inDims[1] && xTexelC${O}Ready == 0) {\n                  xTexelC${O} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC${O}.zw = vec2(0.0);\n                  }\n                  xTexelC${O}Ready = 1;\n                }\n\n                xC${O} = xTexelC${O};\n                `,O+1<g)){const V=u%2==0?xt(h):h;h%2==0&&u%2==1||h%2!=0&&u%2!=1?(b+=`\n                  xCOffset = xC + imod(pads[1], 2) + ${V};\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${O+1}Ready == 0) {\n                    xTexelC${O+1} = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      xTexelC${O+1}.zw = vec2(0.0);\n                    }\n                    xTexelC${O+1}Ready = 1;\n                  }\n                  `,b+=h>1?`\n                    xCOffset -= 2;\n                    if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n                     xC${O+1} = vec4(previous.zw, xTexelC${O+1}.xy);\n                    } else {\n                     xC${O+1} = vec4(0.0, 0.0, xTexelC${O+1}.xy);\n                    }\n                    `:`\n                    xC${O+1} = vec4(xTexelC${O}.zw, xTexelC${O+1}.xy);\n                    `):b+=1===V?`\n                    xC${O+1} = xTexelC${O};\n                    `:`\n                    xCOffset = xC + ${V};\n\n                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${O+1}Ready == 0) {\n                      xTexelC${O+1} = getX(batch, xR, xCOffset, d1);\n                      if (xCOffset + 1 >= inDims[1]) {\n                        xTexelC${O+1}.zw = vec2(0.0);\n                      }\n                      xTexelC${O+1}Ready = 1;\n                    }\n\n                    xC${O+1} = xTexelC${O+1};\n                    `}}else O<g&&(u%2==1?(b+=`\n                xCOffset = xC + 1 - strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${O}Ready == 0) {\n                  xTexelC${O} = getX(batch, xR, xCOffset, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${O}.zw = vec2(0.0);\n                  }\n                  xTexelC${O}Ready = 1;\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${O+1}Ready == 0) {\n                  xTexelC${O+1} = getX(batch, xR, xC + 1, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xC + 2 >= inDims[1]) {\n                    xTexelC${O+1}.zw = vec2(0.0);\n                  }\n                  xTexelC${O+1}Ready = 1;\n                }\n\n                xC${O} = vec4(xTexelC${O}.zw, xTexelC${O+1}.zw);\n              `,O+1<g&&(b+=`\n                  final = vec4(0.0);\n                  xCOffset = xC + 1 + strides[1];\n                  if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xC${O+1} = vec4(xTexelC${O+1}.xy, final.xy);\n                `)):(b+=`\n                if(xC >= 0 && xC < inDims[1] && xTexelC${O}Ready == 0) {\n                  xTexelC${O} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC${O}.zw = vec2(0.0);\n                  }\n                  xTexelC${O}Ready = 1;\n                }\n\n                xCOffset = xC + strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${O+1}Ready == 0) {\n                  xTexelC${O+1} = getX(batch, xR, xCOffset, d1);\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${O+1}.zw = vec2(0.);\n                  }\n                  xTexelC${O+1}Ready = 1;\n                }\n\n                xC${O} = vec4(\n                  xTexelC${O}.xy, xTexelC${O+1}.xy);\n              `,O+1<g&&(b+=`\n                  xC${O+1} = vec4(xTexelC${O}.zw, xTexelC${O+1}.zw);\n                `)));O<g&&(b+=`\n            wTexel = getW(r, ${O}, d1, q);\n            dotProd += xC${O} * vec4(wTexel.xz, wTexel.xz);\n          `,O+1<g&&(b+=`\n              wTexel = getW(r, ${O+1}, d1, q);\n              dotProd += xC${O+1} * vec4(wTexel.xz, wTexel.xz);\n            `))}b+="\n    }\n  ",b+="\n      }\n    ";let _="",I="";r&&(_=s?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${r}\n        }`:o?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${r}\n        }`:`vec4 activation(vec4 x) {\n          ${r}\n        }`,I="result = activation(result);");const S=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),o&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${_}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${l};\n        int q = d2 - d1 * ${l};\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n        vec4 dotProd = vec4(0.000000000000001);\n\n        ${b}\n\n        vec4 result = dotProd - vec4(0.000000000000001);\n        ${S}\n        ${I}\n        setOutput(result);\n      }\n    `}}const PP={kernelName:_a,backendName:"webgl",kernelFunc:function $P(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,filter:o}=t,{strides:l,pad:u,dilations:d,dimRoundingMode:h}=r;let p=d;null==p&&(p=[1,1]),G(Ns(l,p),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${p}'`);const g=Xr(s.shape,o.shape,l,p,u,h,!0);let y;return y=Q().getBool("WEBGL_PACK_DEPTHWISECONV")&&g.strideWidth<=2&&g.outChannels/g.inChannels==1?new fk(g):new hk(g),e.runWebGLProgram(y,[s,o],"float32",[[g.padInfo.top,g.padInfo.left],[g.strideHeight,g.strideWidth],[g.dilationHeight,g.dilationWidth],[g.inHeight,g.inWidth]])}};class LP{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * ${t.outChannels/t.inChannels} + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < ${t.batchSize}; b++) {\n          for (int yR = 0; yR < ${t.outHeight}; yR++) {\n            int xR = wR + yR * ${t.strideHeight} - ${t.padInfo.top};\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${t.outWidth}; yC++) {\n              int xC = wC + yC * ${t.strideWidth} - ${t.padInfo.left};\n\n              if (xC < 0 || xC >= ${t.inWidth}) {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class BP{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const e=t.filterHeight,r=t.filterWidth,d=t.outChannels/t.inChannels;this.userCode=`\n      const ivec2 pads = ivec2(${e-1-t.padInfo.top}, ${r-1-t.padInfo.left});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < ${e}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${e} - 1 - wR;\n\n          for (int wC = 0; wC < ${r}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${r} - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < ${d}; dm++) {\n              int d2 = d1 * ${d} + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const UP={kernelName:nc,backendName:"webgl",kernelFunc:function VP(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,dy:o}=t,{strides:l,dilations:u,pad:d,dimRoundingMode:h,filterShape:p}=r,g=Xr(s.shape,p,l,u,d,h,!0),y=new LP(g);return e.runWebGLProgram(y,[s,o],"float32")}},HP={kernelName:Xc,backendName:"webgl",kernelFunc:function zP(n){const{inputs:t,backend:e,attrs:r}=n,{dy:s,filter:o}=t,{strides:l,dilations:u,pad:d,dimRoundingMode:h,inputShape:p}=r,g=Xr(p,o.shape,l,u,d,h,!0),y=new BP(g);return e.runWebGLProgram(y,[s,o],"float32")}};class WP{constructor(t){this.variableNames=["X"],this.outputShape=[t,t],this.userCode="\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    "}}const GP={kernelName:Yc,backendName:"webgl",kernelFunc:function jP(n){const{inputs:t,backend:e}=n,{x:r}=t,s=[...r.shape,...r.shape],o=Ee(r.shape),l=Mt({inputs:{x:r},backend:e,attrs:{shape:[o]}}),u=new WP(o),d=e.runWebGLProgram(u,[l],l.dtype),h=Mt({inputs:{x:d},backend:e,attrs:{shape:s}});return e.disposeIntermediateTensorInfo(l),e.disposeIntermediateTensorInfo(d),h}};class KP{constructor(t){this.variableNames=["x","W"],this.outputShape=t.outShape;const{inHeight:e,inWidth:r,padInfo:s,strideHeight:o,strideWidth:l,filterHeight:u,filterWidth:d,dilationHeight:h,dilationWidth:p}=t,{top:g,left:y}=s;this.userCode=`\n      const ivec2 strides = ivec2(${o}, ${l});\n      const ivec2 pads = ivec2(${g}, ${y});\n      const float neg_infinity = -3.4e38;\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.w;\n        ivec2 outTopLeftCorner =\n            coords.yz * strides - pads;\n        int hBeg = outTopLeftCorner.x;\n        int wBeg = outTopLeftCorner.y;\n\n        float curVal = neg_infinity;\n        for (int h = 0; h < ${u}; h++) {\n          int hIn = hBeg + h * ${h};\n\n          if (hIn >= 0 && hIn < ${e}) {\n            for (int w = 0; w < ${d}; w++) {\n              int wIn = wBeg + w * ${p};\n\n              if (wIn >= 0 && wIn < ${r}) {\n                float xVal = getX(batch, hIn, wIn, d1);\n                float wVal = getW(h, w, d1);\n\n                float val = xVal + wVal;\n                if (val > curVal) {\n                  curVal = val;\n                }\n              }\n            }\n          }\n        }\n\n        float result = curVal;\n        setOutput(result);\n      }\n    `}}const XP={kernelName:Zc,backendName:"webgl",kernelFunc:function qP(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,filter:o}=t,{strides:l,pad:u,dilations:d}=r,h=uf(s.shape,o.shape,l,u,"NHWC",d);let p;const g=new KP(h);p=e.runWebGLProgram(g,[s,o],"float32");const y=Mt({inputs:{x:p},backend:e,attrs:{shape:h.outShape}});return e.disposeIntermediateTensorInfo(p),y}},ZP={kernelName:Jc,backendName:"webgl",kernelFunc:function YP(n){const{inputs:t,backend:e,attrs:r}=n,{equation:s}=r,o=t,{allDims:l,summedDims:u,idDims:d}=uh(s,o.length);qf(l.length,d,o);const{path:h,steps:p}=hh(u,d),g=p.length;let y=null,b=l.length;const _=[];for(let I=0;I<g;++I){for(const S of p[I]){const{permutationIndices:T,expandDims:O}=dh(b,d[S]);let V;fh(T)?V=o[S]:(V=vo({inputs:{x:o[S]},backend:e,attrs:{perm:T}}),_.push(V));const U=V.shape.slice();for(let j=0;j<O.length;++j)U.splice(O[j],0,1);un(V.shape,U)||(V=Mt({inputs:{x:V},backend:e,attrs:{shape:U}}),_.push(V)),null===y?y=V:(y=UE({inputs:{a:V,b:y},backend:e}),_.push(y))}I<g-1&&(h[I]>=0&&(y=sx({inputs:{x:y},backend:e,attrs:{axis:h[I]-(l.length-b),keepDims:!1}}),_.push(y)),b--)}for(const I of _)I!==y&&e.disposeIntermediateTensorInfo(I);return y}},QP=Ln({opSnippet:"return (x >= 0.0) ? x : (exp(x) - 1.0);",packedOpSnippet:"\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n"}),JP={kernelName:al,backendName:"webgl",kernelFunc:QP},nL={kernelName:md,backendName:"webgl",kernelFunc:n=>{const{inputs:t,backend:e}=n,{dy:r,y:s}=t,o=Q().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new wp("\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n",r.shape,s.shape):new Ih("return (b >= 0.0) ? a : a * (b + 1.0);",r.shape,s.shape);return e.runWebGLProgram(o,[r,s],r.dtype)}},rL=Ws({opSnippet:"return float(a == b);",packedOpSnippet:"\n  return vec4(equal(a, b));\n",dtype:"bool",cpuKernelImpl:HM}),sL={kernelName:Pi,backendName:"webgl",kernelFunc:rL},iL=Ln({opSnippet:`\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  float p = ${ai};\n  float a1 = ${zg};\n  float a2 = ${ah};\n  float a3 = ${Uc};\n  float a4 = ${Hg};\n  float a5 = ${Wg};\n\n  float sign = sign(x);\n  x = abs(x);\n  float t = 1.0 / (1.0 + p * x);\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\n`}),aL={kernelName:sc,backendName:"webgl",kernelFunc:iL},pk=Ln({opSnippet:"if (isnan(x)) return x;\n  return exp(x);\n",packedOpSnippet:"\n  vec4 result = exp(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cpuKernelImpl:WM,dtype:"float32"}),cL={kernelName:Ho,backendName:"webgl",kernelFunc:pk};function jE(n){const{inputs:t,attrs:e,backend:r}=n,{dim:s}=e,{input:o}=t,l=o.shape.length,u=o.shape.slice();let d=s;return s<0&&(G(-(l+1)<=s,()=>`Axis must be in the interval [${-(l+1)}, ${l}]`),d=l+s+1),u.splice(d,0,1),Mt({inputs:{x:o},backend:r,attrs:{shape:u}})}const uL={kernelName:xa,backendName:"webgl",kernelFunc:jE},mk="return exp(x) - 1.0;",dL=Ln({opSnippet:mk,packedOpSnippet:mk,cpuKernelImpl:jM}),hL={kernelName:wa,backendName:"webgl",kernelFunc:dL};class gk{constructor(t,e,r){this.variableNames=["real","imag"];const s=e[1];this.outputShape=e;const o=r?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,l=r?`${s}.0`:"1.0";let u;if("real"===t)u="return real * expR - imag * expI;";else{if("imag"!==t)throw new Error(`FFT component must be either "real" or "imag", got ${t}.`);u="return real * expI + imag * expR;"}this.userCode=`\n      const float exponentMultiplier = ${o};\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        ${u}\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float(${s});\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < ${s}; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / ${l};\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    `}}function yk(n,t,e){const r=e.texData.get(n.dataId),s=Ee(n.shape),o=n.shape[n.shape.length-1],u=Mt({inputs:{x:n},backend:e,attrs:{shape:[s/o,o]}}),d=u.shape,h=new gk("real",d,t),p=new gk("imag",d,t),g=[{dataId:r.complexTensorInfos.real.dataId,dtype:r.complexTensorInfos.real.dtype,shape:d},{dataId:r.complexTensorInfos.imag.dataId,dtype:r.complexTensorInfos.imag.dtype,shape:d}],y=e.runWebGLProgram(h,g,"float32"),b=e.runWebGLProgram(p,g,"float32"),_=id({inputs:{real:y,imag:b},backend:e});e.disposeIntermediateTensorInfo(y),e.disposeIntermediateTensorInfo(b);const I=Mt({inputs:{x:_},backend:e,attrs:{shape:n.shape}});return e.disposeIntermediateTensorInfo(u),e.disposeIntermediateTensorInfo(_),I}const pL={kernelName:"FFT",backendName:"webgl",kernelFunc:function fL(n){const{inputs:t,backend:e}=n,{input:r}=t;return yk(r,!1,e)}};class mL{constructor(t,e){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=t,this.userCode="\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    "}}function Ly(n){const{backend:t,attrs:e}=n,{shape:r,value:s}=e;let{dtype:o}=e;if(o=o||Zt(s),"string"===o){const l=Ft(o,Ee(r));return l.fill(s),t.makeTensorInfo(r,o,l)}{const l=new mL(r,s);return t.runWebGLProgram(l,[],o,[[s]])}}const gL={kernelName:Vr,backendName:"webgl",kernelFunc:Ly};class yL{constructor(t){this.variableNames=["Image"],this.outputShape=[];const e=t[2];this.outputShape=t,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n\n          int coordX = ${e} - x - 1;\n          float outputValue;\n          if(coordX >= 0 && coordX < ${e}) {\n            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);\n          } else {\n            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}}const vL={kernelName:Do,backendName:"webgl",kernelFunc:({inputs:n,backend:t})=>{const{image:e}=n,r=t,s=new yL(e.shape);return r.runWebGLProgram(s,[e],e.dtype)}},vk="return floor(x);",bL=Ln({opSnippet:vk,packedOpSnippet:vk,cpuKernelImpl:GM}),_L={kernelName:fi,backendName:"webgl",kernelFunc:bL},xL=Ws({opSnippet:"\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n",packedOpSnippet:"\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n",dtype:"int32"}),wL={kernelName:Li,backendName:"webgl",kernelFunc:xL};class CL{constructor(t){this.variableNames=["A"];const e=Ss(),[r,s]=t;this.outputShape=t,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${s}.0, ${r}.0);\n\n        vec4 values = ${e.texture2D}(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    `}}class SL{constructor(t){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const e=Ss(),[r,s]=t;this.outputShape=t,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n\n        vec4 result = vec4(0.);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            texC = coords[1] + row;\n            depth = coords[2] + col;\n\n            vec2 uv = (vec2(texC, texR) + halfCR) /\n                       vec2(${s}.0, ${r}.0);\n            vec4 values = ${e.texture2D}(A, uv);\n            float value;\n            if (depth == 0) {\n              value = values.r;\n            } else if (depth == 1) {\n              value = values.g;\n            } else if (depth == 2) {\n              value = values.b;\n            } else if (depth == 3) {\n              value = values.a;\n            }\n\n            result[row * 2 + col] = floor(value * 255.0 + 0.5);\n          }\n        }\n\n        ${e.output} = result;\n      }\n    `}}const EL={kernelName:$h,backendName:"webgl",kernelFunc:function IL(n){const{inputs:t,backend:e,attrs:r}=n;let{pixels:s}=t;const{numChannels:o}=r,l="undefined"!=typeof HTMLVideoElement&&s instanceof HTMLVideoElement,u="undefined"!=typeof HTMLImageElement&&s instanceof HTMLImageElement,[d,h]=l?[s.videoWidth,s.videoHeight]:[s.width,s.height],p=[h,d],g=[h,d,o];if(u||l){const I=Q().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(null==Ip||I!==GE)&&(GE=I,Ip=document.createElement("canvas").getContext("2d",{willReadFrequently:GE})),Ip.canvas.width=d,Ip.canvas.height=h,Ip.drawImage(s,0,0,d,h),s=Ip.canvas}const y=e.makeTensorInfo(p,"int32");e.texData.get(y.dataId).usage=eo.PIXELS,e.gpgpu.uploadPixelDataToTexture(e.getTexture(y.dataId),s);const b=Q().getBool("WEBGL_PACK")?new SL(g):new CL(g),_=e.runWebGLProgram(b,[y],"int32");return e.disposeData(y.dataId),_}};let Ip,GE=Q().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");const TL={kernelName:du,backendName:"webgl",kernelFunc:function DL(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,filter:o,bias:l,preluActivationWeights:u}=t,{strides:d,pad:h,dataFormat:p,dilations:g,dimRoundingMode:y,activation:b,leakyreluAlpha:_}=r,I=sn(p),S=Xr(s.shape,o.shape,d,g,h,y,!1,I);let T;const O=[],V=null!=l,U=null!=u,j="leakyrelu"===b,te=()=>{const le=[s,o],Ce=(be,Me)=>{if("NCHW"===Me&&1===be.shape.length&&1!==be.shape[0]){const He=Mt({inputs:{x:be},backend:e,attrs:{shape:[be.shape[0],1,1]}});return O.push(He),He}return be};if(V&&le.push(Ce(l,p)),U&&le.push(Ce(u,p)),j){const be=e.makeTensorInfo([],"float32",_i(_,"float32"));le.push(be),O.push(be)}return le};if(1!==S.filterHeight||1!==S.filterWidth||1!==S.dilationHeight||1!==S.dilationWidth||1!==S.strideHeight||1!==S.strideWidth||"SAME"!==S.padInfo.type&&"VALID"!==S.padInfo.type)if(S.strideWidth<=2&&"channelsLast"===I&&Q().getBool("WEBGL_EXP_CONV")){const le=b?Oy(b,!0):null,Ce=new ok(S,V,le,U,j),be=[[S.padInfo.top,S.padInfo.left],[S.strideHeight,S.strideWidth],[S.dilationHeight,S.dilationWidth],[S.inHeight,S.inWidth]],Me=te();T=e.runWebGLProgram(Ce,Me,"float32",be)}else if(Q().getBool("WEBGL_CONV_IM2COL"))T=ak({x:s,filter:o,convInfo:S,backend:e,bias:l,activation:b,preluActivationWeights:u,leakyreluAlpha:_});else{const le=b?Oy(b,!1):null,Ce=new sk(S,V,le,U,j),be=te();T=e.runWebGLProgram(Ce,be,"float32")}else T=ik({x:s,filter:o,convInfo:S,backend:e,bias:l,activation:b,preluActivationWeights:u,leakyreluAlpha:_});const se=Mt({inputs:{x:T},backend:e,attrs:{shape:S.outShape}});return O.push(T),O.forEach(le=>e.disposeIntermediateTensorInfo(le)),se}},kL={kernelName:Qs,backendName:"webgl",kernelFunc:function NL(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,filter:o,bias:l,preluActivationWeights:u}=t,{strides:d,pad:h,dilations:p,dimRoundingMode:g,activation:y,leakyreluAlpha:b}=r,_=[];let I=p;null==I&&(I=[1,1]),G(Ns(d,I),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${d} and dilations '${I}'`);const S=Xr(s.shape,o.shape,d,I,h,g,!0),T=Q().getBool("WEBGL_PACK_DEPTHWISECONV")&&S.strideWidth<=2&&S.outChannels/S.inChannels==1,O=y?Oy(y,T):null,V=[s,o],U=null!=l,j=null!=u,te="leakyrelu"===y;if(U&&V.push(l),j&&V.push(u),te){const be=e.makeTensorInfo([],"float32",_i(b,"float32"));V.push(be),_.push(be)}let se;se=T?new fk(S,U,O,j,te):new hk(S,U,O,j,te);const Ce=e.runWebGLProgram(se,V,"float32",[[S.padInfo.top,S.padInfo.left],[S.strideHeight,S.strideWidth],[S.dilationHeight,S.dilationWidth],[S.inHeight,S.inWidth]]);return _.forEach(be=>e.disposeIntermediateTensorInfo(be)),Ce}};class AL{constructor(t,e,r,s){this.sliceDim=t,this.strides=e,this.paramsShape=s,this.variableNames=["x","indices"],this.outputShape=r;const o=ir(r.length);let l="\n    int index;";for(let u=0;u<this.sliceDim;u++)l+=`\n          index = round(getIndices(coords[0], ${u}));\n          out_of_bounds = out_of_bounds || index < 0;\n          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[u]};\n          flattenIndex += index * ${this.strides[u]};`;this.userCode=`\n         void main() {\n          ${o} coords = getOutputCoords();\n          int flattenIndex = 0;\n          bool out_of_bounds = false;\n\n          ${l}\n\n          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));\n        }\n      `}}const ML={kernelName:ll,backendName:"webgl",kernelFunc:function RL(n){const{inputs:t,backend:e}=n,{params:r,indices:s}=t,o=s.shape,l=o[o.length-1],u=Ee(r.shape),[d,h,p,g]=Vc(r,s),y=Mt({inputs:{x:s},backend:e,attrs:{shape:[h,l]}}),b=Mt({inputs:{x:r},backend:e,attrs:{shape:[Ee(r.shape)/p,p]}});if(e.shouldExecuteOnCPU([r,s])||"string"===r.dtype){const T=e.readSync(s.dataId),O=e.bufferSync(r),V=KM(T,O,r.dtype,h,l,p,g,r.shape,u);return e.makeTensorInfo(d,r.dtype,V.values)}const _=new AL(l,g,[h,p],r.shape),I=e.runWebGLProgram(_,[b,y],b.dtype),S=Mt({inputs:{x:I},backend:e,attrs:{shape:d}});return e.disposeIntermediateTensorInfo(y),e.disposeIntermediateTensorInfo(b),e.disposeIntermediateTensorInfo(I),S}};class OL{constructor(t,e){this.variableNames=["A","indices"],this.outputShape=e,this.rank=e.length;const r=ir(this.rank),s=function FL(n,t){const e=["resRC.x","resRC.y","resRC.z","resRC.w"],r=[];for(let s=0;s<n.length;s++)r.push(2===s?"index":`${e[s]}`);return r.join()}(t);this.userCode=`\n      void main() {\n        ${r} resRC = getOutputCoords();\n        int index = int(getIndices(resRC.x, resRC.z));\n        float inBounds = (index >= 0) && (index < ${t[2]}) ? 1.0 : 0.0;\n        setOutput(inBounds * getA(${s}));\n      }\n    `}}function bk(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,indices:o}=t,{axis:l,batchDims:u}=r,d=Tt(l,s.shape)[0];if(Q().get("DEBUG")){const O=e.readSync(o.dataId),V=s.shape[d];for(let U=0;U<O.length;++U){const j=O[U];G(j<=V-1&&j>=0,()=>`GatherV2: the index value ${j} is not in [0, ${V-1}]`)}}const h=ks(s,o,d,u),p=Ee(o.shape),g=[],y=Mt({inputs:{x:s},backend:e,attrs:{shape:[h.batchSize,h.outerSize,h.dimSize,h.sliceSize]}}),b=Mt({inputs:{x:o},backend:e,attrs:{shape:[h.batchSize,p/h.batchSize]}});g.push(y),g.push(b);const _=[h.batchSize,h.outerSize,p/h.batchSize,h.sliceSize];if(e.shouldExecuteOnCPU([s,o])||"string"===s.dtype){const O=e.bufferSync(b),V=e.bufferSync(y),U=qM(V,O,_);return g.forEach(j=>e.disposeIntermediateTensorInfo(j)),e.makeTensorInfo(h.outputShape,U.dtype,U.values)}const I=new OL(y.shape,_),S=e.runWebGLProgram(I,[y,b],y.dtype);g.push(S);const T=Mt({inputs:{x:S},backend:e,attrs:{shape:h.outputShape}});return g.forEach(O=>e.disposeIntermediateTensorInfo(O)),T}const $L={kernelName:To,backendName:"webgl",kernelFunc:bk},PL=Ws({opSnippet:"return float(a > b);",packedOpSnippet:"\n  return vec4(greaterThan(a, b));\n",cpuKernelImpl:XM,dtype:"bool"}),LL={kernelName:cl,backendName:"webgl",kernelFunc:PL},BL=Ws({opSnippet:"return float(a >= b);",packedOpSnippet:"\n  return vec4(greaterThanEqual(a, b));\n",dtype:"bool",cpuKernelImpl:YM}),VL={kernelName:Bi,backendName:"webgl",kernelFunc:BL},zL={kernelName:Ca,backendName:"webgl",kernelFunc:function UL(n){const{inputs:t,backend:e}=n,{input:r}=t;return yk(r,!0,e)}},HL=Ln({opSnippet:"return float(!isnan(x) && !isinf(x));",dtype:"bool"}),WL={kernelName:No,backendName:"webgl",kernelFunc:HL},jL=Ln({opSnippet:"return float(isinf(x));",dtype:"bool"}),GL={kernelName:Ui,backendName:"webgl",kernelFunc:jL},KL=Ln({opSnippet:"return float(isnan(x));",dtype:"bool"}),qL={kernelName:Sa,backendName:"webgl",kernelFunc:KL},XL=Ws({opSnippet:"return float(a < b);",packedOpSnippet:"\n  return vec4(lessThan(a, b));\n",cpuKernelImpl:ZM,dtype:"bool"}),YL={kernelName:eu,backendName:"webgl",kernelFunc:XL},ZL=Ws({opSnippet:"return float(a <= b);",packedOpSnippet:"\n  return vec4(lessThanEqual(a, b));\n",cpuKernelImpl:QM,dtype:"bool"}),QL={kernelName:jn,backendName:"webgl",kernelFunc:ZL},e3={kernelName:ul,backendName:"webgl",kernelFunc:function JL(n){const{backend:t,attrs:e}=n,{start:r,stop:s,num:o}=e,l=JM(r,s,o);return t.makeTensorInfo([l.length],"float32",l)}},n3=Ln({opSnippet:"if (isnan(x)) return x;\n  return x < 0.0 ? 0./0. : log(x);\n",packedOpSnippet:"\n  vec4 result = log(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);\n  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);\n  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);\n  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);\n  return result;\n",cpuKernelImpl:eO}),r3={kernelName:dl,backendName:"webgl",kernelFunc:n3},o3=Ln({opSnippet:"if (isnan(x)) return x;\n  return log(1.0 + x);\n"}),a3={kernelName:Wo,backendName:"webgl",kernelFunc:o3},l3=Ws({opSnippet:"return float(a >= 1.0 && b >= 1.0);",packedOpSnippet:"\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n",dtype:"bool"}),c3={kernelName:Ur,backendName:"webgl",kernelFunc:l3},u3=Ln({opSnippet:"return float(!(x >= 1.0));"}),d3={kernelName:jo,backendName:"webgl",kernelFunc:u3},h3=Ws({opSnippet:"return float(a >= 1.0 || b >= 1.0);",packedOpSnippet:"\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n",dtype:"bool"}),f3={kernelName:zi,backendName:"webgl",kernelFunc:h3};class p3{constructor(t,e,r,s,o){this.variableNames=["x"],this.outputShape=[];const l=e,u=t[3]-1;let d;this.outputShape=t;const h=`float(${r}) + float(${s}) * sum`;d=.5===o?`inversesqrt(${h})`:1===o?`1.0/(${h})`:`exp(log(${h}) * float(-${o}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -${l}; j <= ${l}; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  ${u}) {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * ${d};\n        setOutput(val);\n      }\n    `}}class m3{constructor(t,e,r,s,o){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const l=e,u=t[3]-1;let d;this.outputShape=t;const h=`float(${r}) + float(${s}) * sum`;d=.5===o?`inversesqrt(${h})`:1===o?`1.0/(${h})`:`exp(log(${h}) * float(-${o}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < ${this.outputShape[3]};\n        bool hasNextRow = c < ${this.outputShape[2]};\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - ${l};\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - ${l}; j <= ${l}; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${u}));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * ${d};\n        setOutput(result);\n      }\n    `}}const g3={kernelName:"LRN",backendName:"webgl",kernelFunc:n=>{const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{depthRadius:o,bias:l,alpha:u,beta:d}=r,h=Q().getBool("WEBGL_PACK_NORMALIZATION")?new m3(s.shape,o,l,u,d):new p3(s.shape,o,l,u,d);return e.runWebGLProgram(h,[s],s.dtype)}};class y3{constructor(t,e,r,s,o){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=t,this.depth=t[3],this.depthRadius=e,this.bias=r,this.alpha=s,this.beta=o,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < ${this.depth}; ++d) {\n          int depthBegin = int(max(0.0, float(d - ${e})));\n          int depthEnd = int(min(float(${this.depth}),\n              float(d + ${e} + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = ${this.depth};\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float(${s}) * norm + float(${r});\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float(${s})\n                * float(${o})\n                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * ${o});\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    `}}const v3={kernelName:tu,backendName:"webgl",kernelFunc:n=>{const{inputs:t,backend:e,attrs:r}=n,{x:s,y:o,dy:l}=t,{depthRadius:u,bias:d,alpha:h,beta:p}=r,g=new y3(s.shape,u,d,h,p);return e.runWebGLProgram(g,[s,o,l],s.dtype)}};function _k(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{reductionIndices:o,keepDims:l}=r,u=s.shape.length,d=Tt(o,s.shape);let h=d;const p=pr(h,u),g=null!=p,y=e.shouldExecuteOnCPU([s]);let b=s;if(g){if(y){const V=e.texData.get(b.dataId).values,U=new Array(u);for(let se=0;se<U.length;se++)U[se]=s.shape[p[se]];const j=BE(V,s.shape,s.dtype,p,U);b=e.makeTensorInfo(U,s.dtype),e.texData.get(b.dataId).values=j}else b=rx(s,p,e);h=_r(h.length,u)}_s("max",h,u);const[_,I]=as(b.shape,h);let T,S=_;if(l&&(S=Yr(_,d)),y){const V=e.texData.get(b.dataId).values,U=tO(V,Ee(I),S,s.dtype);T=e.makeTensorInfo(S,s.dtype),e.texData.get(T.dataId).values=U}else T=function b3(n,t,e,r){const s=Ee(t),u=Mt({inputs:{x:n},attrs:{shape:[Ee(n.shape)/s,s]},backend:r}),d=Th(u,n.dtype,"max",r),h=Mt({inputs:{x:d},attrs:{shape:e},backend:r});return r.disposeIntermediateTensorInfo(u),r.disposeIntermediateTensorInfo(d),h}(b,I,S,e);return g&&e.disposeIntermediateTensorInfo(b),T}const _3={kernelName:"Max",backendName:"webgl",kernelFunc:_k},C3=Ws({opSnippet:"\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return max(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(max(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  \n  result.r = isNaN.r ? NAN : result.r;\n  result.g = isNaN.g ? NAN : result.g;\n  result.b = isNaN.b ? NAN : result.b;\n  result.a = isNaN.a ? NAN : result.a;\n\n  return result;\n",cpuKernelImpl:nO}),S3={kernelName:Da,backendName:"webgl",kernelFunc:C3},I3={kernelName:hn,backendName:"webgl",kernelFunc:function E3(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t;Wc(s,"maxPool");const{filterSize:o,strides:l,pad:u,dimRoundingMode:d}=r;G(Ns(l,1),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${l} and dilations '1'`);const p=$o(s.shape,o,l,1,u,d);if(1===p.filterWidth&&1===p.filterHeight&&un(p.inShape,p.outShape))return ui({inputs:{x:s},backend:e});const g=new Fy(p,"max",!1);return e.runWebGLProgram(g,[s],s.dtype)}},T3={kernelName:yd,backendName:"webgl",kernelFunc:function D3(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{filterSize:o,strides:l,pad:u,dataFormat:d,dimRoundingMode:h}=r,g=Ka(s.shape,o,l,[1,1,1],u,h,d),y=new zE(g,"max",!1);return e.runWebGLProgram(y,[s],s.dtype)}};class N3{constructor(t){this.variableNames=["dy","maxPos"],this.outputShape=t.inShape;const o=t.effectiveFilterHeight,l=t.effectiveFilterWidth;this.userCode=`\n      const ivec2 pads = ivec2(${o-1-t.padInfo.top}, ${l-1-t.padInfo.left});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${o};\n          wR += ${t.dilationHeight}) {\n          float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${l}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = ${o*l-1} - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * ${l} + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class k3{constructor(t){this.variableNames=["dy","maxPos"],this.outputShape=t.inShape;const d=t.effectiveFilterDepth,h=t.effectiveFilterHeight,p=t.effectiveFilterWidth;this.userCode=`\n      const ivec3 pads = ivec3(${d-1-t.padInfo.front}, ${h-1-t.padInfo.top}, ${p-1-t.padInfo.left});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${d};\n           wD += ${t.dilationDepth}) {\n          float dyD = float(dyDCorner + wD) / ${t.strideDepth}.0;\n\n          if (dyD < 0.0 || dyD >= ${t.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${h};\n              wR += ${t.dilationHeight}) {\n            float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${p};\n                wC += ${t.dilationWidth}) {\n              float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              int maxPosValue = ${d*h*p-1} -\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              int curPosValue =\n                  wD * ${h} * ${p} +\n                  wR * ${p} + wC;\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const R3={kernelName:hl,backendName:"webgl",kernelFunc:function A3(n){const{inputs:t,backend:e,attrs:r}=n,{dy:s,input:o}=t,l=o,{filterSize:u,strides:d,pad:h,dimRoundingMode:p}=r,y=Ka(l.shape,u,d,[1,1,1],h,p),b=new zE(y,"max",!0),_=e.runWebGLProgram(b,[l],l.dtype),I=new k3(y),S=e.runWebGLProgram(I,[s,_],l.dtype);return e.disposeIntermediateTensorInfo(_),S}},O3={kernelName:nu,backendName:"webgl",kernelFunc:function M3(n){const{inputs:t,backend:e,attrs:r}=n,{dy:s,input:o,output:l}=t,u=o;Wc([o,l],"maxPoolGrad");const{filterSize:d,strides:h,pad:p,dimRoundingMode:g}=r,y=$o(u.shape,d,h,1,p,g),_=new Fy(y,"max",!0),I=e.runWebGLProgram(_,[u],u.dtype),S=new N3(y),T=e.runWebGLProgram(S,[s,I],u.dtype);return e.disposeIntermediateTensorInfo(I),T}},$3={kernelName:ac,backendName:"webgl",kernelFunc:({inputs:n,attrs:t,backend:e})=>{const{x:r}=n,{filterSize:s,strides:o,pad:l,includeBatchInIndex:u}=t,d=e;G(4===r.shape.length,()=>`Error in maxPool: input must be rank 4 but got rank ${r.shape.length}.`);const h=[1,1];G(Ns(o,h),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${h}'`);const p=$o(r.shape,s,o,h,l),[g,y]=function F3(n,t,e,r){let s=new Fy(e,"max",!1);const o=r.runWebGLProgram(s,[n],"float32");return s=new Fy(e,"max",!0,!0,t),[o,r.runWebGLProgram(s,[n],"float32")]}(r,u,p,d);return[g,y]}},L3={kernelName:ru,backendName:"webgl",kernelFunc:({inputs:n,attrs:t,backend:e})=>{const{x:r}=n,{keepDims:s,axis:o}=t,l=e,u=r.shape.length,d=Tt(o,r.shape);let h=d;const p=pr(h,u),g=null!=p,y=l.shouldExecuteOnCPU([r]),b=[];let _=r;if(g){if(y){const U=l.texData.get(_.dataId).values,j=new Array(u);for(let le=0;le<j.length;le++)j[le]=r.shape[p[le]];const te=BE(U,r.shape,r.dtype,p,j);_=l.makeTensorInfo(j,r.dtype),l.texData.get(_.dataId).values=te}else _=rx(r,p,l);b.push(_),h=_r(h.length,u)}_s("sum",h,u);const[I,S]=as(_.shape,h);let T=I;s&&(T=Yr(I,d));const O=function P3(n,t,e,r){const s=Ee(t),u=Mt({inputs:{x:n},attrs:{shape:[Ee(n.shape)/s,s]},backend:r}),d=Th(u,"float32","mean",r),h=Mt({inputs:{x:d},attrs:{shape:e},backend:r});return r.disposeIntermediateTensorInfo(u),r.disposeIntermediateTensorInfo(d),h}(_,S,T,l);for(const V of b)l.disposeIntermediateTensorInfo(V);return O}},V3={kernelName:"Min",backendName:"webgl",kernelFunc:function B3(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:o,keepDims:l}=r,u=s.shape.length,d=Tt(o,s.shape);let h=d;const p=pr(h,u);let g=s;null!=p&&(g=vo({inputs:{x:s},backend:e,attrs:{perm:p}}),h=_r(h.length,s.shape.length)),_s("min",h,u);const[y,b]=as(g.shape,h),I=Mt({inputs:{x:g},backend:e,attrs:{shape:[-1,Ee(b)]}}),S=Th(I,I.dtype,"min",e);let T;return T=Mt(l?{inputs:{x:S},backend:e,attrs:{shape:Yr(y,d)}}:{inputs:{x:S},backend:e,attrs:{shape:y}}),e.disposeIntermediateTensorInfo(I),e.disposeIntermediateTensorInfo(S),null!=p&&e.disposeIntermediateTensorInfo(g),T}},H3=Ws({opSnippet:"\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return min(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(min(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  \n  result.r = isNaN.r ? NAN : result.r;\n  result.g = isNaN.g ? NAN : result.g;\n  result.b = isNaN.b ? NAN : result.b;\n  result.a = isNaN.a ? NAN : result.a;\n\n  return result;\n",cpuKernelImpl:rO}),W3={kernelName:Hi,backendName:"webgl",kernelFunc:H3};class j3{constructor(t,e,r){this.variableNames=["x"],this.outputShape=e.map((p,g)=>p[0]+t[g]+p[1]);const s=t.length,o=ir(s),l=e.map(p=>p[0]).join(","),u=e.map((p,g)=>p[0]+t[g]).join(","),d=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,s),h="reflect"===r?0:1;this.userCode=1!==s?`\n      ${o} start = ${o}(${l});\n      ${o} end = ${o}(${u});\n\n      void main() {\n        ${o} outC = getOutputCoords();\n        for (int i = 0; i < ${s}; i++) {\n          if (outC[i] < start[i]) {\n            outC[i] = start[i] * 2 - outC[i] - ${h};\n          } else if(outC[i] >= end[i]) {\n            outC[i] = (end[i] - 1) * 2 - outC[i] + ${h};\n          }\n        }\n        ${o} coords = outC - start;\n        setOutput(getX(${d}));\n      }\n    `:`\n        int start = ${l};\n        int end = ${u};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start) {\n            outC = start * 2 - outC - ${h};\n          } else if(outC >= end) {\n            outC = (end - 1) * 2 - outC + ${h};\n          }\n          setOutput(getX(outC - start));\n        }\n      `}}class G3{constructor(t,e,r){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e.map((_,I)=>_[0]+t[I]+_[1]);const s=t.length,o=ir(s),l=e.map(_=>_[0]).join(","),u=e.map((_,I)=>_[0]+t[I]).join(","),d=yo("rc",s),h=yo("source",s),p=`${d[s-1]} < ${this.outputShape[s-1]}`,g=1===s?"source":`vec2(${h.slice(-2).join()})`,y="reflect"===r?0:1;let b="";if(1===s){const _=`\n        ${o} source = rc;\n        if (source < start) {\n          source = start * 2 - source - ${y};\n        } else if (source >= end) {\n          source = (end - 1) * 2 - source + ${y};\n        }\n        source -= start;\n      `;b=`\n        ${o} rc = outputLoc;\n        ${_}\n        result[0] = getChannel(getX(${h.join()}), ${g});\n        ${d[s-1]} += 1;\n        if(${p}) {\n          ${_}\n          result[1] = getChannel(getX(${h.join()}), ${g});\n        }\n      `}else{const _=`\n        ${o} source = rc;\n        ${o} lt = ${o}(lessThan(source, start));\n        ${o} gte = ${o}(greaterThanEqual(source, end));\n        ${o} orig = 1 - (lt + gte);\n        source = orig * source +\n                lt * (start * 2 - source - ${y}) +\n                gte * ((end - 1) * 2 - source + ${y});\n        source -= start;\n      `;b=`\n        ${o} rc = outputLoc;\n        ${_}\n        result[0] = getChannel(getX(${h.join()}), ${g});\n        ${d[s-1]} += 1;\n        if(${p}) {\n          ${_}\n          result[1] = getChannel(getX(${h.join()}), ${g});\n        }\n        rc = outputLoc;\n        ${d[s-2]} += 1;\n        if(${d[s-2]} < ${this.outputShape[s-2]}) {\n          ${_}\n          result[2] = getChannel(getX(${h.join()}), ${g});\n          ${d[s-1]} += 1;\n          if(${p}) {\n            ${_}\n            result[3] = getChannel(getX(${h.join()}), ${g});\n          }\n        }\n      `}this.userCode=`\n      const ${o} start = ${o}(${l});\n      const ${o} end = ${o}(${u});\n\n      void main() {\n        ${o} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${b}\n        setOutput(result);\n      }\n    `}}const K3={kernelName:ms,backendName:"webgl",kernelFunc:({inputs:n,backend:t,attrs:e})=>{const{x:r}=n,{paddings:s,mode:o}=e,l=Q().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new G3(r.shape,s,o):new j3(r.shape,s,o);return t.runWebGLProgram(l,[r],r.dtype)}},Y3=Ws({opSnippet:"if (b == 0.0) return NAN;\n  return mod(a, b);",packedOpSnippet:"\n  vec4 result = mod(a, b);\n  bvec4 isNaN = equal(b, vec4(0.0));\n  \n  result.r = isNaN.r ? NAN : result.r;\n  result.g = isNaN.g ? NAN : result.g;\n  result.b = isNaN.b ? NAN : result.b;\n  result.a = isNaN.a ? NAN : result.a;\n\n  return result;\n"}),Z3={kernelName:st,backendName:"webgl",kernelFunc:Y3};class Q3{constructor(t,e,r){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[t,r],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < ${e-1}; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(${e-1}));\n      }\n    `}}const xk=Ws({opSnippet:"\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;",packedOpSnippet:"\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n",checkOutOfBounds:!0}),J3={kernelName:rc,backendName:"webgl",kernelFunc:xk},wk="return a - b;",Ck=Ws({opSnippet:wk,packedOpSnippet:wk,supportsComplex:!0,cpuKernelImpl:SO}),eB={kernelName:Tn,backendName:"webgl",kernelFunc:Ck};function Sk(n){const{inputs:t,backend:e,attrs:r}=n,{logits:s}=t,{dim:o}=r,l=Tt([o],s.shape),u=_k({inputs:{x:s},backend:e,attrs:{reductionIndices:l,keepDims:!1}}),d=Yr(u.shape,l),h=Mt({inputs:{x:u},backend:e,attrs:{shape:d}}),p=Ck({inputs:{a:s,b:h},backend:e}),g=pk({inputs:{x:p},backend:e}),y=sx({inputs:{x:g},backend:e,attrs:{axis:l,keepDims:!1}}),b=Mt({inputs:{x:y},backend:e,attrs:{shape:d}}),_=xk({inputs:{a:g,b},backend:e});return e.disposeIntermediateTensorInfo(u),e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(g),e.disposeIntermediateTensorInfo(y),e.disposeIntermediateTensorInfo(b),_}const tB={kernelName:qo,backendName:"webgl",kernelFunc:Sk},rB={kernelName:_n,backendName:"webgl",kernelFunc:function nB(n){const{inputs:t,backend:e,attrs:r}=n,{logits:s}=t,{numSamples:o,seed:l,normalized:u}=r,d=u?s:Sk({inputs:{logits:s},backend:e,attrs:{dim:s.shape.length-1}}),g=new Q3(d.shape[0],d.shape[1],o),b=e.runWebGLProgram(g,[d],"int32",[[l]]);return u||e.disposeIntermediateTensorInfo(d),b}},aB={kernelName:"Neg",backendName:"webgl",kernelFunc:function iB(n){const{inputs:t,backend:e}=n,{x:r}=t;if(e.shouldExecuteOnCPU([r])){const o=e.texData.get(r.dataId),[l,u]=oO(o.values,r.shape,r.dtype);return e.makeTensorInfo(u,r.dtype,l)}let s;return s=Q().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new od(r.shape,"\n  vec4 result = -x;\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"):new Yl(r.shape,"if (isnan(x)) return x;\n  return -x;\n"),e.runWebGLProgram(s,[r],r.dtype)}},lB=_g,uB={kernelName:Wi,backendName:"webgl",kernelFunc:function cB(n){Js("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:e,attrs:r}=n,{boxes:s,scores:o}=t,{maxOutputSize:l,iouThreshold:u,scoreThreshold:d}=r,h=e.readSync(s.dataId),p=e.readSync(o.dataId),{selectedIndices:g}=lB(h,p,l,u,d);return e.makeTensorInfo([g.length],"int32",new Int32Array(g))}},dB=xg,fB={kernelName:ji,backendName:"webgl",kernelFunc:function hB(n){Js("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:e,attrs:r}=n,{boxes:s,scores:o}=t,{maxOutputSize:l,iouThreshold:u,scoreThreshold:d,padToMaxOutputSize:h}=r,p=e.readSync(s.dataId),g=e.readSync(o.dataId),{selectedIndices:y,validOutputs:b}=dB(p,g,l,u,d,h);return[e.makeTensorInfo([y.length],"int32",new Int32Array(y)),e.makeTensorInfo([],"int32",new Int32Array([b]))]}},pB=Bc,gB={kernelName:Xs,backendName:"webgl",kernelFunc:function mB(n){Js("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:e,attrs:r}=n,{boxes:s,scores:o}=t,{maxOutputSize:l,iouThreshold:u,scoreThreshold:d,softNmsSigma:h}=r,p=e.readSync(s.dataId),g=e.readSync(o.dataId),y=l,b=u,_=d,I=h,{selectedIndices:S,selectedScores:T}=pB(p,g,y,b,_,I);return[e.makeTensorInfo([S.length],"int32",new Int32Array(S)),e.makeTensorInfo([T.length],"float32",new Float32Array(T))]}};class yB{constructor(t,e,r,s){this.variableNames=["indices"],this.outputShape=[t,e],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(${s}), float(${r}),\n                      float(index == coords.y)));\n      }\n    `}}const vB={kernelName:Go,backendName:"webgl",kernelFunc:n=>{const{inputs:t,backend:e,attrs:r}=n,{indices:s}=t,{dtype:o,depth:l,onValue:u,offValue:d}=r,h=Ee(s.shape),p=new yB(h,l,u,d),g=Mt({inputs:{x:s},backend:e,attrs:{shape:[h]}}),y=e.runWebGLProgram(p,[g],o);e.disposeIntermediateTensorInfo(g);const _=Mt({inputs:{x:y},backend:e,attrs:{shape:[...s.shape,l]}});return e.disposeIntermediateTensorInfo(y),_}};function ux(n){const{inputs:t,backend:e}=n,{x:r}=t;if("complex64"===r.dtype){const s=$y({inputs:{input:r},backend:e}),o=ux({inputs:{x:s},backend:e}),l=lx({inputs:{input:r},backend:e}),u=ux({inputs:{x:l},backend:e}),d=id({inputs:{real:o,imag:u},backend:e});return e.disposeIntermediateTensorInfo(s),e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(l),e.disposeIntermediateTensorInfo(u),d}return Ly({attrs:{shape:r.shape,dtype:r.dtype,value:"string"===r.dtype?"":0},backend:e})}const bB={kernelName:Yo,backendName:"webgl",kernelFunc:ux},_B={kernelName:Ao,backendName:"webgl",kernelFunc:function Ek(n){const{inputs:t,backend:e}=n,{x:r}=t;if("string"===r.dtype)throw new Error("onesLike is not supported under string dtype");if("complex64"===r.dtype){const s=$y({inputs:{input:r},backend:e}),o=Ek({inputs:{x:s},backend:e}),l=lx({inputs:{input:r},backend:e}),u=ux({inputs:{x:l},backend:e}),d=id({inputs:{real:o,imag:u},backend:e});return e.disposeIntermediateTensorInfo(s),e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(l),e.disposeIntermediateTensorInfo(u),d}return Ly({attrs:{shape:r.shape,dtype:r.dtype,value:1},backend:e})}},wB={kernelName:su,backendName:"webgl",kernelFunc:function xB(n){const{inputs:t,backend:e,attrs:r}=n,{axis:s}=r;if(1===t.length)return jE({inputs:{input:t[0]},backend:e,attrs:{dim:s}});const o=t[0].shape,l=t[0].dtype;t.forEach(p=>{bn(o,p.shape,"All tensors passed to stack must have matching shapes"),G(l===p.dtype,()=>"All tensors passed to stack must have matching dtypes")});const u=[],h=rk({inputs:t.map(p=>{const g=jE({inputs:{input:p},backend:e,attrs:{dim:s}});return u.push(g),g}),backend:e,attrs:{axis:s}});return u.forEach(p=>e.disposeIntermediateTensorInfo(p)),h}};class CB{constructor(t,e,r){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=e.map((h,p)=>h[0]+t[p]+h[1]);const s=t.length,o=ir(s),l=e.map(h=>h[0]).join(","),u=e.map((h,p)=>h[0]+t[p]).join(","),d=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,s);this.userCode=1!==s?`\n      ${o} start = ${o}(${l});\n      ${o} end = ${o}(${u});\n\n      void main() {\n        ${o} outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(value);\n        } else {\n          ${o} coords = outC - start;\n          setOutput(getX(${d}));\n        }\n      }\n    `:`\n        int start = ${l};\n        int end = ${u};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(value);\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      `}}class SB{constructor(t,e,r){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=e.map((I,S)=>I[0]+t[S]+I[1]);const s=t.length,o=ir(s),l=e.map(I=>I[0]).join(","),u=e.map((I,S)=>I[0]+t[S]).join(","),d=yo("rc",s),h=yo("source",s),p=`${d[s-1]} < ${this.outputShape[s-1]}`,g=1===s?"source":`vec2(${h.slice(-2).join()})`,y=[`${o} rc = outputLoc;`,`${d[s-1]} += 1;\n       if(${p}) {\n      `,1===s?"":`}\n       rc = outputLoc;\n       ${d[s-2]} += 1;\n       if(${d[s-2]} < ${this.outputShape[s-2]}) {`,1===s?"":`  ${d[s-1]} += 1;\n         if(${p}) {`],b=1===s?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let _="";for(let I=0,S=1===s?2:4;I<S;I++)_+=`\n        ${y[I]}\n        if (${b}) {\n          result[${I}] = float(value);\n        } else {\n          ${o} source = rc - start;\n          result[${I}] = getChannel(getX(${h.join()}), ${g});\n        }\n      `;_+=1===s?"} ":"}}",this.userCode=`\n      const ${o} start = ${o}(${l});\n      const ${o} end = ${o}(${u});\n\n      void main() {\n        ${o} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${_}\n        setOutput(result);\n      }\n    `}}const Ik=n=>{const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{paddings:o,constantValue:l}=r;if(0===Ee(s.shape))return Ly({backend:e,attrs:{shape:o.map((p,g)=>p[0]+s.shape[g]+p[1]),value:l,dtype:s.dtype}});const u=Q().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new SB(s.shape,o,l):new CB(s.shape,o,l);return e.runWebGLProgram(u,[s],s.dtype,[[l]])},EB={kernelName:ou,backendName:"webgl",kernelFunc:Ik},TB=Ws({opSnippet:"\n  if(a < 0.0 && floor(b) < b){\n    return NAN;\n  }\n  if (b == 0.0) {\n    return 1.0;\n  }\n  return (round(mod(b, 2.0)) != 1) ?\n      pow(abs(a), b) : sign(a) * pow(abs(a), b);\n",packedOpSnippet:"\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  bvec4 isNaN1 = lessThan(a, vec4(0.0));\n  bvec4 isNaN2 = lessThan(floor(b), b);\n  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);\n  \n  result.r = isNaN.r ? NAN : result.r;\n  result.g = isNaN.g ? NAN : result.g;\n  result.b = isNaN.b ? NAN : result.b;\n  result.a = isNaN.a ? NAN : result.a;\n\n  return result;\n"}),NB={kernelName:Ko,backendName:"webgl",kernelFunc:TB},AB={kernelName:Ys,backendName:"webgl",kernelFunc:function kB(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:o,keepDims:l}=r,u=s.shape.length,d=[],h=Tt(o,s.shape);let p=h;const g=pr(p,u);let b,y=s;if(null!=g&&(y=vo({inputs:{x:s},backend:e,attrs:{perm:g}}),p=_r(p.length,u),d.push(y)),_s("prod",p,u),e.shouldExecuteOnCPU([y])){const _=e.texData.get(y.dataId).values,{outVals:I,outShape:S,outDtype:T}=aO(y.shape,y.dtype,_,p);b=e.makeTensorInfo(S,T,I)}else{const[_,I]=as(y.shape,p),S=Ee(I),T=Mt({inputs:{x:y},backend:e,attrs:{shape:[-1,S]}}),V=Th(T,lt(s.dtype),"prod",e);b=Mt({inputs:{x:V},backend:e,attrs:{shape:_}}),d.push(T),d.push(V)}if(l){d.push(b);const _=Yr(b.shape,h);b=Mt({inputs:{x:b},backend:e,attrs:{shape:_}})}return d.forEach(_=>e.disposeIntermediateTensorInfo(_)),b}},MB={kernelName:ml,backendName:"webgl",kernelFunc:function RB(n){const{inputs:t,backend:e,attrs:r}=n,{paramsNestedSplits:s,paramsDenseValues:o,indices:l}=t,{outputRaggedRank:u}=r,d=s.map(T=>e.readSync(T.dataId)),h=s.map(T=>T.shape),p=e.readSync(o.dataId),g=e.readSync(l.dataId),[y,b,_]=lO(d,h,p,o.shape,o.dtype,g,l.shape,u),I=y.map(T=>e.makeTensorInfo([T.length],"int32",T)),S=e.makeTensorInfo(_,o.dtype,b);return I.concat([S])}},FB={kernelName:so,backendName:"webgl",kernelFunc:function OB(n){const{inputs:t,backend:e}=n,{starts:r,limits:s,deltas:o}=t,l=e.readSync(r.dataId),u=e.readSync(s.dataId),d=e.readSync(o.dataId),[h,p]=cO(l,r.shape,r.dtype,u,s.shape,d,o.shape);return[e.makeTensorInfo([h.length],"int32",h),e.makeTensorInfo([p.length],r.dtype,p)]}},PB={kernelName:rs,backendName:"webgl",kernelFunc:function $B(n){const{inputs:t,backend:e,attrs:r}=n,{shape:s,values:o,defaultValue:l,rowPartitionTensors:u}=t,{rowPartitionTypes:d}=r,h=e.readSync(s.dataId),p=e.readSync(o.dataId),g=e.readSync(l.dataId),y=u.map(S=>e.readSync(S.dataId)),b=u.map(S=>S.shape),[_,I]=uO(h,s.shape,p,o.shape,o.dtype,g,l.shape,y,b,d);return e.makeTensorInfo(_,o.dtype,I)}},Dk=n=>{const{backend:t,attrs:e}=n,{start:r,stop:s,step:o,dtype:l}=e,u=dO(r,s,o,l);return t.makeTensorInfo([u.length],l,u)},LB={kernelName:au,backendName:"webgl",kernelFunc:Dk},BB=Ln({opSnippet:"return 1.0 / x;"}),VB={kernelName:Ta,backendName:"webgl",kernelFunc:BB},zB=Ln({opSnippet:"if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : x;\n",packedOpSnippet:"\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),HB={kernelName:mi,backendName:"webgl",kernelFunc:zB},jB=Ln({opSnippet:"if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",packedOpSnippet:"\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),GB={kernelName:gl,backendName:"webgl",kernelFunc:jB};class KB{constructor(t,e,r,s,o){this.variableNames=["A"],this.outputShape=[];const[l,u,d,h]=t;this.outputShape=[l,e,r,h];const p=[s&&e>1?u-1:u,s&&r>1?d-1:d],g=[s&&e>1?e-1:e,s&&r>1?r-1:r];let y;y=o?"(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${p[0]/g[0]},\n          ${p[1]/g[1]});\n      const vec2 inputShapeRC = vec2(${u}.0, ${d}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${y};\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    `}}class qB{constructor(t,e,r,s,o){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[l,u,d,h]=t;this.outputShape=[l,e,r,h];const p=[s&&e>1?u-1:u,s&&r>1?d-1:d],g=[s&&e>1?e-1:e,s&&r>1?r-1:r];let y;y=o?"(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${p[0]/g[0]},\n          ${p[1]/g[1]},\n          ${p[1]/g[1]});\n      const vec3 inputShapeRC = vec3(${u}.0, ${d}.0,\n                                     ${d}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${y};\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${h-1};\n        bool hasNextRow = coords.z < ${r-1};\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    `}}const YB={kernelName:Gi,backendName:"webgl",kernelFunc:function XB(n){const{inputs:t,backend:e,attrs:r}=n,{images:s}=t,{alignCorners:o,halfPixelCenters:l,size:u}=r,[d,h]=u,p=Q().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new qB(s.shape,d,h,o,l):new KB(s.shape,d,h,o,l);return e.runWebGLProgram(p,[s],"float32")}};class ZB{constructor(t,e,r){this.variableNames=["dy"],this.outputShape=[],this.outputShape=e;const[,s,o]=e,[,l,u]=t,d=[r&&l>1?s-1:s,r&&u>1?o-1:o],h=[r&&l>1?l-1:l,r&&u>1?u-1:u],p=d[0]/h[0],g=d[1]/h[1],y=1/p,b=1/g,_=2*Math.ceil(y)+2,I=2*Math.ceil(b)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${p});\n        const float widthScale = float(${g});\n\n        const float invHeightScale = float(${y});\n        const float invWidthScale = float(${b});\n\n        const int winHeight = int(${_});\n        const int winWidth = int(${I});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${l}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${u}) {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), ${s-1}.0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), ${o-1}.0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}const JB={kernelName:vd,backendName:"webgl",kernelFunc:function QB(n){const{inputs:t,backend:e,attrs:r}=n,{images:s,dy:o}=t,{alignCorners:l}=r,u=new ZB(o.shape,s.shape,l);return e.runWebGLProgram(u,[o],o.dtype)}};class eV{constructor(t,e,r,s,o){this.variableNames=["A"],this.outputShape=[];const[l,u,d,h]=t;this.outputShape=[l,e,r,h];const p=[s&&e>1?u-1:u,s&&r>1?d-1:d],g=[s&&e>1?e-1:e,s&&r>1?r-1:r];let b;b=o?"max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${p[0]/g[0]},\n          ${p[1]/g[1]});\n      const vec2 inputShapeRC = vec2(${u}.0, ${d}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${b};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${s?"0.5":"0.0"})));\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    `}}class tV{constructor(t,e,r,s,o){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[l,u,d,h]=t;this.outputShape=[l,e,r,h];const p=[s&&e>1?u-1:u,s&&r>1?d-1:d],g=[s&&e>1?e-1:e,s&&r>1?r-1:r];let b;b=o?"max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${p[0]/g[0]},\n          ${p[1]/g[1]},\n          ${p[1]/g[1]});\n      const vec3 inputShapeRC = vec3(${u}.0, ${d}.0,\n                                     ${d}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${b};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec3 sourceNearestRC = ivec3(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${s?"0.5":"0.0"})));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${h-1};\n        bool hasNextRow = coords.z < ${r-1};\n\n        vec4 newValue = vec4(\n          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),\n          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);\n\n        setOutput(newValue);\n      }\n    `}}const rV={kernelName:Ro,backendName:"webgl",kernelFunc:function nV(n){const{inputs:t,backend:e,attrs:r}=n,{images:s}=t,{alignCorners:o,halfPixelCenters:l,size:u}=r,[d,h]=u,p=Q().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new tV(s.shape,d,h,o,l):new eV(s.shape,d,h,o,l);return e.runWebGLProgram(p,[s],s.dtype)}};class sV{constructor(t,e,r){this.variableNames=["dy"],this.outputShape=[],this.outputShape=e;const[,s,o]=e,[,l,u]=t,d=[r&&l>1?s-1:s,r&&u>1?o-1:o],h=[r&&l>1?l-1:l,r&&u>1?u-1:u],p=d[0]/h[0],g=d[1]/h[1],y=1/p,b=1/g,_=2*Math.ceil(y)+2,I=2*Math.ceil(b)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${p});\n        const float widthScale = float(${g});\n\n        const float invHeightScale = float(${y});\n        const float invWidthScale = float(${b});\n\n        const int winHeight = int(${_});\n        const int winWidth = int(${I});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${l}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${u}) {\n              continue;\n            }\n\n            float sourceFracRow =\n              float(${d[0]}) *\n                (float(dyR) / float(${h[0]}));\n\n            float sourceFracCol =\n                float(${d[1]}) *\n                  (float(dyC) / float(${h[1]}));\n\n            int sourceNearestRow = int(min(\n                float(int(${s}) - 1),\n                ${r} ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int(${o}) - 1),\n                ${r} ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}const iV={kernelName:lc,backendName:"webgl",kernelFunc:function oV(n){const{inputs:t,backend:e,attrs:r}=n,{images:s,dy:o}=t,{alignCorners:l}=r,u=new sV(o.shape,s.shape,l);return e.runWebGLProgram(u,[o],o.dtype)}};class aV{constructor(t,e){this.variableNames=["x"];const r=t.length;if(r>4)throw new Error(`WebGL backend: Reverse of rank-${r} tensor is not yet supported`);if(this.outputShape=t,1===r)return void(this.userCode=`\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX(${t[0]} - coord - 1));\n        }\n      `);const o=t.map((u,d)=>(u=>-1!==e.indexOf(u)&&1!==t[u]?`${t[u]} - coords[${u}] - 1`:`coords[${u}]`)(d)).join(","),l=ir(r);this.userCode=`\n      void main() {\n        ${l} coords = getOutputCoords();\n        setOutput(getX(${o}));\n      }\n    `}}class lV{constructor(t,e){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const r=t.length;if(r>4)throw new Error(`WebGL backend: Reverse of rank-${r} tensor is not yet supported`);this.outputShape=t;const s=yo("rc",r),o=`${s[r-1]} + 1 < ${this.outputShape[r-1]}`,l=`${s[r-2]} + 1 < ${this.outputShape[r-2]}`,u=ir(r);function y(_){const I=t.map((O,V)=>function b(_,I){return-1!==e.indexOf(_)&&1!==t[_]?`${t[_]} - ${I[_]} - 1`:`${I[_]}`}(V,_));return`getChannel(getX(${I.join(",")}), vec2(${I.slice(-2).join(",")}))`}this.userCode=1===r?`\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX(${t[0]} - rc - 1),\n            ${t[0]} - rc - 1);\n          if(${o}){\n              result.g = getChannel(getX(${t[0]} - (rc  + 1) - 1),\n                ${t[0]} - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      `:`\n        void main() {\n          ${u} rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = ${function d(_){return y(_)}(s.slice())};\n          if(${o}){\n            result.g = ${function h(_){return _[r-1]="("+_[r-1]+" + 1)",y(_)}(s.slice())};\n          }\n          if(${l}) {\n            result.b = ${function p(_){return _[r-2]="("+_[r-2]+" + 1)",y(_)}(s.slice())};\n            if(${o}) {\n              result.a = ${function g(_){return _[r-1]="("+_[r-1]+" + 1)",_[r-2]="("+_[r-2]+" + 1)",y(_)}(s.slice())};\n            }\n          }\n          setOutput(result);\n        }\n    `}}const uV={kernelName:yl,backendName:"webgl",kernelFunc:function cV(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{dims:o}=r,l=s.shape.length,u=Tt(o,s.shape);if(0===l)return ui({inputs:{x:s},backend:e});const d=Q().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new lV(s.shape,u):new aV(s.shape,u);return e.runWebGLProgram(d,[s],s.dtype)}};class dV{constructor(t,e){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const r=t[1],s=t[2];this.outputShape=t;let o="";o="number"==typeof e?`float outputValue = ${e.toFixed(2)};`:`\n        vec3 fill = vec3(${e.join(",")});\n        float outputValue = fill[coords[3]];`,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n          int y = coords[1];\n          float coordXFloat = (float(x) - params[0]) * params[3] -\n            (float(y) - params[1]) * params[2];\n          float coordYFloat = (float(x) - params[0]) * params[2] +\n            (float(y) - params[1]) * params[3];\n          int coordX = int(round(coordXFloat + params[0]));\n          int coordY = int(round(coordYFloat + params[1]));\n          ${o}\n          if(coordX >= 0 && coordX < ${s} && coordY >= 0 && coordY < ${r}) {\n            outputValue = getImage(coords[0], coordY, coordX, coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}}const hV={kernelName:uu,backendName:"webgl",kernelFunc:({inputs:n,attrs:t,backend:e})=>{const{image:r}=n,{radians:s,fillValue:o,center:l}=t,u=e,d=new dV(r.shape,o),[h,p]=u_(l,r.shape[1],r.shape[2]),g=[[h,p,Math.sin(s),Math.cos(s)]];return u.runWebGLProgram(d,[r],r.dtype,g)}},fV=Ln({opSnippet:"\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n"}),pV={kernelName:vl,backendName:"webgl",kernelFunc:fV},mV=Ln({opSnippet:"return inversesqrt(x);",cpuKernelImpl:hO}),gV={kernelName:bl,backendName:"webgl",kernelFunc:mV};class KE{constructor(t,e,r,s,o,l,u=!0,d=!1){this.variableNames=["updates","indices","defaultValue"],this.outputShape=l;const h=ir(o.length),p=ir(l.length);let g="";1===r?g="i":2===r&&(g="i, j");let b="";1===s?b="i":2===s&&(b="i, coords[1]");let I="";d&&(I="coords[0], coords[1]"),this.userCode=`\n        ${h} strides = ${h}(${o});\n\n        void main() {\n          ${p} coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < ${t}; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < ${e}; j++) {\n              int index = round(getIndices(${g}));\n              flattenedIndex += index * ${e>1?"strides[j]":"strides"};\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += getUpdates(${b});\n              found = true;\n            }\n          }\n          setOutput(mix(getDefaultValue(${I}), sum, float(found)));\n        }\n      `}}class yV{constructor(t,e,r,s,o,l,u=!0,d=!1){this.variableNames=["updates","indices","defaultValue"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=l;const h=ir(o.length),p=ir(l.length);let g="";1===r?g="i":2===r&&(g="i, j");let b="";1===s?b="i":2===s&&(b="i, coords[1]");let I="";d&&(I="coords[0], coords[1]"),this.userCode=`\n        ${h} strides = ${h}(${o});\n\n        void main() {\n          ${p} coords = getOutputCoords();\n          vec4 sum = vec4(0.);\n          vec4 found = vec4(0.);\n          for (int i = 0; i < ${t}; i+=2) {\n            ivec2 flattenedIndex = ivec2(0);\n            for (int j = 0; j < ${e}; j+=2) {\n              ivec4 index = round(getIndices(${g}));\n              flattenedIndex += index.xz * ${e>1?"strides[j]":"strides"};\n              if (j + 1 < ${e}) {\n                flattenedIndex += index.yw * ${e>1?"strides[j + 1]":"strides"};\n              }\n            }\n            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||\n                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {\n              vec4 updVals = getUpdates(${b});\n              if (flattenedIndex[0] == coords[0]) {\n                sum.xy += updVals.xy;\n                found.xy = vec2(1.);\n              } else if (flattenedIndex[0] == coords[0] + 1) {\n                sum.zw += updVals.xy;\n                found.zw = vec2(1.);\n              }\n              if (flattenedIndex[1] == coords[0]) {\n                sum.xy += updVals.zw;\n                found.xy = vec2(1.);\n              } else if (flattenedIndex[1] == coords[0] + 1) {\n                sum.zw += updVals.zw;\n                found.zw = vec2(1.);\n              }\n            }\n          }\n          setOutput(mix(getDefaultValue(${I}), sum, found));\n        }\n      `}}const bV={kernelName:cc,backendName:"webgl",kernelFunc:function vV(n){const{inputs:t,backend:e,attrs:r}=n,{indices:s,updates:o}=t,{shape:l}=r,{sliceRank:u,numUpdates:d,sliceSize:h,strides:p,outputSize:g}=Pc(0,s,l),y=[g/h,h];if(0===g)return e.makeTensorInfo(l,s.dtype);const b=Mt({inputs:{x:s},backend:e,attrs:{shape:[d,u]}}),_=Mt({inputs:{x:o},backend:e,attrs:{shape:[d,h]}}),I=e.makeTensorInfo([],"float32",new Float32Array([0]));let S;S=Q().getBool("WEBGL_PACK")?new yV(d,u,b.shape.length,_.shape.length,p,y):new KE(d,u,b.shape.length,_.shape.length,p,y);const T=e.runWebGLProgram(S,[_,b,I],_.dtype),O=Mt({inputs:{x:T},backend:e,attrs:{shape:l}});return e.disposeIntermediateTensorInfo(b),e.disposeIntermediateTensorInfo(_),e.disposeIntermediateTensorInfo(T),e.disposeIntermediateTensorInfo(I),O}};class _V{constructor(t,e,r,s){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[t,r];const l=`for (int i = 0; i < ${Math.ceil(Math.log2(e+1))}; ++i) { if (left >= right) break;`,u=2===Q().getNumber("WEBGL_VERSION")?"while (left < right) {":l;this.userCode=`\n       int findBound(int batch, float value) {\n         int left = 0;\n         int right = numInputs;\n         int mid;\n         ${u}\n           mid = (left + right) / 2;\n           if (getSortedSequence(batch, mid) ${"left"===s?"<":"<="} value) {\n             left = mid + 1;\n           } else {\n             right = mid;\n           }\n         }\n         return right;\n       }\n\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int valueIndex = coords[1];\n\n         float value = getValues(batch, valueIndex);\n\n         setOutput(float(findBound(batch, value)));\n       }\n     `}}const wV={kernelName:Na,backendName:"webgl",kernelFunc:function xV(n){const{inputs:t,backend:e,attrs:r}=n,{sortedSequence:s,values:o}=t,{side:l}=r,u=new _V(s.shape[0],s.shape[1],o.shape[1],l);return e.runWebGLProgram(u,[s,o],"int32",[[s.shape[1]]])}};class CV{constructor(t,e,r){let s,o;if(this.variableNames=["c","a","b"],this.outputShape=e,r>4)throw Error(`Where for rank ${r} is not yet supported`);if(1===r)o="resRC",s="resRC";else{const u=["resRC.x","resRC.y","resRC.z","resRC.w"],d=[],h=[];for(let p=0;p<e.length;p++)h.push(`${u[p]}`),p<t&&d.push(`${u[p]}`);s=d.join(),o=h.join()}const l=ir(r);this.userCode=`\n      void main() {\n        ${l} resRC = getOutputCoords();\n        float cVal = getC(${s});\n        if (cVal >= 1.0) {\n          setOutput(getA(${o}));\n        } else {\n          setOutput(getB(${o}));\n        }\n      }\n    `}}const EV={kernelName:cu,backendName:"webgl",kernelFunc:function SV(n){const{inputs:t,backend:e}=n,{condition:r,t:s,e:o}=t,l=new CV(r.shape.length,s.shape,s.shape.length);return e.runWebGLProgram(l,[r,s,o],ye(s.dtype,o.dtype))}},DV=Ln({opSnippet:`\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = ${Ug};\n  float scale = ${ih};\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n`}),TV={kernelName:ka,backendName:"webgl",kernelFunc:DV},kV=Ln({opSnippet:"if (isnan(x)) return x;\n  return 1.0 / (1.0 + exp(-1.0 * x));\n",packedOpSnippet:"\n  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cpuKernelImpl:pO}),AV={kernelName:dc,backendName:"webgl",kernelFunc:kV},RV=Ln({opSnippet:"\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n"}),MV={kernelName:Aa,backendName:"webgl",kernelFunc:RV},$V=Ln({opSnippet:"if (isnan(x)) return x;\n  return sin(x);\n",packedOpSnippet:`\n  vec4 result = sin(x);\n  bvec4 isNaN = isnan(x);\n  ${Dh}\n  return result;\n`}),PV={kernelName:$s,backendName:"webgl",kernelFunc:$V},LV=Ln({opSnippet:"\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n"}),BV={kernelName:Fn,backendName:"webgl",kernelFunc:LV},VV=Ln({opSnippet:"\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n"}),UV={kernelName:_l,backendName:"webgl",kernelFunc:VV},zV={kernelName:fc,backendName:"webgl",kernelFunc:n=>{const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{blockShape:o,paddings:l}=r;G(s.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");const u=o.reduce((T,O)=>T*O),d=[[0,0]];d.push(...l);for(let T=1+o.length;T<s.shape.length;++T)d.push([0,0]);const h=[],p=Ik({inputs:{x:s},backend:e,attrs:{paddings:d,constantValue:0}}),g=rh(p.shape,o,u,!1),y=sh(g.length,o.length,!1),b=oh(p.shape,o,u,!1),_=Mt({inputs:{x:p},backend:e,attrs:{shape:g}}),I=vo({inputs:{x:_},backend:e,attrs:{perm:y}}),S=Mt({inputs:{x:I},backend:e,attrs:{shape:b}});return h.push(p),h.push(_),h.push(I),h.forEach(T=>e.disposeIntermediateTensorInfo(T)),S}},WV={kernelName:Xo,backendName:"webgl",kernelFunc:function HV(n){const{inputs:t,backend:e}=n,{indices:r,values:s,denseShape:o,defaultValue:l}=t;if(1!==o.shape.length)throw new Error(`Dense shape must be a vector, saw:\n         ${o.shape}`);if(2!==r.shape.length)throw new Error(`Indices must be a matrix, saw:\n         ${r.shape}`);if(1!==s.shape.length)throw new Error(`Values must be a vector, saw:\n         ${s.shape}`);if(0!==l.shape.length)throw new Error(`Default value must be a scalar, saw:\n        ${l.shape}`);const u=e.readSync(r.dataId),d=e.readSync(s.dataId),h=e.readSync(o.dataId),p=e.readSync(l.dataId)[0],[g,y,b,_,I]=gO(u,r.shape,r.dtype,d,s.dtype,h,p);return[e.makeTensorInfo(y,r.dtype,g),e.makeTensorInfo([y[0]],s.dtype,b),e.makeTensorInfo([_.length],"bool",new Uint8Array(_.map(S=>Number(S)))),e.makeTensorInfo([I.length],r.dtype,new Int32Array(I))]}},GV={kernelName:Ma,backendName:"webgl",kernelFunc:function jV(n){const{inputs:t,backend:e}=n,{inputIndices:r,inputShape:s,newShape:o}=t;if(2!==r.shape.length)throw new Error(`Input indices should be a matrix but received shape ${r.shape}`);if(1!==s.shape.length)throw new Error(`Input shape should be a vector but received shape ${s.shape}`);if(1!==o.shape.length)throw new Error(`Target shape should be a vector but received shape ${o.shape}`);const l=Array.from(e.readSync(s.dataId)),u=e.readSync(r.dataId),d=Array.from(e.readSync(o.dataId)),[h,p,g]=yO(u,r.shape,r.dtype,l,d);return[e.makeTensorInfo(p,r.dtype,h),e.makeTensorInfo([g.length],o.dtype,new Int32Array(g))]}},qV={kernelName:yi,backendName:"webgl",kernelFunc:function KV(n){const{inputs:t,backend:e}=n,{data:r,indices:s,segmentIds:o}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.shape.length)throw new Error(`Indices should be a vector but received shape\n              ${s.shape}`);if(1!==o.shape.length)throw new Error(`Segment ids should be a vector but received shape\n              ${o.shape}`);const l=e.readSync(r.dataId),u=e.readSync(s.dataId),d=e.readSync(o.dataId),[h,p]=RN(l,r.shape,r.dtype,u,d,!0);return e.makeTensorInfo(p,r.dtype,h)}},YV={kernelName:k,backendName:"webgl",kernelFunc:function XV(n){const{inputs:t,backend:e}=n,{data:r,indices:s,segmentIds:o}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.shape.length)throw new Error(`Indices should be a vector but received shape\n             ${s.shape}`);if(1!==o.shape.length)throw new Error(`Segment ids should be a vector but received shape\n             ${o.shape}`);const l=e.readSync(r.dataId),u=e.readSync(s.dataId),d=e.readSync(o.dataId),[h,p]=RN(l,r.shape,r.dtype,u,d);return e.makeTensorInfo(p,r.dtype,h)}},QV={kernelName:B,backendName:"webgl",kernelFunc:function ZV(n){const{inputs:t,backend:e,attrs:r}=n,{sparseIndices:s,sparseValues:o,defaultValue:l}=t,{outputShape:u}=r,{sliceRank:d,numUpdates:h,sliceSize:p,strides:g,outputSize:y}=Pc(0,s,u);if("string"===o.dtype){const T=e.bufferSync(s),O=e.bufferSync(o),V=wi(e.readSync(l.dataId)[0]),U=fO(T,O,u,y,p,h,d,g,V,!1);return e.makeTensorInfo(u,U.dtype,U.values)}const _=new KE(h,d,s.shape.length,o.shape.length,g,[y,1],!1),I=e.runWebGLProgram(_,[o,s,l],o.dtype),S=Mt({inputs:{x:I},backend:e,attrs:{shape:u}});return e.disposeIntermediateTensorInfo(I),S}},eU={kernelName:Ki,backendName:"webgl",kernelFunc:function JV(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{numOrSizeSplits:o,axis:l}=r,u=Tt(l,s.shape)[0],d=qg(s,o,u),p=new Array(s.shape.length).fill(0),g=s.shape.slice();return d.map(y=>{const b=[...g];b[u]=y;const _=Sp({inputs:{x:s},backend:e,attrs:{begin:p,size:b}});return p[u]+=y,_})}},Tk="return sqrt(x);",tU=Ln({opSnippet:Tk,packedOpSnippet:Tk,cpuKernelImpl:vO}),nU={kernelName:hc,backendName:"webgl",kernelFunc:tU},sU={kernelName:H,backendName:"webgl",kernelFunc:Ln({opSnippet:"return x * x;"})},Nk="return (a - b) * (a - b);",oU=Ws({opSnippet:Nk,packedOpSnippet:Nk}),iU={kernelName:M,backendName:"webgl",kernelFunc:oU},lU={kernelName:oe,backendName:"webgl",kernelFunc:function aU(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t;if("string"!==s.dtype)throw new Error("Input must be of datatype string");const l=po(e.readSync(s.dataId)),u=bO(l,"string",r);return e.makeTensorInfo(s.shape,"string",u)}},uU={kernelName:Zo,backendName:"webgl",kernelFunc:function cU({inputs:n,attrs:t,backend:e}){const{x:r}=n,o=new Yl(r.shape,`if (isnan(x)) return x;\n    return x > 0.0 ? 1.0 : float(${t.alpha});\n  `);return e.runWebGLProgram(o,[r],r.dtype)}};class dU{constructor(t,e,r){this.variableNames=["x"],this.outputShape=r;const s=r.length,o=ir(r.length),l=ir(r.length);let u="";if(1===s)u="coords * strides + begin";else{let d=0;u=r.map((h,p)=>(d++,1===r.length?`coords * strides[${p}] + begin[${p}]`:`coords[${d-1}] * strides[${p}] + begin[${p}]`)).join(",")}this.userCode=`\n      ${o} begin = ${o}(${t});\n      ${o} strides = ${o}(${e});\n\n      void main() {\n        ${l} coords = getOutputCoords();\n        setOutput(getX(${u}));\n      }\n    `}}const fU={kernelName:Pe,backendName:"webgl",kernelFunc:function hU(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{begin:o,end:l,strides:u,beginMask:d,endMask:h,ellipsisMask:p,newAxisMask:g,shrinkAxisMask:y}=r,{finalShapeSparse:b,finalShape:_,isIdentity:I,sliceDim0:S,isSimpleSlice:T,begin:O,end:V,strides:U}=cf(s.shape,o,l,u,d,h,p,g,y);let j;if(I)j=Mt({inputs:{x:s},backend:e,attrs:{shape:_}});else if(S||T){G(s.shape.length>=1,()=>`Input must have rank at least 1, got: ${s.shape.length}`);const se=Ld(O,V,U),le=Sp({inputs:{x:s},backend:e,attrs:{begin:O,size:se}});j=Mt({inputs:{x:le},backend:e,attrs:{shape:_}}),e.disposeIntermediateTensorInfo(le)}else if(e.shouldExecuteOnCPU([s])){const le=e.readSync(s.dataId),Ce=gn(s.shape,s.dtype,le),be=_O(b,Ce,U,O);j=e.makeTensorInfo(_,s.dtype,be.values)}else{const le=new dU(O,U,b);j=e.runWebGLProgram(le,[s],s.dtype)}const te=Mt({inputs:{x:j},backend:e,attrs:{shape:_}});return e.disposeIntermediateTensorInfo(j),te}},mU={kernelName:Ye,backendName:"webgl",kernelFunc:function pU(n){const{inputs:t,backend:e,attrs:r}=n,{separator:s,nGramWidths:o,leftPad:l,rightPad:u,padWidth:d,preserveShortSequences:h}=r,{data:p,dataSplits:g}=t,y=e.readSync(p.dataId),b=e.readSync(g.dataId),[_,I]=xO(y,b,s,o,l,u,d,h);return[e.makeTensorInfo([_.length],"string",_),e.makeTensorInfo(g.shape,"int32",I)]}},yU={kernelName:Ht,backendName:"webgl",kernelFunc:function gU(n){const{inputs:t,backend:e,attrs:r}=n,{skipEmpty:s}=r,{input:o,delimiter:l}=t;if("string"!==o.dtype)throw new Error("Input must be of datatype string");if(1!==o.shape.length)throw new Error(`Input must be a vector, got shape: ${o.shape}`);if(0!==l.shape.length)throw new Error(`Delimiter must be a scalar, got shape: ${l.shape}`);const u=e.readSync(o.dataId),d=e.readSync(l.dataId)[0],[h,p,g]=wO(u,d,s),y=p.length;return[e.makeTensorInfo([y,2],"int32",h),e.makeTensorInfo([y],"string",p),e.makeTensorInfo([2],"int32",new Int32Array(g))]}},bU={kernelName:Dn,backendName:"webgl",kernelFunc:function vU(n){const{inputs:t,backend:e,attrs:r}=n,{numBuckets:s}=r,{input:o}=t;if("string"!==o.dtype)throw new Error("Input must be of datatype string");if(s<=0)throw new Error("Number of buckets must be at least 1");const l=e.readSync(o.dataId),u=CO(l,s);return e.makeTensorInfo(o.shape,"int32",u)}},_U=Ln({opSnippet:"return tan(x);"}),xU={kernelName:Rn,backendName:"webgl",kernelFunc:_U},wU=Ln({opSnippet:"\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n"}),CU={kernelName:yn,backendName:"webgl",kernelFunc:wU},EU={kernelName:uc,backendName:"webgl",kernelFunc:function SU(n){const{inputs:t,backend:e}=n,{tensor:s,indices:o,updates:l}=t,{sliceRank:u,numUpdates:d,sliceSize:h,strides:p,outputSize:g}=Pc(0,o,s.shape),y=[g/h,h];if(0===g)return e.makeTensorInfo(s.shape,o.dtype);const b=Mt({inputs:{x:o},backend:e,attrs:{shape:[d,u]}}),_=Mt({inputs:{x:l},backend:e,attrs:{shape:[d,h]}}),I=Mt({inputs:{x:s},backend:e,attrs:{shape:y}}),S=new KE(d,u,b.shape.length,_.shape.length,p,y,!1,!0),T=e.runWebGLProgram(S,[_,b,I],I.dtype),O=Mt({inputs:{x:T},backend:e,attrs:{shape:s.shape}});return e.disposeIntermediateTensorInfo(b),e.disposeIntermediateTensorInfo(_),e.disposeIntermediateTensorInfo(I),e.disposeIntermediateTensorInfo(T),O}};class IU{constructor(t,e){this.variableNames=["A"];const r=new Array(t.length);for(let l=0;l<r.length;l++)r[l]=t[l]*e[l];this.outputShape=r,this.rank=r.length;const s=ir(this.rank),o=function DU(n){const t=n.length;if(t>5)throw Error(`Tile for rank ${t} is not yet supported`);if(1===t)return`imod(resRC, ${n[0]})`;const e=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],r=[];for(let s=0;s<n.length;s++)r.push(`imod(${e[s]}, ${n[s]})`);return r.join()}(t);this.userCode=`\n      void main() {\n        ${s} resRC = getOutputCoords();\n        setOutput(getA(${o}));\n      }\n    `}}function kk(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{reps:o}=r;if("string"===s.dtype||s.shape.length>5){const d=e.readSync(s.dataId),h="string"===s.dtype?d.map(y=>wi(y)):d,p=gn(s.shape,s.dtype,h),g=EO(p,o);return e.makeTensorInfo(g.shape,g.dtype,g.values)}const l=new IU(s.shape,o);return e.runWebGLProgram(l,[s],s.dtype)}const TU={kernelName:sr,backendName:"webgl",kernelFunc:kk};class NU{constructor(t){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=t,this.userCode="\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // We compare elements pair-wise within a group of size 2 * inc.\n         // The comparing rule for each group alternates between ascending\n         // and descending. Within each group, we compare each pair at\n         // positions i and i+inc. To decide whether an element at position i\n         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than\n         // inc, it is in the first half of the group, we denote it as x0,\n         // otherwise we denote it as x1.\n         // For example, as shown in the Bitonic top K paper referenced above,\n         // Figure5(a) shows that element[1] is in the\n         // second half of the group when group size is 2, but it is in the\n         // first half of the group when group size is 4.\n\n         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;\n         int i = isFirstInPair ? elemIdx : elemIdx - inc;\n\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));\n         float x0 = i0 < n ? getX(batch, i0) : negativeInf;\n         float x1 = i1 < n ? getX(batch, i1) : negativeInf;\n\n         // Denotes which direction indices are in (ascending or descending).\n         bool reverse = imod(elemIdx, 2 * dir) >= dir;\n         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);\n         if (reverse == isGreater) { // Elements in opposite order of direction\n           int iTemp = i0;\n           i0 = i1;\n           i1 = iTemp;\n         }\n         if (isFirstInPair) {\n            setOutput(float(i0));\n         } else {\n            setOutput(float(i1));\n         }\n       }\n     "}}class kU{constructor(t){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=t,this.userCode="\n    void main() {\n         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // The output size is half of the previous size.\n         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),\n         // we only need to output the indices at positions |, the indices at\n         // positions _ can be thrown away, see Figure5(b) After Phase 2\n         // (Merge phase) in the Bitonic Top K paper referenced above.\n         // For example, the paper shows we only need to output the orange bars.\n         // The output sequence should look like this | | | | | | | |.\n         // Because the sequence is halved, to map the output index back\n         // to the previous sequence to find the corresponding value,\n         // we need to double the index. When we double the index,\n         // we basically interpolate a position, so 2i looks like\n         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position\n         // of each 2k positions by - elemIdx % k. E.g. for output at\n         // index 4,5,6,7, we want to get the corresponding element at\n         // original index 8,9,10,11, for output at index 8,9,10,11,\n         // we want to get the corresponding element at original index\n         // 16,17,18,19, so on and so forth.\n\n         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));\n\n         float x0 = getX(batch, i0);\n         float x1 = i1 < n ? getX(batch, i1) : x0;\n\n         setOutput(x0 >= x1 ? float(i0) : float(i1));\n       }\n     "}}function Nh(n,t){null!==t&&n.disposeIntermediateTensorInfo(t)}function Ak(n){let t=1;for(;t<n;)t*=2;return t}const RU={kernelName:$n,backendName:"webgl",kernelFunc:function AU(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{k:o,sorted:l}=r,u=Q().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),d=Q().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),h=s.shape,p=h[h.length-1];if(e.shouldExecuteOnCPU([s])||p<u||o>d){const be=e.readSync(s.dataId),[Me,He]=IO(be,h,s.dtype,o,l);return[e.makeTensorInfo(Me.shape,Me.dtype,Me.values),e.makeTensorInfo(He.shape,He.dtype,He.values)]}if(0===o)return h[h.length-1]=0,[e.makeTensorInfo(h,s.dtype,[]),e.makeTensorInfo(h,"int32",[])];if(1===p)return[s,Ly({attrs:{shape:h,dtype:"int32",value:0},backend:e})];const g=e.texData.get(s.dataId),y=null!==g&&g.isPacked,b=y?e.unpackTensor(s):s,I=Ee(h)/p,S=Mt({inputs:{x:b},attrs:{shape:[I,p]},backend:e});y&&Nh(e,b);const T=Ak(o),O=Ak(p);let V=null;const U=()=>null===V?[S,S]:[S,V],j=(be,Me,He)=>{const We=U(),je=new NU(He),ke=V;V=e.runWebGLProgram(je,We,"int32",[[p],[null===V?1:0],[Number.NEGATIVE_INFINITY],[be],[Me]]),Nh(e,ke)};for(let be=1;be<T;be*=2){const Me=2*be;for(let He=be;He>=1;He/=2)j(Me,He,[I,O])}for(let be=O;be>T;be/=2){const Me=U(),He=new kU([I,be/2]),Ke=V;V=e.runWebGLProgram(He,Me,"int32",[[p],[null===V?1:0],[T]]),Nh(e,Ke);const Se=T/2,ke=2*Se;for(let De=Se;De>=1;De/=2)j(ke,De,V.shape)}let te=V;V=Sp({inputs:{x:V},backend:e,attrs:{begin:0,size:[I,o]}}),Nh(e,te);let se=bk({inputs:{x:S,indices:V},backend:e,attrs:{axis:1,batchDims:1}});Nh(e,S);const le=h.slice(0,-1);le.push(o),te=V,V=Mt({inputs:{x:V},attrs:{shape:le},backend:e}),Nh(e,te);const Ce=se;return se=Mt({inputs:{x:se},attrs:{shape:le},backend:e}),Nh(e,Ce),[se,V]}};class MU{constructor(t,e,r,s,o,l){this.variableNames=["Image","Transforms"],this.outputShape=l;const u="nearest"===r?1:2;let d;switch(s){case"constant":default:d=1;break;case"reflect":d=2;break;case"wrap":d=3;break;case"nearest":d=4}this.userCode=`\n            float mapCoord(float outCoord, float len) {\n              float inCoord = outCoord;\n              if(${d} == 2) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    if (inCoord < sz2) {\n                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +\n                      inCoord;\n                    }\n                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    inCoord -= sz2 * float(int(float(inCoord / sz2)));\n                    if (inCoord >= len) {\n                      inCoord = sz2 - inCoord - 1.0;\n                    }\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${d} == 3) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord -= len * float(int(float(inCoord / sz)));\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${d} == 4) {\n                return clamp(outCoord, 0.0, len - 1.0);\n              } else {\n                return outCoord;\n              }\n            }\n\n            float readWithFillValue(int batch, int coordY, int coordX,\n              int channel) {\n              float outputValue;\n              if (0 <= coordY && coordY < ${t} && 0 <= coordX && coordX < ${e}) {\n                  outputValue = getImage(batch, coordY, coordX, channel);\n              } else {\n                outputValue = float(${o});\n              }\n              return outputValue;\n            }\n\n            void main() {\n              ivec4 coords = getOutputCoords();\n              float outputValue;\n              int batch = coords[0];\n              int x = coords[2];\n              int y = coords[1];\n              int channel = coords[3];\n              float xf = float(x);\n              float yf = float(y);\n              float a1 = getTransforms(batch, 0);\n              float a2 = getTransforms(batch, 1);\n              float a3 = getTransforms(batch, 2);\n              float b1 = getTransforms(batch, 3);\n              float b2 = getTransforms(batch, 4);\n              float b3 = getTransforms(batch, 5);\n              float c1 = getTransforms(batch, 6);\n              float c2 = getTransforms(batch, 7);\n              float projection = c1 * xf + c2 * yf + 1.0;\n              if (projection == 0.0) {\n                outputValue = float(${o});\n              } else {\n                float inX = (a1 * xf + a2 * yf + a3) / projection;\n                float inY = (b1 * xf + b2 * yf + b3) / projection;\n                float mapX = mapCoord(inX, float(${e}));\n                float mapY = mapCoord(inY, float(${t}));\n\n                if (${u} == 1) {\n                  int coordY = int(round(mapY));\n                  int coordX = int(round(mapX));\n                  outputValue = readWithFillValue(batch, coordY, coordX,\n                    channel);\n                } else {\n                  float yFloor = floor(mapY);\n                  float xFloor = floor(mapX);\n                  float yCeil = yFloor + 1.0;\n                  float xCeil = xFloor + 1.0;\n                  float valueYFloor = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);\n                  float valueYCeil = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);\n                  outputValue = (yCeil - mapY) * valueYFloor +\n                  (mapY - yFloor) * valueYCeil;\n                }\n              }\n              setOutput(outputValue);\n            }\n        `}}const FU={kernelName:or,backendName:"webgl",kernelFunc:function OU(n){const{inputs:t,backend:e,attrs:r}=n,{image:s,transforms:o}=t,{interpolation:l,fillMode:u,fillValue:d,outputShape:h}=r,[p,g,y,b]=s.shape,[_,I]=null!=h?h:[g,y],T=new MU(g,y,l,u,d,[p,_,I,b]);return e.runWebGLProgram(T,[s,o],"float32")}},PU={kernelName:gs,backendName:"webgl",kernelFunc:function $U(n){const{inputs:t,attrs:e,backend:r}=n,{axis:s}=e,{x:o}=t;Wc(o,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const l=r.readSync(o.dataId),{outputValues:u,outputShape:d,indices:h}=DO(l,s,o.shape,o.dtype);return[r.makeTensorInfo(d,o.dtype,u),r.makeTensorInfo([h.length],"int32",h)]}},BU={kernelName:ss,backendName:"webgl",kernelFunc:function LU(n){const{inputs:t,backend:e,attrs:r}=n,{value:s}=t;let{axis:o}=r;o<0&&(o+=s.shape.length);const l=s,u=l.shape.length,d=s.shape[o],h=new Array(u-1);let p=0;for(let I=0;I<u;I++)I!==o&&(h[p++]=l.shape[I]);const g=[],y=new Array(u).fill(0),b=l.shape.slice();b[o]=1;const _=new Array(d);for(let I=0;I<_.length;I++){y[o]=I;const S=Sp({inputs:{x:l},backend:e,attrs:{begin:y,size:b}}),T=Mt({inputs:{x:S},backend:e,attrs:{shape:h}});_[I]=T,g.push(S)}return g.forEach(I=>e.disposeIntermediateTensorInfo(I)),_}};class VU{constructor(t,e){this.variableNames=["x","segmentIds"];const r=t.windowSize,s=t.batchSize,o=t.inSize,l=t.numSegments,u=l*Math.ceil(o/r);this.outputShape=[s,u];const p=4*Math.floor(r/4),g=r%4,y="\n        sumValue += dot(values, segFilter);\n    ";let b="";o%r>0&&(b=`\n        if (inIdx < 0 || inIdx >= ${o}) {\n          return initializationValue;\n        }\n      `);let _="";o%r>0&&(_=`\n        if (inIdx < 0 || inIdx >= ${o}) {\n          return -1.0;\n        }\n      `),this.userCode=`\n      const float initializationValue = 0.0;\n\n      float getValue(int batch, int inIdx) {\n        ${b}\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        ${_}\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          ${l})) * float(${r}));\n        int currentSeg = int(mod(float(outIdx), float(${l})));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${p}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          ${y}\n        }\n\n        int inIdx = inOffset + ${p};\n        if (${1===g}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          ${y}\n        } else if (${2===g}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          ${y}\n        } else if (${3===g}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          ${y}\n        }\n        setOutput(sumValue);\n      }\n    `}}const HU=[_F,wF,EF,TF,kF,MF,FF,PF,UF,HF,GF,XF,QF,n$,o$,a$,c$,f$,m$,y$,_$,I$,T$,R$,O$,B$,U$,j$,rF,q$,J$,rP,cP,hP,pP,gP,vP,wP,SP,IP,TP,kP,RP,FP,PP,UP,HP,GP,XP,ZP,JP,nL,sL,aL,cL,uL,hL,pL,gL,vL,_L,wL,EL,TL,kL,ML,$L,LL,VL,nF,zL,Z$,WL,GL,qL,oF,YL,QL,e3,r3,a3,c3,d3,f3,g3,v3,_3,S3,I3,T3,R3,O3,$3,L3,V3,W3,K3,Z3,rB,lF,aB,uB,fB,gB,F$,vB,_B,wB,EB,NB,aF,AB,MB,FB,PB,LB,$$,J3,VB,HB,GB,uF,YB,JB,rV,iV,uV,hV,pV,gV,bV,wV,EV,TV,AV,MV,PV,BV,E$,tB,UV,zV,WV,GV,qV,YV,QV,eU,nU,sU,iU,lU,uU,fU,mU,yU,bU,eB,yF,xU,CU,EU,TU,RU,FU,vF,PU,BU,{kernelName:Zs,backendName:"webgl",kernelFunc:function UU(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,segmentIds:o}=t,{numSegments:l}=r,u=s.shape.length,d=[];let h=0;const p=pr([h],u);let g=s;null!=p&&(g=vo({inputs:{x:s},backend:e,attrs:{perm:p}}),d.push(g),h=_r(1,u)[0]);const y=g_(g.shape,h,l),b=Ee([g.shape[h]]),_=Mt({inputs:{x:g},backend:e,attrs:{shape:[-1,b]}});d.push(_);const I=lt(s.dtype),S=(U,j,te,se,le)=>{const Ce=U.shape[0],be=U.shape[1],Me=ry(be,le),We=new VU({windowSize:Me,inSize:be,batchSize:Ce,numSegments:le},j),je=e.compileAndRun(We,[U,te],se);if(d.push(je),je.shape[1]===le)return je;const Ke=Dk({backend:e,attrs:{start:0,stop:le,step:1,dtype:"float32"}}),Se=kk({inputs:{x:Ke},backend:e,attrs:{reps:[be/Me]}});return d.push(Ke),d.push(Se),S(je,j,Se,se,le)},O=Mt({inputs:{x:S(_,"unsortedSegmentSum",o,I,l)},backend:e,attrs:{shape:y}});let V=O;if(null!=p){d.push(O);const U=na(p);V=vo({inputs:{x:V},backend:e,attrs:{perm:U}})}return d.forEach(U=>e.disposeIntermediateTensorInfo(U)),V}},bB];for(const n of HU)hu(n);const WU=Za;let jU=(()=>{class n extends ue{nextDataId(){return n.nextDataId++}constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new ce(this,Qi())}write(e,r,s){this.firstUse&&(this.firstUse=!1,Q().get("IS_NODE")&&Js("\n============================\nHi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. \n============================"));const o={id:this.nextDataId()};return this.data.set(o,{values:e,dtype:s,refCount:1}),o}makeTensorInfo(e,r,s){let o;if("string"===r&&null!=s&&s.length>0&&bo(s[0])){const l=s.map(u=>oo(u));o=this.write(l,e,r)}else o=this.write(s,e,r);return{dataId:o,shape:e,dtype:r}}refCount(e){return this.data.has(e)?this.data.get(e).refCount:0}incRef(e){this.data.get(e).refCount++}decRef(e){this.data.has(e)&&this.data.get(e).refCount--}move(e,r,s,o,l){this.data.set(e,{values:r,dtype:o,refCount:l})}numDataIds(){return this.data.numDataIds()}read(e){var r=this;return xe(function*(){return r.readSync(e)})()}readSync(e){const{dtype:r,complexTensorInfos:s}=this.data.get(e);return"complex64"===r?Qa(this.readSync(s.real.dataId),this.readSync(s.imag.dataId)):function ya(n,t){if(Array.isArray(n))return n;if("float32"===t)return n instanceof Float32Array?n:new Float32Array(n);if("int32"===t)return n instanceof Int32Array?n:new Int32Array(n);if("bool"===t||"string"===t)return Uint8Array.from(new Int32Array(n));throw new Error(`Unknown dtype ${t}`)}(this.data.get(e).values,r)}bufferSync(e){const r=this.readSync(e.dataId);if("string"===e.dtype)try{const s=r.map(o=>wi(o));return gn(e.shape,e.dtype,s)}catch(s){throw new Error("Failed to decode encoded string bytes into utf-8")}return gn(e.shape,e.dtype,r)}makeOutput(e,r,s){return Qi().makeTensorFromTensorInfo(this.makeTensorInfo(r,s,e),this)}disposeData(e,r=!1){if(this.data.has(e)){if(this.data.get(e).refCount--,!r&&this.data.get(e).refCount>0)return!1;const{complexTensorInfos:s}=this.data.get(e);null!=s&&(this.disposeData(s.real.dataId,!0),this.disposeData(s.imag.dataId,!0)),this.data.delete(e)}return!0}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}time(e){return xe(function*(){const r=Oo();return e(),{kernelMs:Oo()-r}})()}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(e){Xt([e],"where");const r=this.readSync(e.dataId);return WU(e.shape,r)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}return n.nextDataId=0,n})();Ux("cpu",()=>new jU,1);const Rk=Qn(al,n=>n>=0?n:Math.exp(n)-1),GU={kernelName:al,backendName:"cpu",kernelFunc:Rk};function Mk(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{alpha:o}=r;Xt([s],"leakyRelu");const l=Ee(s.shape),u=e.data.get(s.dataId).values,d=Rt("float32",l);for(let h=0;h<u.length;h++)d[h]=u[h]<0?o*u[h]:u[h];return e.makeTensorInfo(s.shape,"float32",d)}const KU={kernelName:pi,backendName:"cpu",kernelFunc:Mk},qU=Zr((n,t)=>n<0?t*n:n);function Ok(n){const{inputs:t,backend:e}=n,{x:r,alpha:s}=t;Xt([r,s],"prelu");const o=e.data.get(r.dataId).values,l=e.data.get(s.dataId).values,[u,d]=qU(r.shape,s.shape,o,l,"float32");return e.makeTensorInfo(d,"float32",u)}const XU={kernelName:Nr,backendName:"cpu",kernelFunc:Ok},Fk=Qn(mi,n=>Math.max(0,n)),YU={kernelName:mi,backendName:"cpu",kernelFunc:Fk},$k=Qn(gl,n=>Math.min(Math.max(0,n),6)),ZU={kernelName:gl,backendName:"cpu",kernelFunc:$k};function dx(n,t,e,r,s){if("linear"===e)return ql({inputs:{x:t},backend:n});if("relu"===e)return Fk({inputs:{x:t},backend:n});if("elu"===e)return Rk({inputs:{x:t},backend:n});if("relu6"===e)return $k({inputs:{x:t},backend:n});if("prelu"===e)return Ok({inputs:{x:t,alpha:r},backend:n});if("leakyrelu"===e)return Mk({inputs:{x:t},backend:n,attrs:{alpha:s}});if("sigmoid"===e)return mN({inputs:{x:t},backend:n});throw new Error(`Activation ${e} has not been implemented for the CPU backend.`)}function mr(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{shape:o}=r,l=Ee(s.shape),u=Dr(o,l),d=Ee(u);G(l===d,()=>`The new shape (${u}) has ${d} elements and the old shape (${s.shape}) has ${l} elements. The new shape and old shape must have the same number of elements.`),e.incRef(s.dataId);const h=e.data.get(s.dataId);if(null!=h.complexTensorInfos){const g=h.complexTensorInfos.imag;h.complexTensorInfos.real.shape=u,g.shape=u}return{dataId:s.dataId,shape:u,dtype:s.dtype}}const QU={kernelName:gi,backendName:"cpu",kernelFunc:mr};function Pk(n){const{inputs:t,backend:e,attrs:r}=n,{a:s,b:o}=t,{transposeA:l,transposeB:u}=r;Xt([s,o],"matMul");const d=s.shape.length,h=o.shape.length,p=l?s.shape[d-2]:s.shape[d-1],g=u?o.shape[h-1]:o.shape[h-2],y=l?s.shape[d-1]:s.shape[d-2],b=u?o.shape[h-2]:o.shape[h-1],_=s.shape.slice(0,-2),I=o.shape.slice(0,-2),S=Ee(_),T=Ee(I),V=Nn(s.shape.slice(0,-2),o.shape.slice(0,-2)).concat([y,b]);G(p===g,()=>`Error in matMul: inner shapes (${p}) and (${g}) of Tensors with shapes ${s.shape} and ${o.shape} and transposeA=${l} and transposeB=${u} must match.`);const j=u?[T,b,g]:[T,g,b],te=mr({inputs:{x:s},backend:e,attrs:{shape:l?[S,p,y]:[S,y,p]}}),se=mr({inputs:{x:o},backend:e,attrs:{shape:j}}),le=l?te.shape[1]:te.shape[2],Ce=l?te.shape[2]:te.shape[1],be=u?se.shape[1]:se.shape[2],Me=Math.max(S,T),He=e.data.get(te.dataId).values,We=e.data.get(se.dataId).values,je=Wt(te.shape),Ke=Wt(se.shape),[Se,ke,De]=l?[je[0],1,je[1]]:[je[0],je[1],1],[Be,rt,pt]=u?[1,Ke[1],Ke[0]]:[Ke[1],1,Ke[0]],wt=Ce*be,gt=gn([Me,Ce,be],te.dtype),yt=gt.values,It=e.blockSize;for(let zt=0;zt<Me;zt++){const Vt=zt%S,tn=zt%T;for(let Yt=0;Yt<Ce;Yt+=It){const vn=Math.min(Yt+It,Ce);for(let wn=0;wn<be;wn+=It){const Jn=Math.min(wn+It,be);for(let gr=0;gr<le;gr+=It){const Hr=Math.min(gr+It,le);for(let yr=Yt;yr<vn;yr++)for(let ar=wn;ar<Jn;ar++){let Or=0;for(let Ir=gr;Ir<Hr;Ir++)Or+=He[Vt*Se+yr*ke+Ir*De]*We[Ir*Be+ar*rt+tn*pt];yt[zt*wt+(yr*be+ar)]+=Or}}}}}return e.disposeIntermediateTensorInfo(te),e.disposeIntermediateTensorInfo(se),e.makeTensorInfo(V,gt.dtype,gt.values)}const JU={kernelName:mn,backendName:"cpu",kernelFunc:Pk},t4={kernelName:pc,backendName:"cpu",kernelFunc:function e4(n){const{inputs:t,backend:e,attrs:r}=n,{a:s,b:o,bias:l,preluActivationWeights:u}=t,{transposeA:d,transposeB:h,activation:p,leakyreluAlpha:g}=r;let y,b,_;const I=[];y=Pk({inputs:{a:s,b:o},attrs:{transposeA:d,transposeB:h},backend:e}),l&&(b=xp({inputs:{a:y,b:l},backend:e}),I.push(y),y=b),p&&(_=dx(e,y,p,u,g),I.push(y),y=_);for(const T of I)e.disposeIntermediateTensorInfo(T);return y}},n4=Qn(lr,n=>Math.acos(n)),r4={kernelName:lr,backendName:"cpu",kernelFunc:n4},s4=Qn(As,n=>Math.acosh(n)),o4={kernelName:As,backendName:"cpu",kernelFunc:s4},l4={kernelName:Ks,backendName:"cpu",kernelFunc:function a4(n){const{inputs:t,backend:e}=n,r=t;Xt(t,"addN");const s=r.map(u=>e.data.get(u.dataId).values),o=gn(r[0].shape,r[0].dtype),l=o.values;for(let u=0;u<r.length;u++){const d=s[u];for(let h=0;h<l.length;h++)l[h]+=d[h]}return e.makeTensorInfo(o.shape,o.dtype,o.values)}},u4={kernelName:"All",backendName:"cpu",kernelFunc:function c4(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:o,keepDims:l}=r;Xt(s,"all");const u=Tt(o,s.shape);let d=u;const h=pr(d,s.shape.length);let p=s;null!=h&&(p=Vo({inputs:{x:s},backend:e,attrs:{perm:h}}),d=_r(d.length,s.shape.length)),_s("all",d,p.shape.length);const[g,y]=as(p.shape,d),b=Ee(y),_=er(Ee(g),p.dtype),I=e.data.get(p.dataId).values;for(let T=0;T<_.length;++T){const O=T*b;let V=I[O];for(let U=0;U<b;++U){const j=I[O+U];V=V&&j}_[T]=V}null!=h&&e.disposeIntermediateTensorInfo(p);const S=e.makeTensorInfo(g,p.dtype,_);if(l){const O=mr({inputs:{x:S},backend:e,attrs:{shape:Yr(g,u)}});return e.disposeIntermediateTensorInfo(S),O}return S}},h4={kernelName:"Any",backendName:"cpu",kernelFunc:function d4(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:o,keepDims:l}=r;Xt(s,"any");const u=Tt(o,s.shape);let d=u;const h=pr(d,s.shape.length);let p=s;null!=h&&(p=Vo({inputs:{x:s},backend:e,attrs:{perm:h}}),d=_r(d.length,s.shape.length)),_s("any",d,p.shape.length);const[g,y]=as(p.shape,d),b=Ee(y),_=er(Ee(g),p.dtype),I=e.data.get(p.dataId).values;for(let T=0;T<_.length;++T){const O=T*b;let V=I[O];for(let U=0;U<b;++U){const j=I[O+U];V=V||j}_[T]=V}null!=h&&e.disposeIntermediateTensorInfo(p);const S=e.makeTensorInfo(g,p.dtype,_);if(l){const O=mr({inputs:{x:S},backend:e,attrs:{shape:Yr(g,u)}});return e.disposeIntermediateTensorInfo(S),O}return S}},p4={kernelName:Lr,backendName:"cpu",kernelFunc:function f4(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:o}=r;Xt(s,"argMax");let l=Tt(o,s.shape);const u=pr(l,s.shape.length);let d=s;const h=[];null!=u&&(d=Vo({inputs:{x:s},backend:e,attrs:{perm:u}}),h.push(d),l=_r(l.length,d.shape.length)),l=[l[0]],_s("argMax",l,d.shape.length);const[p,g]=as(d.shape,l),b=er(Ee(p),"int32"),_=Ee(g),I=e.data.get(d.dataId).values;for(let S=0;S<b.length;++S){const T=S*_;let O=I[T],V=0;for(let U=0;U<_;++U){const j=I[T+U];j>O&&(O=j,V=U)}b[S]=V}return h.forEach(S=>e.disposeIntermediateTensorInfo(S)),e.makeTensorInfo(p,"int32",b)}},g4={kernelName:kt,backendName:"cpu",kernelFunc:function m4(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:o}=r;Xt(s,"argMin");let l=Tt(o,s.shape);const u=pr(l,s.shape.length);let d=s;const h=[];null!=u&&(d=Vo({inputs:{x:s},backend:e,attrs:{perm:u}}),h.push(d),l=_r(l.length,d.shape.length)),l=[l[0]],_s("argMin",l,d.shape.length);const[p,g]=as(d.shape,l),b=er(Ee(p),"int32"),_=Ee(g),I=e.data.get(d.dataId).values;for(let S=0;S<b.length;++S){const T=S*_;let O=I[T],V=0;for(let U=0;U<_;++U){const j=I[T+U];j<O&&(O=j,V=U)}b[S]=V}return h.forEach(S=>e.disposeIntermediateTensorInfo(S)),e.makeTensorInfo(p,"int32",b)}},y4=Qn(an,n=>Math.asin(n)),v4={kernelName:an,backendName:"cpu",kernelFunc:y4},b4=Qn(Bn,n=>Math.asinh(n)),_4={kernelName:Bn,backendName:"cpu",kernelFunc:b4},x4=Qn(Wr,n=>Math.atan(n)),w4={kernelName:Wr,backendName:"cpu",kernelFunc:x4},C4=Zr((n,t)=>Math.atan2(n,t)),S4=Es(tr,C4),E4={kernelName:tr,backendName:"cpu",kernelFunc:S4},I4=Qn(xo,n=>Math.atanh(n)),D4={kernelName:xo,backendName:"cpu",kernelFunc:I4};function qE(n,t,e,r,s,o){const l=s.strideHeight,u=s.strideWidth,d=s.dilationHeight,h=s.dilationWidth,p=s.effectiveFilterHeight,g=s.effectiveFilterWidth,y=s.padInfo.top,b=s.padInfo.left,_="max"===o?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,I=gn(s.outShape,e),S=I.values,T=s.outShape[1]*s.outShape[2]*s.outShape[3],O=s.outShape[2]*s.outShape[3],V=s.outShape[3];for(let U=0;U<s.batchSize;++U){const j=U*T,te=U*r[0];for(let se=0;se<s.inChannels;++se)for(let le=0;le<s.outHeight;++le){const Ce=le*l-y,be=Math.max(0,Ce),Me=Math.min(s.inHeight,p+Ce),He=j+le*O;for(let We=0;We<s.outWidth;++We){const je=We*u-b,Ke=Math.max(0,je),Se=Math.min(s.inWidth,g+je);let ke=_,De=0,Be=0;for(let pt=be;pt<Me;pt+=d){const wt=te+pt*r[1];for(let gt=Ke;gt<Se;gt+=h){const It=n[wt+gt*r[2]+se];"max"===o&&It>ke?ke=It:"avg"===o&&(De+=It,Be++)}if(isNaN(ke))break}S[He+We*V+se]="avg"===o?De/Be:ke}}}return I}function Lk(n,t,e,r,s=!1,o=!1){const l=gn(r.outShape,"int32"),u=r.strideHeight,d=r.strideWidth,h=r.dilationHeight,p=r.dilationWidth,g=r.effectiveFilterHeight,y=r.effectiveFilterWidth,b=r.padInfo.top,_=r.padInfo.left,I=gn(t,e,n);for(let S=0;S<r.batchSize;++S)for(let T=0;T<r.inChannels;++T)for(let O=0;O<r.outHeight;++O){const V=O*u-b;let U=V;for(;U<0;)U+=h;const j=Math.min(r.inHeight,g+V);for(let te=0;te<r.outWidth;++te){const se=te*d-_;let le=se;for(;le<0;)le+=p;const Ce=Math.min(r.inWidth,y+se);let be=Number.NEGATIVE_INFINITY,Me=-1;for(let He=U;He<j;He+=h){const We=He-V;for(let je=le;je<Ce;je+=p){const Ke=je-se,Se=I.get(S,He,je,T);Se>be&&(be=Se,Me=s?o?((S*r.inHeight+He)*r.inWidth+je)*r.inChannels+T:(He*r.inWidth+je)*r.inChannels+T:We*y+Ke)}}l.set(Me,S,O,te,T)}}return l}function Bk(n,t,e,r,s,o){const l=s.strideDepth,u=s.strideHeight,d=s.strideWidth,h=s.dilationDepth,p=s.dilationHeight,g=s.dilationWidth,y=s.effectiveFilterDepth,b=s.effectiveFilterHeight,_=s.effectiveFilterWidth,I=s.padInfo.front,S=s.padInfo.top,T=s.padInfo.left,O="max"===o?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,V=gn(s.outShape,e),U=V.values,j=s.outShape[1]*s.outShape[2]*s.outShape[3]*s.outShape[4],te=s.outShape[2]*s.outShape[3]*s.outShape[4],se=s.outShape[3]*s.outShape[4],le=s.outShape[4];for(let Ce=0;Ce<s.batchSize;++Ce){const be=Ce*j,Me=Ce*r[0];for(let He=0;He<s.inChannels;++He)for(let We=0;We<s.outDepth;++We){const je=We*l-I;let Ke=je;for(;Ke<0;)Ke+=h;const Se=Math.min(s.inDepth,y+je),ke=be+We*te;for(let De=0;De<s.outHeight;++De){const Be=De*u-S;let rt=Be;for(;rt<0;)rt+=p;const pt=Math.min(s.inHeight,b+Be),wt=ke+De*se;for(let gt=0;gt<s.outWidth;++gt){const yt=gt*d-T;let It=yt;for(;It<0;)It+=g;const zt=Math.min(s.inWidth,_+yt),Vt=wt+gt*le;let tn=O,Yt=0,vn=0;for(let Jn=Ke;Jn<Se;Jn+=h){const gr=Me+Jn*r[1];for(let Hr=rt;Hr<pt;Hr+=p){const yr=gr+Hr*r[2];for(let ar=It;ar<zt;ar+=g){const Ir=n[yr+ar*r[3]+He];if("max"===o&&Ir>tn?tn=Ir:"avg"===o&&(Yt+=Ir,vn++),isNaN(tn))break}if(isNaN(tn))break}if(isNaN(tn))break}U[Vt+He]="avg"===o?Yt/Math.max(vn,1):tn}}}}return V}const k4={kernelName:Ms,backendName:"cpu",kernelFunc:function N4(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t;Xt(s,"avgPool");const{filterSize:o,strides:l,pad:u,dimRoundingMode:d}=r;G(Ns(l,1),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${l} and dilations '1'`);const p=$o(s.shape,o,l,1,u,d);let g;if(1===p.filterWidth&&1===p.filterHeight&&un(p.inShape,p.outShape))g=ql({inputs:{x:s},backend:e});else{const y=e.data.get(s.dataId).values,b=Wt(s.shape),_=qE(y,0,s.dtype,b,p,"avg");g=e.makeTensorInfo(p.outShape,s.dtype,_.values)}return g}},R4={kernelName:hs,backendName:"cpu",kernelFunc:function A4(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{filterSize:o,strides:l,pad:u,dimRoundingMode:d,dataFormat:h}=r;Xt(s,"avgPool3d");const p=Ka(s.shape,o,l,1,u,d,h),y=Bk(e.data.get(s.dataId).values,0,s.dtype,Wt(s.shape),p,"avg");return e.makeTensorInfo(y.shape,"float32",y.values)}},O4={kernelName:wo,backendName:"cpu",kernelFunc:function M4(n){const{inputs:t,backend:e,attrs:r}=n,{dy:s,input:o}=t,{filterSize:l,strides:u,pad:d,dimRoundingMode:h}=r;Xt([s,o],"avgPool3DGrad");const p=Ka(o.shape,l,u,1,d,h),g=p.strideDepth,y=p.strideHeight,b=p.strideWidth,_=p.filterDepth,I=p.filterHeight,S=p.filterWidth,T=p.dilationDepth,O=p.dilationHeight,V=p.dilationWidth,U=p.effectiveFilterDepth,j=p.effectiveFilterHeight,te=p.effectiveFilterWidth,se=U-1-p.padInfo.front,le=te-1-p.padInfo.left,Ce=j-1-p.padInfo.top,be=gn(o.shape,"float32"),Me=1/(_*I*S),He=e.bufferSync(s);for(let We=0;We<p.batchSize;++We)for(let je=0;je<p.inChannels;++je)for(let Ke=0;Ke<p.inDepth;++Ke)for(let Se=0;Se<p.inHeight;++Se)for(let ke=0;ke<p.inWidth;++ke){const De=Ke-se,Be=Se-Ce,rt=ke-le;let pt=0;for(let wt=0;wt<U;wt+=T){const gt=(De+wt)/g;if(!(gt<0||gt>=p.outDepth||Math.floor(gt)!==gt))for(let yt=0;yt<j;yt+=O){const It=(Be+yt)/y;if(!(It<0||It>=p.outHeight||Math.floor(It)!==It))for(let zt=0;zt<te;zt+=V){const Vt=(rt+zt)/b;Vt<0||Vt>=p.outWidth||Math.floor(Vt)!==Vt||(pt+=He.get(We,gt,It,Vt,je))}}}be.set(pt*Me,We,Ke,Se,ke,je)}return e.makeTensorInfo(be.shape,be.dtype,be.values)}},$4={kernelName:nr,backendName:"cpu",kernelFunc:function F4(n){const{inputs:t,backend:e,attrs:r}=n,{dy:s,input:o}=t,l=o;Xt([s,o],"avgPoolGrad");const{filterSize:u,strides:d,pad:h}=r,p=$o(l.shape,u,d,1,h),g=p.strideHeight,y=p.strideWidth,b=p.filterHeight,_=p.filterWidth,I=p.dilationHeight,S=p.dilationWidth,T=p.effectiveFilterHeight,O=p.effectiveFilterWidth,V=O-1-p.padInfo.left,U=T-1-p.padInfo.top,j=gn(l.shape,"float32"),te=1/(b*_),se=e.data.get(s.dataId).values,le=gn(s.shape,"float32",se);for(let Ce=0;Ce<p.batchSize;++Ce)for(let be=0;be<p.inChannels;++be)for(let Me=0;Me<p.inHeight;++Me)for(let He=0;He<p.inWidth;++He){const We=Me-U,je=He-V;let Ke=0;for(let Se=0;Se<T;Se+=I){const ke=(We+Se)/g;if(!(ke<0||ke>=p.outHeight||Math.floor(ke)!==ke))for(let De=0;De<O;De+=S){const Be=(je+De)/y;Be<0||Be>=p.outWidth||Math.floor(Be)!==Be||(Ke+=le.get(Ce,ke,Be,be))}}j.set(Ke*te,Ce,Me,He,be)}return e.makeTensorInfo(j.shape,j.dtype,j.values)}},L4={kernelName:ic,backendName:"cpu",kernelFunc:function P4(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,scale:o,offset:l,mean:u,variance:d}=t;G(u.shape.length===d.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),G(null==l||u.shape.length===l.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),G(null==o||u.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),Xt([s,u,d,o,l],"batchNorm");let{varianceEpsilon:h}=r;null==h&&(h=.001);const p=e.data.get(s.dataId).values,g=e.data.get(u.dataId).values,y=e.data.get(d.dataId).values,b=o?e.data.get(o.dataId).values:new Float32Array([1]),_=l?e.data.get(l.dataId).values:new Float32Array([0]),I=new Float32Array(p.length),S=_.length,T=b.length,O=y.length,V=g.length;let U=0,j=0,te=0,se=0;for(let le=0;le<p.length;++le)I[le]=_[U++]+(p[le]-g[j++])*b[te++]/Math.sqrt(y[se++]+h),U>=S&&(U=0),j>=V&&(j=0),te>=T&&(te=0),se>=O&&(se=0);return e.makeTensorInfo(s.shape,s.dtype,I)}},V4={kernelName:Fi,backendName:"cpu",kernelFunc:function B4(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{blockShape:o,crops:l}=r;Xt([s],"batchToSpaceND");const u=o.reduce((T,O)=>T*O),d=rh(s.shape,o,u),h=sh(d.length,o.length),p=oh(s.shape,o,u),g=Bg(l,o.length),y=Vg(p,l,o.length),b=mr({inputs:{x:s},backend:e,attrs:{shape:d}}),_=Vo({inputs:{x:b},backend:e,attrs:{perm:h}}),I=mr({inputs:{x:_},backend:e,attrs:{shape:p}}),S=Eh({inputs:{x:I},backend:e,attrs:{begin:g,size:y}});return e.disposeIntermediateTensorInfo(b),e.disposeIntermediateTensorInfo(_),e.disposeIntermediateTensorInfo(I),S}},z4={kernelName:Co,backendName:"cpu",kernelFunc:function U4(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,weights:o}=t,{size:l}=r,h=OE(e.data.get(s.dataId).values,e.data.get(o.dataId).values,o.dtype,o.shape,l);return e.makeTensorInfo([l],o.dtype,h)}},W4={kernelName:cr,backendName:"cpu",kernelFunc:function H4(n){const{inputs:t,backend:e}=n,{s0:r,s1:s}=t,o=e.data.get(r.dataId).values,l=e.data.get(s.dataId).values,u=Nn(Array.from(o),Array.from(l));return e.makeTensorInfo([u.length],"int32",Int32Array.from(u))}},j4=Qn(Br,(n,t)=>n>t.clipValueMax?t.clipValueMax:n<t.clipValueMin?t.clipValueMin:n),G4={kernelName:Br,backendName:"cpu",kernelFunc:j4},K4={kernelName:Eo,backendName:"cpu",kernelFunc:n=>{const{x:t}=n.inputs,e=n.backend,r=new Float32Array(Ee(t.shape)),s=e.data.get(t.dataId),l=s.complexTensorInfos.imag,u=e.data.get(s.complexTensorInfos.real.dataId).values,d=e.data.get(l.dataId).values;for(let h=0;h<u.length;h++)r[h]=Math.hypot(u[h],d[h]);return e.makeOutput(r,t.shape,"float32")}};function Dp(n){const{inputs:t,backend:e}=n,{input:r}=t,s=e.data.get(r.dataId).complexTensorInfos.imag,o=e.data.get(s.dataId).values;return e.makeTensorInfo(s.shape,s.dtype,o)}const q4={kernelName:ts,backendName:"cpu",kernelFunc:Dp};function Tp(n){const{inputs:t,backend:e,attrs:r}=n,{axis:s}=r,o=Tt(s,t[0].shape)[0];Mg(t.map(I=>I.shape),o);let u=fo(t.map(I=>I.shape),o);if(0===Ee(u))return e.makeTensorInfo(u,t[0].dtype,[]);const d=t.filter(I=>Ee(I.shape)>0);if(1===d.length)return ql({inputs:{x:d[0]},backend:e});if("complex64"===d[0].dtype){const I=d.map(U=>Ch({inputs:{input:U},backend:e})),S=d.map(U=>Dp({inputs:{input:U},backend:e})),T=Tp({inputs:I,backend:e,attrs:{axis:o}}),O=Tp({inputs:S,backend:e,attrs:{axis:o}}),V=ci({inputs:{real:T,imag:O},backend:e});return I.forEach(U=>e.disposeIntermediateTensorInfo(U)),S.forEach(U=>e.disposeIntermediateTensorInfo(U)),e.disposeIntermediateTensorInfo(T),e.disposeIntermediateTensorInfo(O),V}const h=d.map(I=>{const S=Ee(I.shape.slice(o));return mr({inputs:{x:I},backend:e,attrs:{shape:[-1,S]}})}),p=h.map(I=>({vals:e.data.get(I.dataId).values,shape:I.shape}));u=fo(h.map(I=>I.shape),1);const y=LT(p,u,t[0].dtype,1===h[0].shape[0]),b=fo(d.map(I=>I.shape),o),_=e.makeTensorInfo(b,t[0].dtype,y);return h.forEach(I=>e.disposeIntermediateTensorInfo(I)),_}const X4={kernelName:Vn,backendName:"cpu",kernelFunc:Tp};function Vk(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,filter:o}=t,{strides:l,pad:u,dataFormat:d,dilations:h,dimRoundingMode:p}=r;Xt([s,o],"conv2d");const g=sn(d),y=Xr(s.shape,o.shape,l,h,u,p,!1,g),b=y.filterHeight,_=y.filterWidth,I=y.dilationHeight,S=y.dilationWidth,T=y.padInfo.left,O=y.padInfo.top,V="channelsLast"===y.dataFormat,U=new zr(y.outShape,s.dtype),j=Wt(s.shape),te=Wt(o.shape),se=j[0],le=V?j[1]:j[2],Ce=V?j[2]:1,be=V?1:j[1],Me=U.strides[0],He=V?U.strides[1]:U.strides[2],We=V?U.strides[2]:1,je=V?1:U.strides[1],Ke=e.data.get(s.dataId).values,Se=e.data.get(o.dataId).values,ke=U.values;for(let De=0;De<y.batchSize;++De){const Be=De*se,rt=De*Me;for(let pt=0;pt<y.outHeight;++pt){const wt=rt+pt*He,gt=pt*y.strideHeight-O;for(let yt=0;yt<b;++yt){const It=gt+yt*I;if(It<0||It>=y.inHeight)continue;const zt=yt*te[0],Vt=Be+It*le;for(let tn=0;tn<y.outWidth;++tn){const Yt=wt+tn*We,vn=tn*y.strideWidth-T;for(let wn=0;wn<_;++wn){const Jn=vn+wn*S;if(Jn<0||Jn>=y.inWidth)continue;const Hr=Vt+Jn*Ce;let yr=zt+wn*te[1];for(let ar=0;ar<y.inChannels;++ar){const Or=Ke[Hr+ar*be];for(let Ir=0;Ir<y.outChannels;++Ir)ke[Yt+Ir*je]+=Or*Se[yr+Ir];yr+=y.outChannels}}}}}}return e.makeTensorInfo(U.shape,U.dtype,ke)}const Y4={kernelName:sl,backendName:"cpu",kernelFunc:Vk},Q4={kernelName:ol,backendName:"cpu",kernelFunc:function Z4(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,dy:o}=t,{strides:l,pad:u,dataFormat:d,dimRoundingMode:h,filterShape:p}=r;Xt([s,o],"conv2dBackpropFilter");const g=sn(d),y=Xr(s.shape,p,l,1,u,h,!1,g),{strideHeight:b,strideWidth:_,filterHeight:I,filterWidth:S}=y,T="channelsLast"===y.dataFormat,O=new zr(y.filterShape,"float32"),V=y.padInfo.left,U=y.padInfo.top,j=e.data.get(s.dataId).values,te=e.data.get(o.dataId).values,se=new zr(s.shape,s.dtype,j),le=new zr(o.shape,o.dtype,te);for(let Ce=0;Ce<I;++Ce){const be=Math.max(0,Math.ceil((U-Ce)/b)),Me=Math.min(y.outHeight,(y.inHeight+U-Ce)/b);for(let He=0;He<S;++He){const We=Math.max(0,Math.ceil((V-He)/_)),je=Math.min(y.outWidth,(y.inWidth+V-He)/_);for(let Ke=0;Ke<y.inChannels;++Ke)for(let Se=0;Se<y.outChannels;++Se){let ke=0;for(let De=0;De<y.batchSize;++De)for(let Be=be;Be<Me;++Be){const rt=Ce+Be*b-U;for(let pt=We;pt<je;++pt){const wt=He+pt*_-V;ke+=T?se.get(De,rt,wt,Ke)*le.get(De,Be,pt,Se):se.get(De,Ke,rt,wt)*le.get(De,Se,Be,pt)}}O.set(ke,Ce,He,Ke,Se)}}}return e.makeTensorInfo(O.shape,O.dtype,O.values)}},ez={kernelName:jr,backendName:"cpu",kernelFunc:function J4(n){const{inputs:t,backend:e,attrs:r}=n,{dy:s,filter:o}=t,{inputShape:l,strides:u,pad:d,dataFormat:h,dimRoundingMode:p}=r;Xt([s,o],"conv2dBackpropInput");const g=Wt(o.shape),y=Wt(s.shape);let b=sn(h);const _=Xr(l,o.shape,u,1,d,p,!1,b),I=new zr(_.inShape,"float32"),S=I.values,T=e.data.get(s.dataId).values,O=e.data.get(o.dataId).values,[V,U,j]=g,{batchSize:te,filterHeight:se,filterWidth:le,inChannels:Ce,inHeight:be,inWidth:Me,outChannels:He,outHeight:We,outWidth:je,strideHeight:Ke,strideWidth:Se}=_;b=_.dataFormat;const ke=se-1-_.padInfo.top,De=le-1-_.padInfo.left,Be="channelsLast"===b,rt=I.strides[0],pt=Be?I.strides[1]:I.strides[2],wt=Be?I.strides[2]:1,gt=Be?1:I.strides[1],yt=y[0],It=Be?y[1]:y[2],zt=Be?y[2]:1,Vt=Be?1:y[1];for(let tn=0;tn<te;++tn)for(let Yt=0;Yt<Ce;++Yt)for(let vn=0;vn<be;++vn){const wn=vn-ke,Jn=Math.max(0,Math.ceil(wn/Ke)),gr=Math.min(We,(se+wn)/Ke);for(let Hr=0;Hr<Me;++Hr){const yr=Hr-De,ar=Math.max(0,Math.ceil(yr/Se)),Or=Math.min(je,(le+yr)/Se);let Ir=0;for(let js=Jn;js<gr;++js){const cd=js*Ke-wn;for(let Oi=ar;Oi<Or;++Oi){const rl=yt*tn+It*js+zt*Oi,qc=V*(se-1-cd)+U*(le-1-(Oi*Se-yr))+j*Yt;for(let ud=0;ud<He;++ud)Ir+=T[rl+Vt*ud]*O[qc+ud]}}S[rt*tn+pt*vn+wt*Hr+gt*Yt]=Ir}}return e.makeTensorInfo(I.shape,I.dtype,I.values)}},nz={kernelName:es,backendName:"cpu",kernelFunc:function tz(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,filter:o}=t,{strides:l,pad:u,dilations:d}=r;Xt([s,o],"conv3d");const h=Ml(s.shape,o.shape,l,d,u),{filterDepth:p,filterHeight:g,filterWidth:y,dilationDepth:b,dilationHeight:_,dilationWidth:I,padInfo:S}=h,T=S.front,O=S.left,V=S.top,U=new zr(h.outShape,s.dtype),j=e.data.get(s.dataId).values,te=e.data.get(o.dataId).values,se=U.values,le=Wt(s.shape),Ce=Wt(o.shape);for(let be=0;be<h.batchSize;++be){const Me=be*le[0],He=be*U.strides[0];for(let We=0;We<h.outDepth;++We){const je=He+We*U.strides[1],Ke=We*h.strideDepth-T;for(let Se=0;Se<p;++Se){const ke=Ke+Se*b;if(ke<0||ke>=h.inDepth)continue;const De=Se*Ce[0],Be=Me+ke*le[1];for(let rt=0;rt<h.outHeight;++rt){const pt=je+rt*U.strides[2],wt=rt*h.strideHeight-V;for(let gt=0;gt<g;++gt){const yt=wt+gt*_;if(yt<0||yt>=h.inHeight)continue;const It=De+gt*Ce[1],zt=Be+yt*le[2];for(let Vt=0;Vt<h.outWidth;++Vt){const tn=pt+Vt*h.outChannels,Yt=Vt*h.strideWidth-O;for(let vn=0;vn<y;++vn){const wn=Yt+vn*I;if(wn<0||wn>=h.inWidth)continue;const gr=zt+wn*h.inChannels;let Hr=It+vn*Ce[2];for(let yr=0;yr<h.inChannels;++yr){const ar=j[gr+yr];for(let Or=0;Or<h.outChannels;++Or)se[tn+Or]+=ar*te[Hr+Or];Hr+=h.outChannels}}}}}}}}return e.makeTensorInfo(U.shape,U.dtype,U.values)}},sz={kernelName:hi,backendName:"cpu",kernelFunc:function rz(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,dy:o}=t,{strides:l,pad:u,filterShape:d}=r;Xt([s,o],"conv3dBackpropFilterV2");const h=Wt(s.shape),p=Wt(o.shape),g=Ml(s.shape,d,l,1,u),y=g.strideDepth,b=g.strideHeight,_=g.strideWidth,I=g.filterDepth,S=g.filterHeight,T=g.filterWidth,O=new zr(g.filterShape,"float32"),V=O.values,[U,j,te,se]=O.strides,le=e.data.get(o.dataId).values,[Ce,be,Me,He]=p,We=e.data.get(s.dataId).values,[je,Ke,Se,ke]=h,De=g.padInfo.front,Be=g.padInfo.left,rt=g.padInfo.top;for(let pt=0;pt<I;++pt){const wt=Math.max(0,Math.ceil((De-pt)/y)),gt=Math.min(g.outDepth,(g.inDepth+De-pt)/y),yt=pt*U;for(let It=0;It<S;++It){const zt=Math.max(0,Math.ceil((rt-It)/b)),Vt=Math.min(g.outHeight,(g.inHeight+rt-It)/b),tn=It*j+yt;for(let Yt=0;Yt<T;++Yt){const vn=Math.max(0,Math.ceil((Be-Yt)/_)),wn=Math.min(g.outWidth,(g.inWidth+Be-Yt)/_),Jn=Yt*te+tn;for(let gr=0;gr<g.inChannels;++gr){const Hr=gr*se+Jn;for(let yr=0;yr<g.outChannels;++yr){let ar=0;for(let Or=0;Or<g.batchSize;++Or){const Ir=Or*je,Kc=Or*Ce;for(let js=wt;js<gt;++js){const Oi=(pt+js*y-De)*Ke+Ir,Fh=js*be+Kc;for(let rl=zt;rl<Vt;++rl){const ud=(It+rl*b-rt)*Se+Oi,dd=rl*Me+Fh;for(let hd=vn;hd<wn;++hd)ar+=We[(Yt+hd*_-Be)*ke+ud+gr]*le[hd*He+dd+yr]}}}V[Hr+yr]=ar}}}}}return e.makeTensorInfo(O.shape,O.dtype,O.values)}},iz={kernelName:Gr,backendName:"cpu",kernelFunc:function oz(n){const{inputs:t,backend:e,attrs:r}=n,{dy:s,filter:o}=t,{pad:l,strides:u,inputShape:d}=r;Xt([s],"conv3dBackpropInputV2");const h=Wt(s.shape),p=Wt(o.shape),g=Ml(d,o.shape,u,1,l),y=new zr(g.inShape,"float32"),b=y.values,[_,I,S,T]=y.strides,O=e.data.get(s.dataId).values,[V,U,j,te]=h,se=e.data.get(o.dataId).values,[le,Ce,be,Me]=p,{batchSize:He,filterDepth:We,filterHeight:je,filterWidth:Ke,inChannels:Se,inDepth:ke,inHeight:De,inWidth:Be,outChannels:rt,outDepth:pt,outHeight:wt,outWidth:gt,strideDepth:yt,strideHeight:It,strideWidth:zt}=g,Vt=We-1-g.padInfo.front,tn=je-1-g.padInfo.top,Yt=Ke-1-g.padInfo.left;for(let vn=0;vn<He;++vn)for(let wn=0;wn<Se;++wn)for(let Jn=0;Jn<ke;++Jn){const gr=Jn-Vt,Hr=Math.max(0,Math.ceil(gr/yt)),yr=Math.min(pt,(We+gr)/yt);for(let ar=0;ar<De;++ar){const Or=ar-tn,Ir=Math.max(0,Math.ceil(Or/It)),Kc=Math.min(wt,(je+Or)/It);for(let js=0;js<Be;++js){const cd=js-Yt,Oi=Math.max(0,Math.ceil(cd/zt)),Fh=Math.min(gt,(Ke+cd)/zt);let rl=0;for(let qc=Hr;qc<yr;++qc){const ud=qc*yt-gr;for(let dd=Ir;dd<Kc;++dd){const hd=dd*It-Or;for(let Yy=Oi;Yy<Fh;++Yy){const RI=V*vn+U*qc+j*dd+te*Yy,o8=le*(We-1-ud)+Ce*(je-1-hd)+be*(Ke-1-(Yy*zt-cd))+Me*wn;for(let Fx=0;Fx<rt;++Fx)rl+=O[RI+Fx]*se[o8+Fx]}}}b[_*vn+I*Jn+S*ar+T*js+wn]=rl}}}return e.makeTensorInfo(y.shape,y.dtype,y.values)}},az=Qn(Io,n=>Math.cos(n)),lz={kernelName:Io,backendName:"cpu",kernelFunc:az},cz=Qn(ps,n=>Math.cosh(n)),uz={kernelName:ps,backendName:"cpu",kernelFunc:cz},hz={kernelName:qs,backendName:"cpu",kernelFunc:function dz(n){const{inputs:t,backend:e,attrs:r}=n,{image:s,boxes:o,boxInd:l}=t,{cropSize:u,method:d,extrapolationValue:h}=r,[p,g,y,b]=s.shape,_=o.shape[0],[I,S]=u,T=gn([_,I,S,b],"float32"),O=e.data.get(o.dataId).values,V=e.data.get(l.dataId).values,U=e.data.get(s.dataId).values,j=Wt(s.shape),te=Wt(T.shape);for(let se=0;se<_;se++){const le=4*se,Ce=O[le],be=O[le+1],Me=O[le+2],He=O[le+3],We=V[se];if(We>=p)continue;const je=I>1?(Me-Ce)*(g-1)/(I-1):0,Ke=S>1?(He-be)*(y-1)/(S-1):0;for(let Se=0;Se<I;Se++){const ke=I>1?Ce*(g-1)+Se*je:.5*(Ce+Me)*(g-1);if(ke<0||ke>g-1)for(let De=0;De<S;De++)for(let Be=0;Be<b;Be++)T.values[Be+De*te[2]+Se*te[1]+se*te[0]]=h;else if("bilinear"===d){const De=Math.floor(ke),Be=Math.ceil(ke),rt=ke-De;for(let pt=0;pt<S;pt++){const wt=S>1?be*(y-1)+pt*Ke:.5*(be+He)*(y-1);if(wt<0||wt>y-1){for(let zt=0;zt<b;zt++)T.values[zt+pt*te[2]+Se*te[1]+se*te[0]]=h;continue}const gt=Math.floor(wt),yt=Math.ceil(wt),It=wt-gt;for(let zt=0;zt<b;zt++){let Vt=zt+gt*j[2]+De*j[1]+We*j[0];const tn=U[Vt];Vt=zt+yt*j[2]+De*j[1]+We*j[0];const Yt=U[Vt];Vt=zt+gt*j[2]+Be*j[1]+We*j[0];const vn=U[Vt];Vt=zt+yt*j[2]+Be*j[1]+We*j[0];const wn=U[Vt],Jn=tn+(Yt-tn)*It;Vt=zt+pt*te[2]+Se*te[1]+se*te[0],T.values[Vt]=Jn+(vn+(wn-vn)*It-Jn)*rt}}}else for(let De=0;De<S;++De){const Be=S>1?be*(y-1)+De*Ke:.5*(be+He)*(y-1);if(Be<0||Be>y-1){for(let wt=0;wt<b;wt++)T.values[wt+De*te[2]+Se*te[1]+se*te[0]]=h;continue}const rt=Math.round(Be),pt=Math.round(ke);for(let wt=0;wt<b;wt++)T.values[wt+De*te[2]+Se*te[1]+se*te[0]]=U[wt+rt*j[2]+pt*j[1]+We*j[0]]}}}return e.makeTensorInfo(T.shape,T.dtype,T.values)}},pz={kernelName:il,backendName:"cpu",kernelFunc:function fz(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:o,exclusive:l,reverse:u}=r;Xt(s,"cumprod");const d=pr([o],s.shape.length);let h=s;null!=d&&(h=Vo({inputs:{x:s},backend:e,attrs:{perm:d}}));const p=_r(1,s.shape.length)[0];if(p!==h.shape.length-1)throw new Error(`backend.cumprod in CPU expects an inner-most axis=${h.shape.length-1} but got axis=${p}`);const g=ye(h.dtype,"int32"),y=_o(Ee(h.shape),g),b=e.data.get(h.dataId).values,_=h.shape[h.shape.length-1],I=u?(T,O)=>T+_-O-1:(T,O)=>T+O;for(let T=0;T<b.length;T+=_)for(let O=0;O<_;O++){const V=I(T,O);if(0===O)y[V]=l?1:b[V];else{const U=I(T,O-1);y[V]=l?b[U]*y[U]:b[V]*y[U]}}const S=e.makeTensorInfo(h.shape,g,y);if(null!=d){const O=Vo({inputs:{x:S},backend:e,attrs:{perm:na(d)}});return e.disposeIntermediateTensorInfo(S),e.disposeIntermediateTensorInfo(h),O}return S}},gz={kernelName:tc,backendName:"cpu",kernelFunc:function mz(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:o,exclusive:l,reverse:u}=r;Xt(s,"cumsum");const d=pr([o],s.shape.length);let h=s;null!=d&&(h=Vo({inputs:{x:s},backend:e,attrs:{perm:d}}));const p=_r(1,s.shape.length)[0];if(p!==h.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${h.shape.length-1} but got axis=${p}`);const g=ye(h.dtype,"int32"),y=er(Ee(h.shape),g),b=e.data.get(h.dataId).values,_=h.shape[h.shape.length-1],I=u?(T,O)=>T+_-O-1:(T,O)=>T+O;for(let T=0;T<b.length;T+=_)for(let O=0;O<_;O++){const V=I(T,O);if(0===O)y[V]=l?0:b[V];else{const U=I(T,O-1);y[V]=l?b[U]+y[U]:b[V]+y[U]}}const S=e.makeTensorInfo(h.shape,g,y);if(null!=d){const O=Vo({inputs:{x:S},backend:e,attrs:{perm:na(d)}});return e.disposeIntermediateTensorInfo(S),e.disposeIntermediateTensorInfo(h),O}return S}},vz={kernelName:ba,backendName:"cpu",kernelFunc:function yz(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,weights:o}=t,{size:l,binaryOutput:u}=r;if(1===s.shape.length){const p=OE(e.data.get(s.dataId).values,e.data.get(o.dataId).values,o.dtype,o.shape,l);return e.makeTensorInfo([l],o.dtype,p)}if(2===s.shape.length){const p=FT(e.bufferSync(s),e.bufferSync(o),l,u);return e.makeTensorInfo(p.shape,o.dtype,p.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${s.shape.length}.`)}},_z={kernelName:zo,backendName:"cpu",kernelFunc:function bz(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{blockSize:o,dataFormat:l}=r;G("NHWC"===l,()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${l}`);const u=s.shape[0],d=s.shape[1],h=s.shape[2],p=s.shape[3],g=d*o,y=h*o,b=p/(o*o),_=e.data.get(s.dataId).values,I=new Float32Array(u*g*y*b);let S=0;for(let T=0;T<u;++T)for(let O=0;O<g;++O){const V=Math.floor(O/o),U=O%o;for(let j=0;j<y;++j){const te=Math.floor(j/o),le=(U*o+j%o)*b;for(let Ce=0;Ce<b;++Ce)I[S++]=_[Ce+le+p*(te+h*(V+d*T))]}}return e.makeTensorInfo([u,g,y,b],s.dtype,I)}};function Uk(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,filter:o}=t,{strides:l,pad:u,dilations:d,dimRoundingMode:h}=r;Xt([s,o],"depthwiseConv2DNative");const p=Wt(s.shape),g=Wt(o.shape);let y=d;null==y&&(y=[1,1]),G(Ns(l,y),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${y}'`);const b=Xr(s.shape,o.shape,l,y,u,h,!0),{filterHeight:_,filterWidth:I,dilationHeight:S,dilationWidth:T,padInfo:O}=b,V=O.left,U=O.top,j=b.outChannels/b.inChannels,te=new zr(b.outShape,s.dtype),se=e.data.get(s.dataId).values,le=e.data.get(o.dataId).values,Ce=te.values;for(let be=0;be<b.batchSize;++be){const Me=be*p[0],He=be*te.strides[0];for(let We=0;We<b.outHeight;++We){const je=He+We*te.strides[1],Ke=We*b.strideHeight-U;for(let Se=0;Se<_;++Se){const ke=Ke+Se*S;if(ke<0||ke>=b.inHeight)continue;const De=Se*g[0],Be=Me+ke*p[1];for(let rt=0;rt<b.outWidth;++rt){const pt=je+rt*te.strides[2],wt=rt*b.strideWidth-V;for(let gt=0;gt<I;++gt){const yt=wt+gt*T;if(yt<0||yt>=b.inWidth)continue;const zt=Be+yt*b.inChannels;let Vt=pt,tn=De+gt*g[1];for(let Yt=0;Yt<b.inChannels;++Yt){const vn=se[zt+Yt];for(let wn=0;wn<j;++wn)Ce[Vt+wn]+=vn*le[tn+wn];Vt+=j,tn+=j}}}}}}return e.makeTensorInfo(te.shape,te.dtype,te.values)}const xz={kernelName:_a,backendName:"cpu",kernelFunc:Uk},Cz={kernelName:nc,backendName:"cpu",kernelFunc:function wz(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,dy:o}=t,{strides:l,dilations:u,pad:d,dimRoundingMode:h,filterShape:p}=r;Xt([s,o],"depthwiseConv2dNativeBackpropFilter");const g=Xr(s.shape,p,l,u,d,h,!0),{strideHeight:y,strideWidth:b,filterHeight:_,filterWidth:I}=g,S=new zr(g.filterShape,"float32"),T=g.padInfo.left,O=g.padInfo.top,V=g.outChannels/g.inChannels,U=e.data.get(s.dataId).values,j=new zr(s.shape,s.dtype,U),te=e.data.get(o.dataId).values,se=new zr(o.shape,o.dtype,te);for(let le=0;le<_;++le){const Ce=Math.max(0,Math.ceil((O-le)/y)),be=Math.min(g.outHeight,(g.inHeight+O-le)/y);for(let Me=0;Me<I;++Me){const He=Math.max(0,Math.ceil((T-Me)/b)),We=Math.min(g.outWidth,(g.inWidth+T-Me)/b);for(let je=0;je<g.outChannels;++je){const Ke=Math.trunc(je/V),Se=je%V;let ke=0;for(let De=0;De<g.batchSize;++De)for(let Be=Ce;Be<be;++Be){const rt=le+Be*y-O;for(let pt=He;pt<We;++pt)ke+=j.get(De,rt,Me+pt*b-T,Ke)*se.get(De,Be,pt,je)}S.set(ke,le,Me,Ke,Se)}}}return e.makeTensorInfo(S.shape,S.dtype,S.values)}},Ez={kernelName:Xc,backendName:"cpu",kernelFunc:function Sz(n){const{inputs:t,backend:e,attrs:r}=n,{dy:s,filter:o}=t,{strides:l,dilations:u,pad:d,dimRoundingMode:h,inputShape:p}=r;Xt([s,o],"depthwiseConv2DNativeBackpropInput");const g=Wt(s.shape),y=Wt(o.shape),b=Xr(p,o.shape,l,u,d,h,!0),_=new zr(b.inShape,"float32"),I=_.values,[S,T,O]=_.strides,V=e.data.get(s.dataId).values,[U,j,te]=g,se=e.data.get(o.dataId).values,[le,Ce,be]=y,{batchSize:Me,filterHeight:He,filterWidth:We,inChannels:je,inHeight:Ke,inWidth:Se,outChannels:ke,outHeight:De,outWidth:Be,strideHeight:rt,strideWidth:pt}=b,wt=He-1-b.padInfo.top,gt=We-1-b.padInfo.left,yt=ke/je;for(let It=0;It<Me;++It)for(let zt=0;zt<je;++zt)for(let Vt=0;Vt<Ke;++Vt){const tn=Vt-wt,Yt=Math.max(0,Math.ceil(tn/rt)),vn=Math.min(De,(He+tn)/rt);for(let wn=0;wn<Se;++wn){const Jn=wn-gt,gr=Math.max(0,Math.ceil(Jn/pt)),Hr=Math.min(Be,(We+Jn)/pt);let yr=0;for(let ar=Yt;ar<vn;++ar){const Or=ar*rt-tn;for(let Ir=gr;Ir<Hr;++Ir){const js=U*It+j*ar+te*Ir,cd=le*(He-1-Or)+Ce*(We-1-(Ir*pt-Jn))+be*zt;for(let Oi=0;Oi<yt;++Oi)yr+=V[js+(zt*yt+Oi)]*se[cd+Oi]}}I[S*It+T*Vt+O*wn+zt]=yr}}return e.makeTensorInfo(_.shape,_.dtype,_.values)}},Dz={kernelName:Yc,backendName:"cpu",kernelFunc:function Iz(n){const{inputs:t,backend:e}=n,{x:r}=t,s=Ee(r.shape),o=e.data.get(r.dataId).values,l=gn([s,s],r.dtype),u=l.values;for(let h=0;h<o.length;h++)u[h*s+h]=o[h];const d=[...r.shape,...r.shape];return e.makeTensorInfo(d,l.dtype,l.values)}},Tz={kernelName:Zc,backendName:"cpu",kernelFunc:({inputs:n,backend:t,attrs:e})=>{const{x:r,filter:s}=n,{strides:o,pad:l,dilations:u}=e,d=t,h=d.data.get(r.dataId).values,p=r.shape.length,g=d.data.get(s.dataId).values,y=s.shape.length,{batchSize:b,inHeight:_,inWidth:I,inChannels:S,outHeight:T,outWidth:O,padInfo:V,strideHeight:U,strideWidth:j,filterHeight:te,filterWidth:se,dilationHeight:le,dilationWidth:Ce,outShape:be}=uf(r.shape,s.shape,o,l,"NHWC",u),Me=Ee(be),He=be.length,We=Ft(r.dtype,Me);for(let Ke=0;Ke<b;++Ke)for(let Se=0;Se<T;++Se){const ke=Se*U-V.top;for(let De=0;De<O;++De){const Be=De*j-V.left;for(let rt=0;rt<S;++rt){let pt=Number.MIN_SAFE_INTEGER;for(let gt=0;gt<te;++gt){const yt=ke+gt*le;if(yt>=0&&yt<_)for(let It=0;It<se;++It){const zt=Be+It*Ce;if(zt>=0&&zt<I){const Vt=Qr([Ke,yt,zt,rt],p,Wt(r.shape)),tn=Qr([gt,It,rt],y,Wt(s.shape)),Yt=h[Vt]+g[tn];Yt>pt&&(pt=Yt)}}}We[Qr([Ke,Se,De,rt],He,Wt(be))]=pt}}}return{dataId:d.write(xi(We,r.dtype),be,r.dtype),shape:be,dtype:r.dtype}}},Nz={kernelName:pd,backendName:"cpu",kernelFunc:({inputs:n,backend:t,attrs:e})=>{const{x:r,filter:s,dy:o}=n,{strides:l,pad:u,dilations:d}=e,h=t,p=Pr(r.shape,h.data.get(r.dataId).values),g=Pr(s.shape,h.data.get(s.dataId).values),{batchSize:y,inHeight:b,inWidth:_,inChannels:I,outHeight:S,outWidth:T,padInfo:O,strideHeight:V,strideWidth:U,filterHeight:j,filterWidth:te,dilationHeight:se,dilationWidth:le,outShape:Ce}=uf(r.shape,s.shape,l,u,"NHWC",d);G(o.rank===Ce.length,()=>`Error in ${pd}, dy must have the same rank as output ${Ce.length}, but got ${o.rank}`);const be=Pr(Ce,h.data.get(o.dataId).values),Me=ds(s.shape,s.dtype);for(let We=0;We<y;++We)for(let je=0;je<S;++je){const Ke=je*V-O.top;for(let Se=0;Se<T;++Se){const ke=Se*U-O.left;for(let De=0;De<I;++De){let Be=Number.MIN_SAFE_INTEGER,rt=0,pt=0;for(let wt=0;wt<j;++wt){const gt=Ke+wt*se;if(gt>=0&&gt<b)for(let yt=0;yt<te;++yt){const It=ke+yt*le;if(It>=0&&It<_){const zt=p[We][gt][It][De]+g[wt][yt][De];zt>Be&&(Be=zt,rt=wt,pt=yt)}}}Me[rt][pt][De]+=be[We][je][Se][De]}}}return{dataId:h.write(xi(Me,r.dtype),s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}},kz={kernelName:fd,backendName:"cpu",kernelFunc:({inputs:n,backend:t,attrs:e})=>{const{x:r,filter:s,dy:o}=n,{strides:l,pad:u,dilations:d}=e,h=t,p=Pr(r.shape,h.data.get(r.dataId).values),g=Pr(s.shape,h.data.get(s.dataId).values),{batchSize:y,inHeight:b,inWidth:_,inChannels:I,outHeight:S,outWidth:T,padInfo:O,strideHeight:V,strideWidth:U,filterHeight:j,filterWidth:te,dilationHeight:se,dilationWidth:le,outShape:Ce}=uf(r.shape,s.shape,l,u,"NHWC",d);G(o.rank===Ce.length,()=>`Error in ${fd}, dy must have the same rank as output ${Ce.length}, but got ${o.rank}`);const be=Pr(Ce,h.data.get(o.dataId).values),Me=ds(r.shape,r.dtype);for(let We=0;We<y;++We)for(let je=0;je<S;++je){const Ke=je*V-O.top;for(let Se=0;Se<T;++Se){const ke=Se*U-O.left;for(let De=0;De<I;++De){let Be=Number.MIN_SAFE_INTEGER,rt=Ke<0?0:Ke,pt=ke<0?0:ke;for(let wt=0;wt<j;++wt){const gt=Ke+wt*se;if(gt>=0&&gt<b)for(let yt=0;yt<te;++yt){const It=ke+yt*le;if(It>=0&&It<_){const zt=p[We][gt][It][De]+g[wt][yt][De];zt>Be&&(Be=zt,rt=gt,pt=It)}}}Me[We][rt][pt][De]+=be[We][je][Se][De]}}}return{dataId:h.write(xi(Me,r.dtype),r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},Rz={kernelName:"Draw",backendName:"cpu",kernelFunc:function Az(n){const{inputs:t,backend:e,attrs:r}=n,{image:s}=t,{canvas:o,options:l}=r,{contextOptions:u,imageOptions:d}=l||{},h=(null==d?void 0:d.alpha)||1,p=(null==u?void 0:u.contextType)||"2d";if("2d"!==p)throw new Error(`Context type ${u.contextType} is not supported by the CPU backend.`);const g=o.getContext(p,(null==u?void 0:u.contextAttributes)||{});if(null==g)throw new Error(`Could not get the context with ${p} type.`);const[y,b]=s.shape.slice(0,2),_=2===s.shape.length?1:s.shape[2],I=e.data.get(s.dataId).values,S="float32"===s.dtype?255:1,T=new Uint8ClampedArray(b*y*4);for(let V=0;V<y*b;++V){const U=[0,0,0,255*h];for(let te=0;te<_;te++){const se=I[V*_+te];if("float32"===s.dtype){if(se<0||se>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${se}.`)}else if("int32"===s.dtype&&(se<0||se>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${se}.`);1===_?(U[0]=se*S,U[1]=se*S,U[2]=se*S):U[te]=se*S}const j=4*V;T[j+0]=Math.round(U[0]),T[j+1]=Math.round(U[1]),T[j+2]=Math.round(U[2]),T[j+3]=Math.round(U[3])}o.width=b,o.height=y;const O=new ImageData(T,b,y);return g.putImageData(O,0,0),s}};function By(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:o,keepDims:l}=r;let u;Xt(s,"sum"),u="bool"===s.dtype?nd({inputs:{x:s},backend:e,attrs:{dtype:"int32"}}):ql({inputs:{x:s},backend:e});const d=u.shape.length,h=Tt(o,u.shape),p=pr(h,d);let g=h,y=u;null!=p&&(y=Vo({inputs:{x:u},backend:e,attrs:{perm:p}}),g=_r(g.length,d)),_s("sum",g,y.shape.length);const[b,_]=as(y.shape,g);let S=J_(e,b,ye(y.dtype,"int32"));const T=Ee(_),O=e.data.get(S.dataId).values,V=e.data.get(y.dataId).values;for(let U=0;U<O.length;++U){const j=U*T;let te=0;for(let se=0;se<T;++se)te+=V[j+se];O[U]=te}if(l){const j=S;S=mr({inputs:{x:S},backend:e,attrs:{shape:Yr(S.shape,h)}}),e.disposeIntermediateTensorInfo(j)}return e.disposeIntermediateTensorInfo(u),null!=p&&e.disposeIntermediateTensorInfo(y),S}const Mz={kernelName:"Sum",backendName:"cpu",kernelFunc:By},Fz={kernelName:Jc,backendName:"cpu",kernelFunc:function Oz(n){const{inputs:t,backend:e,attrs:r}=n,{equation:s}=r,o=t,{allDims:l,summedDims:u,idDims:d}=uh(s,o.length);qf(l.length,d,o);const{path:h,steps:p}=hh(u,d),g=p.length;let y=null,b=l.length;const _=[];for(let I=0;I<g;++I){for(const S of p[I]){const{permutationIndices:T,expandDims:O}=dh(b,d[S]);let V;fh(T)?V=o[S]:(V=Vo({inputs:{x:o[S]},backend:e,attrs:{perm:T}}),_.push(V));const U=V.shape.slice();for(let j=0;j<O.length;++j)U.splice(O[j],0,1);un(V.shape,U)||(V=mr({inputs:{x:V},backend:e,attrs:{shape:U}}),_.push(V)),null===y?y=V:(y=ex({inputs:{a:V,b:y},backend:e}),_.push(y))}I<g-1&&(h[I]>=0&&(y=By({inputs:{x:y},backend:e,attrs:{axis:h[I]-(l.length-b),keepDims:!1}}),_.push(y)),b--)}for(const I of _)I!==y&&e.disposeIntermediateTensorInfo(I);return y}},Pz={kernelName:md,backendName:"cpu",kernelFunc:function $z(n){const{inputs:t,backend:e}=n,{dy:r,y:s}=t;Xt([r,s],"eluGrad");const o=new Float32Array(Ee(s.shape)),l=e.data.get(s.dataId).values,u=e.data.get(r.dataId).values;for(let d=0;d<l.length;++d){const h=l[d];o[d]=h>=0?u[d]:u[d]*(h+1)}return e.makeTensorInfo(s.shape,"float32",o)}},Lz=ai,Bz=zg,Vz=ah,Uz=Uc,zz=Hg,Hz=Wg,Wz=Qn(sc,n=>{const t=Math.sign(n),e=Math.abs(n),r=1/(1+Lz*e);return t*(1-((((Hz*r+zz)*r+Uz)*r+Vz)*r+Bz)*r*Math.exp(-e*e))}),jz={kernelName:sc,backendName:"cpu",kernelFunc:Wz};function hx(n){const{inputs:t,backend:e,attrs:r}=n,{input:s}=t,{dim:o}=r,l=s.shape.length,u=s.shape.slice();let d=o;return o<0&&(G(-(l+1)<=o,()=>`Axis must be in the interval [${-(l+1)}, ${l}]`),d=l+o+1),u.splice(d,0,1),mr({inputs:{x:s},backend:e,attrs:{shape:u}})}const Gz={kernelName:xa,backendName:"cpu",kernelFunc:hx},Kz=Zr((n,t)=>n/t),XE=Es(rc,Kz),YE={kernelName:rc,backendName:"cpu",kernelFunc:XE};function zk(n,t,e){const r=n.shape,s=r[0],o=r[1],l=e.data.get(n.dataId),u=l.complexTensorInfos.real,d=l.complexTensorInfos.imag,h=[s,o],p=Ee(h),g=Rt("float32",p),y=Rt("float32",p);for(let S=0;S<s;S++){const T=Eh({inputs:{x:u},backend:e,attrs:{begin:[S,0],size:[1,o]}}),O=Eh({inputs:{x:d},backend:e,attrs:{begin:[S,0],size:[1,o]}}),V=ci({inputs:{real:T,imag:O},backend:e}),{real:U,imag:j}=qz(V,t,e),te=Qa(U,j);for(let se=0;se<o;se++){const le=jg(te,se);g[S*o+se]=le.real,y[S*o+se]=le.imag}e.disposeIntermediateTensorInfo(T),e.disposeIntermediateTensorInfo(O),e.disposeIntermediateTensorInfo(V)}const b=e.makeTensorInfo(h,"float32",g),_=e.makeTensorInfo(h,"float32",y),I=ci({inputs:{real:b,imag:_},backend:e});return e.disposeIntermediateTensorInfo(b),e.disposeIntermediateTensorInfo(_),I}function qz(n,t,e){const r=Ee(n.shape),s=e.data.get(n.dataId),o=e.data.get(s.complexTensorInfos.real.dataId).values,l=e.data.get(s.complexTensorInfos.imag.dataId).values;if(function Xz(n){return 0==(n&n-1)}(r)){const u=ZE(o,l,r,t,e),d=[n.shape[0],n.shape[1]];if(t){const h=e.makeTensorInfo(d,"float32",u.real),p=e.makeTensorInfo(d,"float32",u.imag),g=e.makeTensorInfo([],"float32",_i(r,"float32")),y=ql({inputs:{x:g},backend:e}),b=YE.kernelFunc({inputs:{a:h,b:g},backend:e}),_=YE.kernelFunc({inputs:{a:p,b:y},backend:e}),I=e.data.get(b.dataId).values,S=e.data.get(_.dataId).values;return e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(g),e.disposeIntermediateTensorInfo(y),e.disposeIntermediateTensorInfo(b),e.disposeIntermediateTensorInfo(_),{real:I,imag:S}}return u}{const d=function Yz(n,t,e){const r=new Float32Array(2*t);for(let s=0;s<t;s++){let o=0,l=0;for(let u=0;u<t;u++){const d=Gf(s*u,t,e),h=jg(n,u);o+=h.real*d.real-h.imag*d.imag,l+=h.real*d.imag+h.imag*d.real}e&&(o/=t,l/=t),Gg(r,o,l,s)}return r}(Qa(o,l),r,t);return lh(d)}}function ZE(n,t,e,r,s){if(1===e)return{real:n,imag:t};const o=Qa(n,t),l=e/2,u=ch(o),d=u.real,h=u.imag,p=[d.length],g=s.makeTensorInfo(p,"float32",d),y=s.makeTensorInfo(p,"float32",h),b=ci({inputs:{real:g,imag:y},backend:s}),_=d_(o),I=_.real,S=_.imag,T=[I.length],O=s.makeTensorInfo(T,"float32",I),V=s.makeTensorInfo(T,"float32",S),U=ci({inputs:{real:O,imag:V},backend:s}),j=ZE(d,h,l,r,s),te=j.real,se=j.imag,le=[te.length],Ce=s.makeTensorInfo(le,"float32",te),be=s.makeTensorInfo(le,"float32",se),Me=ci({inputs:{real:Ce,imag:be},backend:s}),He=ZE(I,S,l,r,s),We=He.real,je=He.imag,Ke=[We.length],Se=s.makeTensorInfo(Ke,"float32",We),ke=s.makeTensorInfo(Ke,"float32",je),De=ci({inputs:{real:Se,imag:ke},backend:s}),Be=Kg(e,r),rt=[Be.real.length],pt=s.makeTensorInfo(rt,"float32",Be.real),wt=s.makeTensorInfo(rt,"float32",Be.imag),gt=ci({inputs:{real:pt,imag:wt},backend:s}),yt=ex({inputs:{a:gt,b:De},backend:s}),It=xp({inputs:{a:Me,b:yt},backend:s}),zt=LE({inputs:{a:Me,b:yt},backend:s}),Vt=Ch({inputs:{input:It},backend:s}),tn=Ch({inputs:{input:zt},backend:s}),Yt=Dp({inputs:{input:It},backend:s}),vn=Dp({inputs:{input:zt},backend:s}),wn=Tp({inputs:[Vt,tn],backend:s,attrs:{axis:0}}),Jn=Tp({inputs:[Yt,vn],backend:s,attrs:{axis:0}}),gr=s.data.get(wn.dataId).values,Hr=s.data.get(Jn.dataId).values;return s.disposeIntermediateTensorInfo(g),s.disposeIntermediateTensorInfo(y),s.disposeIntermediateTensorInfo(b),s.disposeIntermediateTensorInfo(O),s.disposeIntermediateTensorInfo(V),s.disposeIntermediateTensorInfo(U),s.disposeIntermediateTensorInfo(Ce),s.disposeIntermediateTensorInfo(be),s.disposeIntermediateTensorInfo(Me),s.disposeIntermediateTensorInfo(Se),s.disposeIntermediateTensorInfo(ke),s.disposeIntermediateTensorInfo(De),s.disposeIntermediateTensorInfo(pt),s.disposeIntermediateTensorInfo(wt),s.disposeIntermediateTensorInfo(gt),s.disposeIntermediateTensorInfo(yt),s.disposeIntermediateTensorInfo(It),s.disposeIntermediateTensorInfo(zt),s.disposeIntermediateTensorInfo(Vt),s.disposeIntermediateTensorInfo(Yt),s.disposeIntermediateTensorInfo(tn),s.disposeIntermediateTensorInfo(vn),s.disposeIntermediateTensorInfo(wn),s.disposeIntermediateTensorInfo(Jn),{real:gr,imag:Hr}}const Qz={kernelName:"FFT",backendName:"cpu",kernelFunc:function Zz(n){const{inputs:t,backend:e}=n,{input:r}=t,s=Ee(r.shape),o=r.shape[r.shape.length-1],u=mr({inputs:{x:r},backend:e,attrs:{shape:[s/o,o]}}),d=zk(u,!1,e),h=mr({inputs:{x:d},backend:e,attrs:{shape:r.shape}});return e.disposeIntermediateTensorInfo(u),e.disposeIntermediateTensorInfo(d),h}};function QE(n){const{backend:t,attrs:e}=n,{shape:r,value:s,dtype:o}=e,l=o||Zt(s),u=Ft(l,Ee(r));return function eH(n,t,e){n.fill(t)}(u,s),t.makeTensorInfo(r,l,u)}const Jz={kernelName:Vr,backendName:"cpu",kernelFunc:QE},tH={kernelName:Do,backendName:"cpu",kernelFunc:({inputs:n,backend:e})=>{const{image:r}=n,s=e,o=Rt(r.dtype,Ee(r.shape)),[l,u,d,h]=r.shape,p=s.data.get(r.dataId).values;for(let y=0;y<l;y++){const b=y*d*u*h;for(let _=0;_<u;_++){const I=_*(d*h);for(let S=0;S<d;S++){const T=S*h;for(let O=0;O<h;O++){const V=Math.round(d-S-1),U=b+I+T+O;let j=p[U];V>=0&&V<d&&(j=p[b+I+V*h+O]),o[U]=j}}}}return{dataId:s.write(o,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},rH={kernelName:du,backendName:"cpu",kernelFunc:function nH(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,filter:o,bias:l,preluActivationWeights:u}=t,{strides:d,pad:h,dataFormat:p,dilations:g,dimRoundingMode:y,activation:b,leakyreluAlpha:_}=r;let I=Vk({inputs:{x:s,filter:o},backend:e,attrs:{strides:d,pad:h,dataFormat:p,dilations:g,dimRoundingMode:y}});if(l){const S=I;if("NCHW"===p&&1===l.shape.length&&1!==l.shape[0]){const T=mr({inputs:{x:l},backend:e,attrs:{shape:[l.shape[0],1,1]}});I=xp({inputs:{a:I,b:T},backend:e}),e.disposeIntermediateTensorInfo(T)}else I=xp({inputs:{a:I,b:l},backend:e});e.disposeIntermediateTensorInfo(S)}if(b){const S=I;if("NCHW"===p&&"prelu"===b&&1===u.shape.length&&1!==u.shape[0]){const T=mr({inputs:{x:u},backend:e,attrs:{shape:[u.shape[0],1,1]}});I=dx(e,I,b,T,_),e.disposeIntermediateTensorInfo(T)}else I=dx(e,I,b,u,_);e.disposeIntermediateTensorInfo(S)}return I}},oH={kernelName:Qs,backendName:"cpu",kernelFunc:function sH(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,filter:o,bias:l,preluActivationWeights:u}=t,{strides:d,pad:h,dataFormat:p,dilations:g,dimRoundingMode:y,activation:b,leakyreluAlpha:_}=r;let I=Uk({inputs:{x:s,filter:o},backend:e,attrs:{strides:d,pad:h,dataFormat:p,dilations:g,dimRoundingMode:y}});if(l){const S=I;I=xp({inputs:{a:I,b:l},backend:e}),e.disposeIntermediateTensorInfo(S)}if(b){const S=I;I=dx(e,I,b,u,_),e.disposeIntermediateTensorInfo(S)}return I}},aH={kernelName:ll,backendName:"cpu",kernelFunc:function iH(n){const{inputs:t,backend:e}=n,{params:r,indices:s}=t,o=Ee(r.shape),l=s.shape,u=l[l.length-1],[d,h,p,g]=Vc(r,s);if(0===h)return e.makeTensorInfo(d,r.dtype,[]);const _=GT(e.data.get(s.dataId).values,e.bufferSync(r),r.dtype,h,u,p,g,r.shape,o);return e.makeTensorInfo(d,r.dtype,_.values)}},cH={kernelName:To,backendName:"cpu",kernelFunc:function lH(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,indices:o}=t,{axis:l,batchDims:u}=r;Xt([s,o],"gatherV2");const d=Tt(l,s.shape)[0],h=e.data.get(o.dataId).values,p=s.shape[d];for(let U=0;U<h.length;++U){const j=h[U];G(j<=p-1&&j>=0,()=>`GatherV2: the index value ${j} is not in [0, ${p-1}]`)}let g=u;null==u&&(g=0);const y=Ee(o.shape),b=ks(s,o,d,g),_=mr({inputs:{x:s},backend:e,attrs:{shape:[b.batchSize,b.outerSize,b.dimSize,b.sliceSize]}}),I=mr({inputs:{x:o},backend:e,attrs:{shape:[b.batchSize,y/b.batchSize]}}),S=[b.batchSize,b.outerSize,y/b.batchSize,b.sliceSize],T=e.bufferSync(I),V=KT(e.bufferSync(_),T,S);return e.disposeIntermediateTensorInfo(_),e.disposeIntermediateTensorInfo(I),e.makeTensorInfo(b.outputShape,V.dtype,V.values)}},dH={kernelName:Ca,backendName:"cpu",kernelFunc:function uH(n){const{inputs:t,backend:e}=n,{input:r}=t,s=Ee(r.shape),o=r.shape[r.shape.length-1],u=mr({inputs:{x:r},backend:e,attrs:{shape:[s/o,o]}}),d=zk(u,!0,e),h=mr({inputs:{x:d},backend:e,attrs:{shape:r.shape}});return e.disposeIntermediateTensorInfo(u),e.disposeIntermediateTensorInfo(d),h}},hH=Qn(No,n=>Number.isFinite(n)?1:0,"bool"),fH={kernelName:No,backendName:"cpu",kernelFunc:hH},pH=Qn(Ui,n=>Math.abs(n)===1/0?1:0,"bool"),mH={kernelName:Ui,backendName:"cpu",kernelFunc:pH},gH=Qn(Sa,n=>Number.isNaN(n)?1:0,"bool"),yH={kernelName:Sa,backendName:"cpu",kernelFunc:gH},bH={kernelName:ul,backendName:"cpu",kernelFunc:function vH(n){const{backend:t,attrs:e}=n,{start:r,stop:s,num:o}=e,l=QT(r,s,o);return t.makeTensorInfo([l.length],"float32",l)}},_H=Qn(Wo,n=>Math.log1p(n)),xH={kernelName:Wo,backendName:"cpu",kernelFunc:_H},wH=Zr((n,t)=>n&&t),CH=Es(Ur,wH,null,"bool"),SH={kernelName:Ur,backendName:"cpu",kernelFunc:CH},EH=Qn(jo,n=>n?0:1,"bool"),IH={kernelName:jo,backendName:"cpu",kernelFunc:EH},DH=Zr((n,t)=>n||t),TH=Es(zi,DH,null,"bool"),NH={kernelName:zi,backendName:"cpu",kernelFunc:TH},AH={kernelName:"LRN",backendName:"cpu",kernelFunc:function kH(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{depthRadius:o,bias:l,alpha:u,beta:d}=r;Xt(s,"LRN");const h=s.shape[3],p=h-1,g=e.data.get(s.dataId).values,y=Ee(s.shape),b=new Float32Array(y);function _(I){const S=I%h;let T=I-S+Math.max(0,S-o);const O=I-S+Math.min(S+o,p);let V=0;for(;T<=O;T++){const U=g[T];V+=U*U}return V}for(let I=0;I<y;I++){const S=_(I),T=g[I]*Math.pow(l+u*S,-d);b[I]=T}return e.makeTensorInfo(s.shape,s.dtype,b)}},MH={kernelName:tu,backendName:"cpu",kernelFunc:function RH(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,y:o,dy:l}=t,{depthRadius:u,bias:d,alpha:h,beta:p}=r;Xt(l,"LRNGrad");const g=Ee(l.shape),y=l.shape[3],b=e.data.get(l.dataId).values,_=e.data.get(s.dataId).values,I=e.data.get(o.dataId).values,S=new Float32Array(g),T=g;for(let O=0;O<T;O++){const V=O%y,U=O-V+Math.max(0,V-u),j=O-V+Math.min(y,V+u+1);let te=0;for(let se=U;se<j;se++)te+=Math.pow(_[se],2);te=h*te+d;for(let se=U;se<j;se++){let le=-2*h*p*_[se]*I[O]/te;O===se&&(le+=Math.pow(te,-p)),le*=b[O],S[se]+=le}}return e.makeTensorInfo(l.shape,s.dtype,S)}};function Hk(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{reductionIndices:o,keepDims:l}=r,u=e;let d=s.shape;const h=d.length,p=Tt(o,d);let g=p;const y=pr(g,h);let b=u.data.get(s.dataId).values;if(null!=y){const U=new Array(h);for(let j=0;j<U.length;j++)U[j]=d[y[j]];b=$E(b,d,s.dtype,y,U),g=_r(g.length,h),d=U}Xt(s,"max"),_s("max",g,h);const[_,I]=as(d,g),T=eN(b,Ee(I),_,s.dtype),O=u.write(T,_,s.dtype);let V=_;return l&&(V=Yr(_,p)),{dataId:O,shape:V,dtype:s.dtype}}const OH={kernelName:"Max",backendName:"cpu",kernelFunc:Hk},$H={kernelName:hn,backendName:"cpu",kernelFunc:function FH(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t;Xt(s,"maxPool");const{filterSize:o,strides:l,pad:u,dimRoundingMode:d}=r;G(Ns(l,1),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${l} and dilations '1'`);const p=$o(s.shape,o,l,1,u,d);let g;if(1===p.filterWidth&&1===p.filterHeight&&un(p.inShape,p.outShape))g=ql({inputs:{x:s},backend:e});else{const y=e.data.get(s.dataId).values,b=Wt(s.shape),_=qE(y,0,s.dtype,b,p,"max");g=e.makeTensorInfo(p.outShape,s.dtype,_.values)}return g}},LH={kernelName:yd,backendName:"cpu",kernelFunc:function PH(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{filterSize:o,strides:l,pad:u,dimRoundingMode:d,dataFormat:h}=r;Xt(s,"maxPool3d");const p=Ka(s.shape,o,l,1,u,d,h),y=Bk(e.data.get(s.dataId).values,0,s.dtype,Wt(s.shape),p,"max");return e.makeTensorInfo(y.shape,"float32",y.values)}},VH={kernelName:hl,backendName:"cpu",kernelFunc:function BH(n){const{inputs:t,backend:e,attrs:r}=n,{dy:s,input:o}=t,{filterSize:l,strides:u,pad:d,dimRoundingMode:h}=r;Xt([s,o],"maxPool3DGrad");const p=Ka(o.shape,l,u,1,d,h),y=function T4(n,t){const e=gn(t.outShape,"int32"),r=t.strideDepth,s=t.strideHeight,o=t.strideWidth,l=t.dilationDepth,u=t.dilationHeight,d=t.dilationWidth,h=t.effectiveFilterDepth,p=t.effectiveFilterHeight,g=t.effectiveFilterWidth,y=t.padInfo.front,b=t.padInfo.top,_=t.padInfo.left;for(let I=0;I<t.batchSize;++I)for(let S=0;S<t.inChannels;++S)for(let T=0;T<t.outDepth;++T){const O=T*r-y;let V=O;for(;V<0;)V+=l;const U=Math.min(t.inDepth,h+O);for(let j=0;j<t.outHeight;++j){const te=j*s-b;let se=te;for(;se<0;)se+=u;const le=Math.min(t.inHeight,p+te);for(let Ce=0;Ce<t.outWidth;++Ce){const be=Ce*o-_;let Me=be;for(;Me<0;)Me+=d;const He=Math.min(t.inWidth,g+be);let We=Number.NEGATIVE_INFINITY,je=-1;for(let Ke=V;Ke<U;Ke+=l){const Se=Ke-O;for(let ke=se;ke<le;ke+=u){const De=ke-te;for(let Be=Me;Be<He;Be+=d){const rt=Be-be,pt=n.get(I,Ke,ke,Be,S);pt>=We&&(We=pt,je=Se*p*g+De*p+rt)}}}e.set(je,I,T,j,Ce,S)}}}return e}(e.bufferSync(o),p),b=p.strideDepth,_=p.strideHeight,I=p.strideWidth,S=p.dilationDepth,T=p.dilationHeight,O=p.dilationWidth,V=p.effectiveFilterDepth,U=p.effectiveFilterHeight,j=p.effectiveFilterWidth,te=V-1-p.padInfo.front,se=j-1-p.padInfo.left,le=U-1-p.padInfo.top,Ce=gn(o.shape,"float32"),be=e.bufferSync(s);for(let Me=0;Me<p.batchSize;++Me)for(let He=0;He<p.inChannels;++He)for(let We=0;We<p.inDepth;++We)for(let je=0;je<p.inHeight;++je)for(let Ke=0;Ke<p.inWidth;++Ke){const Se=We-te,ke=je-le,De=Ke-se;let Be=0;for(let rt=0;rt<V;rt+=S){const pt=(Se+rt)/b;if(!(pt<0||pt>=p.outDepth||Math.floor(pt)!==pt))for(let wt=0;wt<U;wt+=T){const gt=(ke+wt)/_;if(!(gt<0||gt>=p.outHeight||Math.floor(gt)!==gt))for(let yt=0;yt<j;yt+=O){const It=(De+yt)/I;if(It<0||It>=p.outWidth||Math.floor(It)!==It)continue;const tn=V*U*j-1-y.get(Me,pt,gt,It,He)===rt*U*j+wt*j+yt?1:0;0!==tn&&(Be+=be.get(Me,pt,gt,It,He)*tn)}}}Ce.set(Be,Me,We,je,Ke,He)}return e.makeTensorInfo(Ce.shape,Ce.dtype,Ce.values)}},zH={kernelName:nu,backendName:"cpu",kernelFunc:function UH(n){const{inputs:t,backend:e,attrs:r}=n,{dy:s,input:o,output:l}=t,u=o;Xt([o,l],"maxPoolGrad");const{filterSize:d,strides:h,pad:p,dimRoundingMode:g}=r,y=$o(u.shape,d,h,1,p,g),b=e.data.get(u.dataId).values,_=gn(y.outShape,u.dtype,Lk(b,u.shape,u.dtype,y).values),I=y.strideHeight,S=y.strideWidth,T=y.dilationHeight,O=y.dilationWidth,V=y.effectiveFilterHeight,U=y.effectiveFilterWidth,j=U-1-y.padInfo.left,te=V-1-y.padInfo.top,se=gn(u.shape,"float32"),le=e.data.get(s.dataId).values,Ce=gn(s.shape,"float32",le);for(let be=0;be<y.batchSize;++be)for(let Me=0;Me<y.inChannels;++Me)for(let He=0;He<y.inHeight;++He)for(let We=0;We<y.inWidth;++We){const je=He-te,Ke=We-j;let Se=0;for(let ke=0;ke<V;ke+=T){const De=(je+ke)/I;if(!(De<0||De>=y.outHeight||Math.floor(De)!==De))for(let Be=0;Be<U;Be+=O){const rt=(Ke+Be)/S;if(rt<0||rt>=y.outWidth||Math.floor(rt)!==rt)continue;const gt=V*U-1-_.get(be,De,rt,Me)===ke*U+Be?1:0;0!==gt&&(Se+=Ce.get(be,De,rt,Me)*gt)}}se.set(Se,be,He,We,Me)}return e.makeTensorInfo(se.shape,se.dtype,se.values)}},WH={kernelName:ac,backendName:"cpu",kernelFunc:({inputs:n,attrs:t,backend:e})=>{const{x:r}=n,{filterSize:s,strides:o,pad:l,includeBatchInIndex:u}=t,d=e;Xt(r,"MaxPoolWithArgmax");const h=d.data.get(r.dataId).values,p=$o(r.shape,s,o,[1,1],l),[g,y]=function HH(n,t,e,r,s){const l=qE(n,0,e,Wt(t),s,"max"),u=Lk(n,t,e,s,!0,r);return[l.values,u.values]}(h,r.shape,r.dtype,u,p),b=d.write(g,p.outShape,r.dtype),_=d.write(y,p.outShape,r.dtype);return[{dataId:b,shape:p.outShape,dtype:r.dtype},{dataId:_,shape:p.outShape,dtype:"int32"}]}},GH={kernelName:ru,backendName:"cpu",kernelFunc:function jH(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:o,keepDims:l}=r,u=Tt(o,s.shape),p=Ee(as(s.shape,u)[1]),g=[],y=e.makeTensorInfo([],"float32",new Float32Array([p]));g.push(y);const b=nd({inputs:{x:s},backend:e,attrs:{dtype:"float32"}});g.push(b);const _=XE({inputs:{a:b,b:y},backend:e});g.push(_);const I=By({inputs:{x:_},backend:e,attrs:{axis:o,keepDims:l}});return g.forEach(S=>e.disposeIntermediateTensorInfo(S)),I}},qH={kernelName:"Min",backendName:"cpu",kernelFunc:function KH(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:o,keepDims:l}=r;Xt(s,"min");const u=Tt(o,s.shape);let d=u;const h=pr(d,s.shape.length);let p=s;null!=h&&(p=Vo({inputs:{x:s},backend:e,attrs:{perm:h}}),d=_r(d.length,s.shape.length)),_s("min",d,p.shape.length);const[g,y]=as(p.shape,d),b=Ee(y),_=er(Ee(g),p.dtype),I=e.data.get(p.dataId).values;for(let T=0;T<_.length;++T){const O=T*b;let V=I[O];for(let U=0;U<b;++U){const j=I[O+U];(Number.isNaN(j)||j<V)&&(V=j)}_[T]=V}null!=h&&e.disposeIntermediateTensorInfo(p);const S=e.makeTensorInfo(g,p.dtype,_);if(l){const O=mr({inputs:{x:S},backend:e,attrs:{shape:Yr(g,u)}});return e.disposeIntermediateTensorInfo(S),O}return S}},YH={kernelName:ms,backendName:"cpu",kernelFunc:function XH(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{paddings:o,mode:l}=r;Xt(s,"mirrorPad");const u=o.map((V,U)=>V[0]+s.shape[U]+V[1]),d=o.map(V=>V[0]),h=o.map((V,U)=>V[0]+s.shape[U]),p="reflect"===l?0:1,g=e.data.get(s.dataId).values,y=s.shape.length,b=Wt(s.shape),_=Ee(u),I=u.length,S=Wt(u),T=Rt(s.dtype,_);for(let V=0;V<_;V++){let U=Jr(V,I,S);for(let te=0;te<I;te++)U[te]<d[te]?U[te]=2*d[te]-U[te]-p:U[te]>=h[te]&&(U[te]=2*(h[te]-1)-U[te]+p);U=U.map((te,se)=>te-d[se]);const j=Qr(U,y,b);T[V]=g[j]}return{dataId:e.write(T,u,s.dtype),shape:u,dtype:s.dtype}}},ZH=Zr((n,t)=>{const e=n%t;return n<0&&t<0||n>=0&&t>=0?e:(e+t)%t}),QH=Es(st,ZH),JH={kernelName:st,backendName:"cpu",kernelFunc:QH};function Wk(n){const{inputs:t,backend:e,attrs:r}=n,{logits:s}=t,{dim:o}=r,l=s.shape.length;let u=o;if(-1===u&&(u=l-1),u!==l-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${l} and dim was ${u}`);const d=Tt([u],s.shape),h=Hk({inputs:{x:s},backend:e,attrs:{reductionIndices:d,keepDims:!1}}),p=Yr(h.shape,d),g=mr({inputs:{x:h},backend:e,attrs:{shape:p}}),y=LE({inputs:{a:s,b:g},backend:e}),b=zT({inputs:{x:y},backend:e}),_=By({inputs:{x:b},backend:e,attrs:{axis:d,keepDims:!1}}),I=mr({inputs:{x:_},backend:e,attrs:{shape:p}}),S=XE({inputs:{a:b,b:I},backend:e});return e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(g),e.disposeIntermediateTensorInfo(y),e.disposeIntermediateTensorInfo(b),e.disposeIntermediateTensorInfo(_),e.disposeIntermediateTensorInfo(I),S}const eW={kernelName:qo,backendName:"cpu",kernelFunc:Wk},nW={kernelName:_n,backendName:"cpu",kernelFunc:function tW(n){const{inputs:t,backend:e,attrs:r}=n,{logits:s}=t,{numSamples:o,seed:l,normalized:u}=r;Xt(s,"multinomial");const d=u?s:Wk({inputs:{logits:s},backend:e,attrs:{dim:-1}}),h=d.shape[0],p=d.shape[1],g=e.data.get(d.dataId).values,y=[h,o],b=er(Ee(y),"int32");for(let _=0;_<h;++_){const I=_*p,S=new Float32Array(p-1);S[0]=g[I];for(let V=1;V<S.length;++V)S[V]=S[V-1]+g[I+V];const T=Uu.alea(l.toString()),O=_*o;for(let V=0;V<o;++V){const U=T();b[O+V]=S.length;for(let j=0;j<S.length;j++)if(U<S[j]){b[O+V]=j;break}}}return u||e.disposeIntermediateTensorInfo(d),e.makeTensorInfo(y,"int32",b)}},rW=_g,oW={kernelName:Wi,backendName:"cpu",kernelFunc:function sW(n){const{inputs:t,backend:e,attrs:r}=n,{boxes:s,scores:o}=t,{maxOutputSize:l,iouThreshold:u,scoreThreshold:d}=r;Xt(s,"NonMaxSuppression");const h=e.data.get(s.dataId).values,p=e.data.get(o.dataId).values,{selectedIndices:g}=rW(h,p,l,u,d);return e.makeTensorInfo([g.length],"int32",new Int32Array(g))}},iW=xg,lW={kernelName:ji,backendName:"cpu",kernelFunc:function aW(n){const{inputs:t,backend:e,attrs:r}=n,{boxes:s,scores:o}=t,{maxOutputSize:l,iouThreshold:u,scoreThreshold:d,padToMaxOutputSize:h}=r;Xt(s,"NonMaxSuppressionPadded");const p=e.data.get(s.dataId).values,g=e.data.get(o.dataId).values,{selectedIndices:y,validOutputs:b}=iW(p,g,l,u,d,h);return[e.makeTensorInfo([y.length],"int32",new Int32Array(y)),e.makeTensorInfo([],"int32",new Int32Array([b]))]}},cW=Bc,dW={kernelName:Xs,backendName:"cpu",kernelFunc:function uW(n){const{inputs:t,backend:e,attrs:r}=n,{boxes:s,scores:o}=t,{maxOutputSize:l,iouThreshold:u,scoreThreshold:d,softNmsSigma:h}=r;Xt(s,"NonMaxSuppressionWithScore");const p=e.data.get(s.dataId).values,g=e.data.get(o.dataId).values,y=l,b=u,_=d,I=h,{selectedIndices:S,selectedScores:T}=cW(p,g,y,b,_,I);return[e.makeTensorInfo([S.length],"int32",new Int32Array(S)),e.makeTensorInfo([T.length],"float32",new Float32Array(T))]}},fW={kernelName:Go,backendName:"cpu",kernelFunc:function hW(n){const{inputs:t,backend:e,attrs:r}=n,{indices:s}=t,{dtype:o,depth:l,onValue:u,offValue:d}=r;Xt(s,"oneHot");const h=Ee(s.shape),p=new Float32Array(h*l);p.fill(d);const g=e.data.get(s.dataId).values;for(let y=0;y<h;++y)g[y]>=0&&g[y]<l&&(p[y*l+g[y]]=u);return e.makeTensorInfo([...s.shape,l],o,p)}};function fx(n){const{inputs:t,backend:e}=n,{x:r}=t;if("string"===r.dtype)throw new Error("zerosLike is not supported for string tensors");if("complex64"===r.dtype){const s=Ch({inputs:{input:r},backend:e}),o=fx({inputs:{x:s},backend:e}),l=Dp({inputs:{input:r},backend:e}),u=fx({inputs:{x:l},backend:e}),d=ci({inputs:{real:o,imag:u},backend:e});return e.disposeIntermediateTensorInfo(s),e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(l),e.disposeIntermediateTensorInfo(u),d}return QE({backend:e,attrs:{shape:r.shape,value:0,dtype:r.dtype}})}const pW={kernelName:Yo,backendName:"cpu",kernelFunc:fx},mW={kernelName:Ao,backendName:"cpu",kernelFunc:function jk(n){const{inputs:t,backend:e}=n,{x:r}=t;if("string"===r.dtype)throw new Error("onesLike is not supported for string tensors");if("complex64"===r.dtype){const s=Ch({inputs:{input:r},backend:e}),o=jk({inputs:{x:s},backend:e}),l=Dp({inputs:{input:r},backend:e}),u=fx({inputs:{x:l},backend:e}),d=ci({inputs:{real:o,imag:u},backend:e});return e.disposeIntermediateTensorInfo(s),e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(l),e.disposeIntermediateTensorInfo(u),d}return QE({backend:e,attrs:{shape:r.shape,value:1,dtype:r.dtype}})}};function Gk(n){const{inputs:t,backend:e,attrs:r}=n,{axis:s}=r;if(1===t.length)return hx({inputs:{input:t[0]},backend:e,attrs:{dim:s}});const o=t[0].shape,l=t[0].dtype;t.forEach(p=>{bn(o,p.shape,"All tensors passed to stack must have matching shapes"),G(l===p.dtype,()=>"All tensors passed to stack must have matching dtypes")});const u=[],h=Tp({inputs:t.map(p=>{const g=hx({inputs:{input:p},backend:e,attrs:{dim:s}});return u.push(g),g}),backend:e,attrs:{axis:s}});return u.forEach(p=>e.disposeIntermediateTensorInfo(p)),h}const gW={kernelName:su,backendName:"cpu",kernelFunc:Gk},Kk={kernelName:ou,backendName:"cpu",kernelFunc:function yW(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{paddings:o,constantValue:l}=r;Xt(s,"pad");const u=o.map((O,V)=>O[0]+s.shape[V]+O[1]),d=o.map(O=>O[0]),h=e.data.get(s.dataId).values,p=Ee(s.shape),g=s.shape.length,y=Wt(s.shape),b=Ee(u),_=u.length,I=Wt(u),S=Rt(s.dtype,b);0!==l&&S.fill(l);for(let O=0;O<p;O++)S[Qr(Jr(O,g,y).map((te,se)=>te+d[se]),_,I)]=h[O];return{dataId:e.write(S,u,s.dtype),shape:u,dtype:s.dtype}}},vW=Zr((n,t)=>Math.pow(n,t)),bW=Es(Ko,vW),_W={kernelName:Ko,backendName:"cpu",kernelFunc:bW},wW={kernelName:ml,backendName:"cpu",kernelFunc:function xW(n){const{inputs:t,backend:e,attrs:r}=n,{paramsNestedSplits:s,paramsDenseValues:o,indices:l}=t,d=s.map(T=>e.data.get(T.dataId).values),h=s.map(T=>T.shape),p=e.data.get(o.dataId).values,g=e.data.get(l.dataId).values,[y,b,_]=aN(d,h,p,o.shape,o.dtype,g,l.shape),I=y.map(T=>e.makeTensorInfo([T.length],"int32",T)),S=e.makeTensorInfo(_,o.dtype,b);return I.concat([S])}},SW={kernelName:so,backendName:"cpu",kernelFunc:function CW(n){const{inputs:t,backend:e}=n,{starts:r,limits:s,deltas:o}=t,l=e.data.get(r.dataId).values,u=e.data.get(s.dataId).values,d=e.data.get(o.dataId).values,[h,p]=cN(l,r.shape,r.dtype,u,s.shape,d,o.shape);return[e.makeTensorInfo([h.length],"int32",h),e.makeTensorInfo([p.length],r.dtype,p)]}},IW={kernelName:rs,backendName:"cpu",kernelFunc:function EW(n){const{inputs:t,backend:e,attrs:r}=n,{shape:s,values:o,defaultValue:l,rowPartitionTensors:u}=t,{rowPartitionTypes:d}=r,h=e.data.get(s.dataId).values,p=e.data.get(o.dataId).values,g=e.data.get(l.dataId).values,y=u.map(S=>e.data.get(S.dataId).values),b=u.map(S=>S.shape),[_,I]=hN(h,s.shape,p,o.shape,o.dtype,g,l.shape,y,b,d);return e.makeTensorInfo(_,o.dtype,I)}},TW={kernelName:au,backendName:"cpu",kernelFunc:function DW(n){const{backend:t,attrs:e}=n,{start:r,stop:s,dtype:o,step:l}=e,u=fN(r,s,l,o);return t.makeTensorInfo([u.length],o,u)}},NW=Qn(Ta,n=>1/n),kW={kernelName:Ta,backendName:"cpu",kernelFunc:NW},RW={kernelName:Gi,backendName:"cpu",kernelFunc:function AW(n){const{inputs:t,backend:e,attrs:r}=n,{images:s}=t,{alignCorners:o,halfPixelCenters:l,size:u}=r;Xt(s,"resizeBilinear");const d=Wt(s.shape),[h,p]=u,[g,y,b,_]=s.shape,I=e.data.get(s.dataId).values,S=new Float32Array(Ee([g,h,p,_])),T=[o&&h>1?y-1:y,o&&p>1?b-1:b],O=[o&&h>1?h-1:h,o&&p>1?p-1:p];let V=0;const U=T[0]/O[0],j=T[1]/O[1];for(let te=0;te<g;te++)for(let se=0;se<h;se++){let le;le=l?U*(se+.5)-.5:U*se;const Ce=Math.max(0,Math.floor(le)),be=le-Ce,Me=Math.min(y-1,Math.ceil(le)),He=te*d[0]+Ce*d[1],We=te*d[0]+Me*d[1];for(let je=0;je<p;je++){let Ke;Ke=l?j*(je+.5)-.5:j*je;const Se=Math.max(0,Math.floor(Ke)),ke=Ke-Se,De=Math.min(b-1,Math.ceil(Ke)),Be=He+Se*d[2],rt=We+Se*d[2],pt=He+De*d[2],wt=We+De*d[2];for(let gt=0;gt<_;gt++){const yt=I[Be+gt],It=I[rt+gt],tn=yt+(I[pt+gt]-yt)*ke;S[V++]=tn+(It+(I[wt+gt]-It)*ke-tn)*be}}}return e.makeTensorInfo([g,h,p,_],"float32",S)}},OW={kernelName:vd,backendName:"cpu",kernelFunc:function MW(n){const{inputs:t,backend:e,attrs:r}=n,{images:s,dy:o}=t,{alignCorners:l}=r;Xt([o,s],"resizeBilinearGrad");const u=Wt(s.shape),[d,h,p,g]=s.shape,[,y,b]=o.shape,_=new Float32Array(d*h*p*g),I=[l&&y>1?h-1:h,l&&b>1?p-1:p],S=[l&&y>1?y-1:y,l&&b>1?b-1:b],T=I[0]/S[0],O=I[1]/S[1],V=e.data.get(o.dataId).values;let U=0;for(let j=0;j<d;j++){const te=j*u[0];for(let se=0;se<y;se++){const le=se*T,Ce=Math.floor(le),be=Math.min(Math.ceil(le),h-1),Me=te+Ce*u[1],He=te+be*u[1],We=le-Ce,je=1-We;for(let Ke=0;Ke<b;Ke++){const Se=Ke*O,ke=Math.floor(Se),De=Math.min(Math.ceil(Se),p-1),Be=Se-ke,rt=1-Be,pt=Me+ke*u[2],wt=Me+De*u[2],gt=He+ke*u[2],yt=He+De*u[2],It=je*rt,zt=je*Be,Vt=We*rt,tn=We*Be;for(let Yt=0;Yt<g;Yt++){const vn=V[U++];_[pt+Yt]+=vn*It,_[wt+Yt]+=vn*zt,_[gt+Yt]+=vn*Vt,_[yt+Yt]+=vn*tn}}}}return e.makeTensorInfo([d,p,h,g],"float32",_)}},$W={kernelName:Ro,backendName:"cpu",kernelFunc:function FW(n){const{inputs:t,backend:e,attrs:r}=n,{images:s}=t,{alignCorners:o,halfPixelCenters:l,size:u}=r;Xt(s,"resizeNearestNeighbor");const d=Wt(s.shape),[h,p]=u,[g,y,b,_]=s.shape,I=e.data.get(s.dataId).values,S=new Float32Array(g*h*p*_),T=[o&&h>1?y-1:y,o&&p>1?b-1:b],O=[o&&h>1?h-1:h,o&&p>1?p-1:p],V=T[0]/O[0],U=T[1]/O[1];let j=0;for(let te=0;te<g;te++){const se=te*d[0];for(let le=0;le<h;le++){const Ce=l?V*(le+.5):V*le;let be=Math.min(y-1,o?Math.round(Ce):Math.floor(Ce));l&&(be=Math.max(0,be));const Me=se+be*d[1];for(let He=0;He<p;He++){const We=l?U*(He+.5):U*He;let je=Math.min(b-1,o?Math.round(We):Math.floor(We));l&&(je=Math.max(0,je));const Ke=Me+je*d[2];for(let Se=0;Se<_;Se++)S[j++]=I[Ke+Se]}}}return e.makeTensorInfo([g,h,p,_],s.dtype,S)}},LW={kernelName:lc,backendName:"cpu",kernelFunc:function PW(n){const{inputs:t,backend:e,attrs:r}=n,{images:s,dy:o}=t,{alignCorners:l}=r;Xt([o,s],"resizeNearestNeighborGrad");const u=Wt(s.shape),d=Wt(o.shape),[h,p,g,y]=s.shape,[,b,_]=o.shape,I=new Float32Array(h*p*g*y),S=e.data.get(o.dataId).values,T=[l&&b>1?p-1:p,l&&_>1?g-1:g],O=[l&&b>1?b-1:b,l&&_>1?_-1:_],V=T[0]/O[0],U=T[1]/O[1],j=1/V,te=1/U,se=2*Math.ceil(j)+2,le=2*Math.ceil(te)+2;for(let Ce=0;Ce<h;Ce++){const be=Ce*u[0];for(let Me=0;Me<p;Me++){const He=be+Me*u[1],We=Math.floor(Me*j),je=Math.floor(We-se/2);for(let Ke=0;Ke<g;Ke++){const Se=He+Ke*u[2],ke=Math.floor(Ke*te),De=Math.floor(ke-le/2);for(let Be=0;Be<y;Be++){let rt=0;for(let pt=0;pt<se;pt++){const wt=pt+je;if(wt<0||wt>=b)continue;const gt=be+wt*d[1],yt=wt*V;if(Me===Math.min(p-1,l?Math.round(yt):Math.floor(yt)))for(let zt=0;zt<le;zt++){const Vt=zt+De;if(Vt<0||Vt>=_)continue;const tn=gt+Vt*d[2],Yt=Vt*U;Ke===Math.min(g-1,l?Math.round(Yt):Math.floor(Yt))&&(rt+=S[tn+Be])}}I[Se+Be]=rt}}}}return e.makeTensorInfo(s.shape,s.dtype,I)}},VW={kernelName:yl,backendName:"cpu",kernelFunc:function BW(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{dims:o}=r;Xt(s,"reverse");const l=s.shape.length,u=Tt(o,s.shape);if(0===l)return ql({inputs:{x:s},backend:e});const d=new zr(s.shape,s.dtype),h=e.bufferSync(s);for(let p=0;p<d.size;p++){const g=d.indexToLoc(p),y=g.slice();u.forEach(b=>y[b]=s.shape[b]-1-y[b]),d.set(h.get(...y),...g)}return e.makeTensorInfo(d.shape,d.dtype,d.values)}},UW={kernelName:uu,backendName:"cpu",kernelFunc:({inputs:n,attrs:t,backend:e})=>{const{image:r}=n,{radians:s,fillValue:o,center:l}=t,u=e,d=Rt(r.dtype,Ee(r.shape)),[h,p,g,y]=r.shape,[b,_]=u_(l,p,g),S=Math.sin(s),T=Math.cos(s),O=u.data.get(r.dataId).values;for(let U=0;U<h;U++){const j=U*g*p*y;for(let te=0;te<p;te++){const se=te*(g*y);for(let le=0;le<g;le++){const Ce=le*y;for(let be=0;be<y;be++){const Me=[h,te,le,be],He=Me[2],We=Me[1];let je=(He-b)*T-(We-_)*S,Ke=(He-b)*S+(We-_)*T;je=Math.round(je+b),Ke=Math.round(Ke+_);let Se=o;"number"!=typeof o&&(Se=3===be?255:o[be]),je>=0&&je<g&&Ke>=0&&Ke<p&&(Se=O[j+Ke*(g*y)+je*y+be]),d[j+se+Ce+be]=Se}}}}return{dataId:u.write(d,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},zW=Qn(vl,n=>{const t=Math.floor(n);return n-t<.5?Math.floor(n):n-t>.5?Math.ceil(n):t%2==0?t:t+1}),HW={kernelName:vl,backendName:"cpu",kernelFunc:zW},jW={kernelName:cc,backendName:"cpu",kernelFunc:function WW(n){const{inputs:t,backend:e,attrs:r}=n,{indices:s,updates:o}=t,{shape:l}=r,{sliceRank:u,numUpdates:d,sliceSize:h,strides:p,outputSize:g}=Pc(0,s,l),I=Sh(e.bufferSync(s),e.bufferSync(o),l,g,h,d,u,p,0,!0);return e.makeTensorInfo(l,I.dtype,I.values)}};function GW(n,t){let e=0,r=n.length,s=0;for(;e<r;)s=Math.floor((e+r)/2),n[s]<t?e=s+1:r=s;return r}function KW(n,t){let e=0,r=n.length,s=0;for(;e<r;)s=Math.floor((e+r)/2),n[s]<=t?e=s+1:r=s;return r}const YW={kernelName:Na,backendName:"cpu",kernelFunc:function XW(n){const{inputs:t,backend:e,attrs:r}=n,{sortedSequence:s,values:o}=t,{side:l}=r,h=function qW(n,t,e,r,s,o){const l=Ft("int32",e*s);for(let u=0;u<e;++u){const d=n.slice(u*r,(u+1)*r),h=u*s;for(let p=0;p<s;++p)l[h+p]="left"===o?GW(d,t[p+h]):KW(d,t[p+h])}return l}(e.data.get(s.dataId).values,e.data.get(o.dataId).values,s.shape[0],s.shape[1],o.shape[1],l);return e.makeTensorInfo(o.shape,"int32",h)}},QW={kernelName:cu,backendName:"cpu",kernelFunc:function ZW(n){const{inputs:t,backend:e}=n,{condition:r,t:s,e:o}=t;Xt([r,s,o],"select");const l=r.shape.length,u=e.data.get(r.dataId).values,d=e.data.get(s.dataId).values,h=e.data.get(o.dataId).values,p=ye(s.dtype,o.dtype),g=er(Ee(s.shape),p);let y=0;const b=0===l||l>1||1===s.shape.length?1:Ee(s.shape.slice(1));for(let _=0;_<u.length;_++)for(let I=0;I<b;I++)g[y++]=1===u[_]?d[_]:h[_];return e.makeTensorInfo(s.shape,p,g)}},JW=Ug,ej=ih,tj=Qn(ka,n=>n>=0?ej*n:JW*(Math.exp(n)-1)),nj={kernelName:ka,backendName:"cpu",kernelFunc:tj},rj=Qn(Aa,n=>n<0?-1:n>0?1:0),sj={kernelName:Aa,backendName:"cpu",kernelFunc:rj},oj=Qn($s,n=>Math.sin(n)),ij={kernelName:$s,backendName:"cpu",kernelFunc:oj},aj=Qn(Fn,n=>Math.sinh(n)),lj={kernelName:Fn,backendName:"cpu",kernelFunc:aj},qk=Math.log(1.1920928955078125e-7)+2,cj=Qn(_l,n=>{const t=n>-qk,e=n<qk,r=Math.exp(n);let s;return s=e?r:t?n:Math.log(1+r),s}),uj={kernelName:_l,backendName:"cpu",kernelFunc:cj},hj={kernelName:fc,backendName:"cpu",kernelFunc:function dj(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{blockShape:o,paddings:l}=r;Xt([s],"spaceToBatchND");const u=Ee(o),d=[[0,0]];d.push(...l);for(let te=1+o.length;te<s.shape.length;++te)d.push([0,0]);const h=Kk.kernelFunc({inputs:{x:s},backend:e,attrs:{paddings:d,constantValue:0}}),p=rh(h.shape,o,u,!1),g=sh(p.length,o.length,!1),y=oh(h.shape,o,u,!1),I=mr({inputs:{x:h},backend:e,attrs:{shape:p}}),O=Vo({inputs:{x:I},backend:e,attrs:{perm:g}}),j=mr({inputs:{x:O},backend:e,attrs:{shape:y}});return e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(I),e.disposeIntermediateTensorInfo(O),j}},pj={kernelName:Xo,backendName:"cpu",kernelFunc:function fj(n){const{inputs:t,backend:e}=n,{indices:r,values:s,denseShape:o,defaultValue:l}=t;if(1!==o.shape.length)throw new Error(`Dense shape must be a vector, saw:\n        ${o.shape}`);if(2!==r.shape.length)throw new Error(`Indices must be a matrix, saw:\n        ${r.shape}`);if(1!==s.shape.length)throw new Error(`Values must be a vector, saw:\n        ${s.shape}`);if(0!==l.shape.length)throw new Error(`Default value must be a scalar, saw:\n        ${l.shape}`);const u=e.data.get(r.dataId).values,d=e.data.get(s.dataId).values,h=e.data.get(o.dataId).values,p=e.data.get(l.dataId).values[0],[g,y,b,_,I]=yN(u,r.shape,r.dtype,d,s.dtype,h,p);return[e.makeTensorInfo(y,r.dtype,g),e.makeTensorInfo([y[0]],s.dtype,b),e.makeTensorInfo([_.length],"bool",new Uint8Array(_.map(S=>Number(S)))),e.makeTensorInfo([I.length],r.dtype,new Int32Array(I))]}},gj={kernelName:Ma,backendName:"cpu",kernelFunc:function mj(n){const{inputs:t,backend:e}=n,{inputIndices:r,inputShape:s,newShape:o}=t;if(2!==r.shape.length)throw new Error(`Input indices should be a matrix but received shape\n        ${r.shape}`);if(1!==s.shape.length)throw new Error(`Input shape should be a vector but received shape\n        ${s.shape}`);if(1!==o.shape.length)throw new Error(`Target shape should be a vector but received shape ${o.shape}`);const l=Array.from(e.data.get(s.dataId).values),u=e.data.get(r.dataId).values,d=Array.from(e.data.get(o.dataId).values),[h,p,g]=vN(u,r.shape,r.dtype,l,d);return[e.makeTensorInfo(p,r.dtype,h),e.makeTensorInfo([g.length],o.dtype,new Int32Array(g))]}},vj={kernelName:yi,backendName:"cpu",kernelFunc:function yj(n){const{inputs:t,backend:e}=n,{data:r,indices:s,segmentIds:o}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.shape.length)throw new Error(`Indices should be a vector but received shape\n          ${s.shape}`);if(1!==o.shape.length)throw new Error(`Segment ids should be a vector but received shape\n          ${o.shape}`);if(s.shape[0]!==o.shape[0])throw new Error("segmentIds and indices should have same size.");const l=e.data.get(r.dataId).values,u=e.data.get(s.dataId).values,d=e.data.get(o.dataId).values,[h,p]=PE(l,r.shape,r.dtype,u,d,!0);return e.makeTensorInfo(p,r.dtype,h)}},_j={kernelName:k,backendName:"cpu",kernelFunc:function bj(n){const{inputs:t,backend:e}=n,{data:r,indices:s,segmentIds:o}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.shape.length)throw new Error(`Indices should be a vector but received shape\n         ${s.shape}`);if(1!==o.shape.length)throw new Error(`Segment ids should be a vector but received shape\n         ${o.shape}`);if(s.shape[0]!==o.shape[0])throw new Error("segmentIds and indices should have same size.");const l=e.data.get(r.dataId).values,u=e.data.get(s.dataId).values,d=e.data.get(o.dataId).values,[h,p]=PE(l,r.shape,r.dtype,u,d);return e.makeTensorInfo(p,r.dtype,h)}},wj={kernelName:B,backendName:"cpu",kernelFunc:function xj(n){const{inputs:t,backend:e,attrs:r}=n,{sparseIndices:s,sparseValues:o,defaultValue:l}=t,{outputShape:u}=r,{sliceRank:d,numUpdates:h,sliceSize:p,strides:g,outputSize:y}=Pc(0,s,u),b=!1,_=e.bufferSync(s);let I;switch(o.dtype){case"bool":I=Sh(_,e.bufferSync(o),u,y,p,h,d,g,Boolean(e.data.get(l.dataId).values[0]),b);break;case"float32":case"int32":I=Sh(_,e.bufferSync(o),u,y,p,h,d,g,e.data.get(l.dataId).values[0],b);break;case"string":I=Sh(_,e.bufferSync(o),u,y,p,h,d,g,wi(e.data.get(l.dataId).values[0]),b);break;default:throw new Error(`Unsupported type ${o.dtype}`)}return e.makeTensorInfo(u,I.dtype,I.values)}},Sj={kernelName:Ki,backendName:"cpu",kernelFunc:function Cj(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{numOrSizeSplits:o,axis:l}=r,u=Tt(l,s.shape)[0],d=qg(s,o,u),h=new Array(s.shape.length).fill(0),p=s.shape.slice();return d.map(g=>{const y=[...p];y[u]=g;const b=Eh({inputs:{x:s},backend:e,attrs:{begin:h,size:y}});return h[u]+=g,b})}},Ej={kernelName:H,backendName:"cpu",kernelFunc:({inputs:n,backend:t})=>{const{x:e}=n,r=t;Xt(e,"square");const s=r.data.get(e.dataId).values,o=new Float32Array(s.length);for(let u=0;u<s.length;++u){const d=s[u];o[u]=d*d}return{dataId:r.write(o,e.shape,e.dtype),shape:e.shape,dtype:e.dtype}}},Ij=Qn(Zo,(n,t)=>{const e=t;return isNaN(n)?NaN:n>0?1:e.alpha}),Dj={kernelName:Zo,backendName:"cpu",kernelFunc:Ij},Nj={kernelName:Pe,backendName:"cpu",kernelFunc:function Tj(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{begin:o,end:l,strides:u,beginMask:d,endMask:h,ellipsisMask:p,newAxisMask:g,shrinkAxisMask:y}=r;Xt(s,"stridedSlice");const{finalShapeSparse:b,finalShape:_,isIdentity:I,sliceDim0:S,isSimpleSlice:T,begin:O,end:V,strides:U}=cf(s.shape,o,l,u,d,h,p,g,y);let j;if(I)j=mr({inputs:{x:s},backend:e,attrs:{shape:_}});else if(S||T){G(s.shape.length>=1,()=>`Input must have rank at least 1, got: ${s.shape.length}`);const te=Ld(O,V,U),se=Eh({inputs:{x:s},backend:e,attrs:{begin:O,size:te}});j=mr({inputs:{x:se},backend:e,attrs:{shape:_}}),e.disposeIntermediateTensorInfo(se)}else{const se=xN(b,e.bufferSync(s),U,O);j=e.makeTensorInfo(_,se.dtype,se.values)}return j}},Aj={kernelName:Ye,backendName:"cpu",kernelFunc:function kj(n){const{inputs:t,backend:e,attrs:r}=n,{separator:s,nGramWidths:o,leftPad:l,rightPad:u,padWidth:d,preserveShortSequences:h}=r,{data:p,dataSplits:g}=t,y=e.data.get(p.dataId).values,b=e.data.get(g.dataId).values,[_,I]=wN(y,b,s,o,l,u,d,h);return[e.makeTensorInfo([_.length],"string",_),e.makeTensorInfo(g.shape,"int32",I)]}},Mj={kernelName:Ht,backendName:"cpu",kernelFunc:function Rj(n){const{inputs:t,backend:e,attrs:r}=n,{skipEmpty:s}=r,{input:o,delimiter:l}=t;if("string"!==o.dtype)throw new Error("Input must be of datatype string");if(1!==o.shape.length)throw new Error(`Input must be a vector, got shape: ${o.shape}`);if(0!==l.shape.length)throw new Error(`Delimiter must be a scalar, got shape: ${l.shape}`);const u=e.data.get(o.dataId).values,d=e.data.get(l.dataId).values[0],[h,p,g]=CN(u,d,s),y=p.length;return[e.makeTensorInfo([y,2],"int32",h),e.makeTensorInfo([y],"string",p),e.makeTensorInfo([2],"int32",new Int32Array(g))]}},Fj={kernelName:Dn,backendName:"cpu",kernelFunc:function Oj(n){const{inputs:t,backend:e,attrs:r}=n,{numBuckets:s}=r,{input:o}=t;if("string"!==o.dtype)throw new Error("Input must be of datatype string");if(s<=0)throw new Error("Number of buckets must be at least 1");const u=SN(e.data.get(o.dataId).values,s);return e.makeTensorInfo(o.shape,"int32",u)}},$j=Qn(Rn,n=>Math.tan(n)),Pj={kernelName:Rn,backendName:"cpu",kernelFunc:$j},Lj=Qn(yn,n=>Math.tanh(n));function Xk(n,t,e){switch(e){case"reflect":return function qj(n,t){let e=n;if(e<0)if(t<=1)e=0;else{const r=2*t;e<r&&(e=r*Math.trunc(-e/r)+e),e=e<-t?e+r:-e-1}else if(e>t-1)if(t<=1)e=0;else{const r=2*t;e-=r*Math.trunc(e/r),e>=t&&(e=r-e-1)}return Ve(0,e,t-1)}(n,t);case"wrap":return function Xj(n,t){let e=n;return e<0?t<=1?e=0:e+=t*(Math.trunc(-e/(t-1))+1):e>t-1&&(t<=1?e=0:e-=t*Math.trunc(e/(t-1))),Ve(0,e,t-1)}(n,t);case"nearest":return function Zj(n,t){return Ve(0,n,t-1)}(n,t);default:return function Yj(n,t){return n}(n)}}function Vy(n,t,e,r,s,o,l,u,d,h,p){return 0<=u&&u<t&&0<=d&&d<e?n[l*r+u*s+d*o+h]:p}function Qj(n,t,e,r,s,o,l,u,d,h,p){return Vy(n,t,e,r,s,o,l,Math.round(u),Math.round(d),h,p)}function Jj(n,t,e,r,s,o,l,u,d,h,p){const g=Math.floor(u),y=Math.floor(d),b=g+1,_=y+1;return(b-u)*((_-d)*Vy(n,t,e,r,s,o,l,g,y,h,p)+(d-y)*Vy(n,t,e,r,s,o,l,g,_,h,p))+(u-g)*((_-d)*Vy(n,t,e,r,s,o,l,b,y,h,p)+(d-y)*Vy(n,t,e,r,s,o,l,b,_,h,p))}const iG=[t4,D2,r4,o4,M2,l4,u4,h4,p4,g4,v4,_4,w4,E4,D4,k4,R4,O4,$4,JU,L4,V4,z4,F2,W4,A2,P2,G4,T2,K4,X4,Y4,Q4,ez,nz,sz,iz,lz,uz,hz,pz,gz,vz,_z,xz,Cz,Ez,Dz,Tz,Nz,kz,Rz,Fz,GU,Pz,L2,jz,B2,Gz,U2,Qz,Jz,tH,H2,j2,rH,oH,aH,cH,K2,X2,N2,dH,q4,fH,mH,yH,KU,Z2,J2,bH,tM,xH,SH,IH,NH,AH,MH,OH,rM,$H,LH,VH,zH,WH,GH,qH,oM,YH,JH,nW,aM,cM,oW,lW,dW,dM,fW,mW,gW,Kk,_W,XU,pM,wW,SW,IW,TW,k2,YE,kW,YU,ZU,QU,RW,OW,$W,LW,VW,UW,HW,wM,jW,YW,QW,nj,SM,sj,ij,lj,EM,eW,uj,hj,pj,gj,vj,_j,wj,Sj,TM,Ej,kM,RM,Dj,Nj,Aj,Mj,Fj,$M,Mz,Pj,{kernelName:yn,backendName:"cpu",kernelFunc:Lj},{kernelName:uc,backendName:"cpu",kernelFunc:function Vj(n){const{inputs:t,backend:e}=n,{tensor:r,indices:s,updates:o}=t,{sliceRank:l,numUpdates:u,sliceSize:d,strides:h,outputSize:p}=Pc(0,s,r.shape),y=e.bufferSync(s),b=e.bufferSync(o),_=e.bufferSync(r),I=Sh(y,b,r.shape,p,d,u,l,h,_,!1);return e.makeTensorInfo(r.shape,I.dtype,I.values)}},{kernelName:sr,backendName:"cpu",kernelFunc:function zj(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{reps:o}=r;Xt(s,"tile");const l=IN(e.bufferSync(s),o);return e.makeTensorInfo(l.shape,l.dtype,l.values)}},{kernelName:$n,backendName:"cpu",kernelFunc:function Wj(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{k:o,sorted:l}=r;Xt(s,"topk");const u=e.data.get(s.dataId).values,[d,h]=TN(u,s.shape,s.dtype,o,l);return[e.makeTensorInfo(d.shape,d.dtype,d.values),e.makeTensorInfo(h.shape,h.dtype,h.values)]}},{kernelName:or,backendName:"cpu",kernelFunc:function Gj(n){const{inputs:t,attrs:e,backend:r}=n,{image:s,transforms:o}=t,{interpolation:l,fillMode:u,fillValue:d,outputShape:h}=e,[p,g,y,b]=s.shape,[_,I]=null!=h?h:[g,y],S=[p,_,I,b],T=Wt(s.shape),O=T[0],V=T[1],U=T[2],j=Wt(S),te=j[0],se=j[1],le=j[2],Ce=Rt(s.dtype,Ee(S));Ce.fill(d);const be=r.data.get(s.dataId).values,Me=r.data.get(o.dataId).values;for(let We=0;We<p;++We){const je=1===o.shape[0]?Me:Me.subarray(8*We,8*We+8);for(let Ke=0;Ke<_;++Ke)for(let Se=0;Se<I;++Se)for(let ke=0;ke<b;++ke){let De;const Be=je[6]*Se+je[7]*Ke+1;if(0===Be)continue;const pt=(je[3]*Se+je[4]*Ke+je[5])/Be,wt=Xk((je[0]*Se+je[1]*Ke+je[2])/Be,y,u),gt=Xk(pt,g,u);switch(l){case"nearest":De=Qj(be,g,y,O,V,U,We,gt,wt,ke,d);break;case"bilinear":De=Jj(be,g,y,O,V,U,We,gt,wt,ke,d);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${l}`)}Ce[We*te+Ke*se+Se*le+ke]=De}return r.makeTensorInfo(S,s.dtype,Ce)}return{dataId:r.write(Ce,S,s.dtype),shape:s.shape,dtype:s.dtype}}},hM,{kernelName:gs,backendName:"cpu",kernelFunc:function eG(n){const{inputs:t,attrs:e,backend:r}=n,{axis:s}=e,{x:o}=t;Xt(o,"unique");const l=r.data.get(o.dataId).values,{outputValues:u,outputShape:d,indices:h}=NN(l,s,o.shape,o.dtype);return[r.makeTensorInfo(d,o.dtype,u),r.makeTensorInfo([h.length],"int32",h)]}},{kernelName:ss,backendName:"cpu",kernelFunc:function nG(n){const{inputs:t,backend:e,attrs:r}=n,{value:s}=t;let{axis:o}=r;o<0&&(o+=s.shape.length);const l=s.shape.length,u=s.shape[o],d=new Array(l-1);let h=0;for(let b=0;b<l;b++)b!==o&&(d[h++]=s.shape[b]);const p=new Array(l).fill(0),g=s.shape.slice();g[o]=1;const y=new Array(u);for(let b=0;b<y.length;b++){p[o]=b;const _=Eh({inputs:{x:s},backend:e,attrs:{begin:p,size:g}});y[b]=mr({inputs:{x:_},backend:e,attrs:{shape:d}}),e.disposeIntermediateTensorInfo(_)}return y}},{kernelName:Zs,backendName:"cpu",kernelFunc:function sG(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,segmentIds:o}=t,{numSegments:l}=r;Xt(s,"unsortedSegmentSum");const h=[],p=[],g=s.shape.length-o.shape.length;let y=o;for(let _=0;_<g;++_){const I=hx({inputs:{input:y},backend:e,attrs:{dim:_+1}});y=I,p.push(I)}for(let _=0;_<l;++_){const I=_i(_,"int32"),S=e.makeTensorInfo([],"int32",I),T=VT({inputs:{a:S,b:y},backend:e}),O=nd({inputs:{x:T},backend:e,attrs:{dtype:"float32"}}),V=ex({inputs:{a:O,b:s},backend:e}),U=By({inputs:{x:V},backend:e,attrs:{axis:0,keepDims:!1}});h.push(U),p.push(S),p.push(T),p.push(O),p.push(V),p.push(U)}const b=Gk({inputs:h,backend:e,attrs:{axis:0}});return p.forEach(_=>e.disposeIntermediateTensorInfo(_)),b}},pW];for(const n of iG)hu(n);var Kt=Y(6899);const Np=new Kt.GestureDescription("IGUALMENTE");Np.addCurl(Kt.Finger.Index,Kt.FingerCurl.NoCurl,1),Np.addCurl(Kt.Finger.Pinky,Kt.FingerCurl.NoCurl,1),Np.addCurl(Kt.Finger.Thumb,Kt.FingerCurl.NoCurl,1),Np.addCurl(Kt.Finger.Middle,Kt.FingerCurl.FullCurl,1),Np.addCurl(Kt.Finger.Ring,Kt.FingerCurl.FullCurl,1);const kp=new Kt.GestureDescription("AMOR");kp.addCurl(Kt.Finger.Index,Kt.FingerCurl.NoCurl,1),kp.addCurl(Kt.Finger.Thumb,Kt.FingerCurl.FullCurl,1),kp.addCurl(Kt.Finger.Middle,Kt.FingerCurl.FullCurl,1),kp.addCurl(Kt.Finger.Ring,Kt.FingerCurl.FullCurl,1),kp.addCurl(Kt.Finger.Pinky,Kt.FingerCurl.NoCurl,1);const Ap=new Kt.GestureDescription("HOLA");Ap.addCurl(Kt.Finger.Index,Kt.FingerCurl.NoCurl,1),Ap.addCurl(Kt.Finger.Middle,Kt.FingerCurl.NoCurl,1),Ap.addCurl(Kt.Finger.Ring,Kt.FingerCurl.NoCurl,1),Ap.addCurl(Kt.Finger.Pinky,Kt.FingerCurl.NoCurl,1),Ap.addCurl(Kt.Finger.Thumb,Kt.FingerCurl.NoCurl,1);const Rp=new Kt.GestureDescription("NOMBRE");Rp.addCurl(Kt.Finger.Index,Kt.FingerCurl.NoCurl,1),Rp.addCurl(Kt.Finger.Middle,Kt.FingerCurl.NoCurl,1),Rp.addCurl(Kt.Finger.Thumb,Kt.FingerCurl.FullCurl,1),Rp.addCurl(Kt.Finger.Ring,Kt.FingerCurl.FullCurl,1),Rp.addCurl(Kt.Finger.Pinky,Kt.FingerCurl.FullCurl,1);const Mp=new Kt.GestureDescription("ES");Mp.addCurl(Kt.Finger.Index,Kt.FingerCurl.NoCurl,1),Mp.addCurl(Kt.Finger.Thumb,Kt.FingerCurl.FullCurl,1),Mp.addCurl(Kt.Finger.Middle,Kt.FingerCurl.FullCurl,1),Mp.addCurl(Kt.Finger.Ring,Kt.FingerCurl.FullCurl,1),Mp.addCurl(Kt.Finger.Pinky,Kt.FingerCurl.FullCurl,1);const Op=new Kt.GestureDescription("Victoria");Op.addCurl(Kt.Finger.Index,Kt.FingerCurl.FullCurl,1),Op.addCurl(Kt.Finger.Thumb,Kt.FingerCurl.FullCurl,1),Op.addCurl(Kt.Finger.Middle,Kt.FingerCurl.FullCurl,1),Op.addCurl(Kt.Finger.Ring,Kt.FingerCurl.FullCurl,1),Op.addCurl(Kt.Finger.Pinky,Kt.FingerCurl.FullCurl,1);const aG=new Kt.GestureEstimator([Np,kp,Ap,Rp,Mp,Op]);let lG=(()=>{class n{constructor(){this._lastGestureTimestamp=-1,this._lastGesture="none",this._emitGesture=!0}get stream(){return this._stream}get lastGesture(){return this._lastGesture}initialize(e,r){this._dimensions=[r.width,r.height],navigator.mediaDevices.getUserMedia({video:!0}).then(s=>(this._stream=s,function Sy(n){var t=void 0===n?{}:n,e=t.maxContinuousChecks,r=void 0===e?1/0:e,s=t.detectionConfidence,o=void 0===s?.8:s,l=t.iouThreshold,u=void 0===l?.3:l,d=t.scoreThreshold,h=void 0===d?.5:d;return tl(this,void 0,void 0,function(){var p,b,_,I;return Gl(this,function(S){switch(S.label){case 0:return[4,Promise.all([G_(),j_(),Hc()])];case 1:return p=S.sent(),b=p[2],_=new z_(p[1],256,256,p[0],u,h),I=new bE(_,b,256,256,r,o),[2,new Ey(I)]}})})}())).then(s=>{const o=e.getContext("2d");if(!o)return;o.clearRect(0,0,r.width,r.height),o.strokeStyle="red",o.fillStyle="red",o.translate(e.width,0),o.scale(-1,1);const l=()=>{s.estimateHands(r).then(u=>{o.drawImage(r,0,0,r.width,r.height,0,0,e.width,e.height),u&&u[0]&&this._processGesture(u[0].landmarks),requestAnimationFrame(l)})};l()}).catch(s=>{console.error(s)})}_processGesture(e){const r=aG.estimate(e,7.5),s=r?r.gestures:[];let o=null;for(const l of s)o=l.name;this._lastGesture!==o?(this._lastGesture=o,this._lastGestureTimestamp=Date.now(),this._emitGesture=!0):this._emitGesture&&this._toSeconds(Date.now()-this._lastGestureTimestamp)>1&&(this._emitGesture=!1)}_toSeconds(e){return e/1e3}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=K.Yz7({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();var kh=Y(9808);const cG=new K.OlP("cdk-dir-doc",{providedIn:"root",factory:function uG(){return(0,K.f3M)(kh.K0)}});let dG=(()=>{class n{constructor(e){if(this.value="ltr",this.change=new K.vpe,e){const s=e.documentElement?e.documentElement.dir:null,o=(e.body?e.body.dir:null)||s;this.value="ltr"===o||"rtl"===o?o:"ltr"}}ngOnDestroy(){this.change.complete()}}return n.\u0275fac=function(e){return new(e||n)(K.LFG(cG,8))},n.\u0275prov=K.Yz7({token:n,factory:n.\u0275fac,providedIn:"root"}),n})(),hG=(()=>{class n{constructor(){this._dir="ltr",this._isInitialized=!1,this.change=new K.vpe}get dir(){return this._dir}set dir(e){const r=this._dir,s=e&&e.toLowerCase();this._rawDir=e,this._dir="ltr"===s||"rtl"===s?s:"ltr",r!==this._dir&&this._isInitialized&&this.change.emit(this._dir)}get value(){return this.dir}ngAfterContentInit(){this._isInitialized=!0}ngOnDestroy(){this.change.complete()}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275dir=K.lG2({type:n,selectors:[["","dir",""]],hostVars:1,hostBindings:function(e,r){2&e&&K.uIk("dir",r._rawDir)},inputs:{dir:"dir"},outputs:{change:"dirChange"},exportAs:["dir"],features:[K._Bn([{provide:dG,useExisting:n}])]}),n})(),Yk=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=K.oAB({type:n}),n.\u0275inj=K.cJS({}),n})();const fG=["video"],pG=["canvas"];let mG=(()=>{class n{constructor(e,r){this._recognizer=e,this._router=r,setInterval(()=>{const s=this._recognizer.lastGesture;s!==this.gesto&&(this.gesto=s,this.gesto&&"none"!==this.gesto&&this.speakText(this.gesto))},1e3)}get stream(){return this._recognizer.stream}ngAfterViewInit(){this._recognizer.initialize(this.canvas.nativeElement,this.video.nativeElement)}speakText(e){if("speechSynthesis"in window){const r=new SpeechSynthesisUtterance(e),s=()=>{const l=window.speechSynthesis.getVoices().find(u=>u.lang.startsWith("es"));l?r.voice=l:console.warn("No se encontr\xf3 una voz en espa\xf1ol. Usando la voz por defecto."),window.speechSynthesis.speak(r)};window.speechSynthesis.getVoices().length>0?s():window.speechSynthesis.onvoiceschanged=()=>{s()}}else console.error("El navegador no soporta la s\xedntesis de voz.")}}return n.\u0275fac=function(e){return new(e||n)(K.Y36(lG),K.Y36(_t.F0))},n.\u0275cmp=K.Xpm({type:n,selectors:[["app-root"]],viewQuery:function(e,r){if(1&e&&(K.Gf(fG,5),K.Gf(pG,5)),2&e){let s;K.iGM(s=K.CRH())&&(r.video=s.first),K.iGM(s=K.CRH())&&(r.canvas=s.first)}},decls:218,vars:2,consts:[[1,"app"],[1,""],[1,"web-preview-header","web-preview-header--responsive"],[1,"app-name",2,"padding-top","15px"],[1,"device-type-selector","align-center"],[1,"web-renderer-wrapper--responsive","framed"],[1,"responsive-preview-frame-wrapper"],[1,"responsive-preview-frame-inner-wrapper",2,"width","434px","height","841px","transform","scale(0.970488)"],[1,"device-frame"],["id","Layer_1","xmlns","http://www.w3.org/2000/svg",0,"xmlns","xlink","http://www.w3.org/1999/xlink","x","0px","y","0px","viewBox","0 0 440 860",0,"xml","space","preserve"],["type","text/css"],["d","M433.6,157.4v97.4c0,0.6-0.7,1.2-1.5,1.2h-2.8v-99.8h2.8C432.9,156.2,433.6,156.8,433.6,157.4z",1,"st0"],["d","M429.3,256v527.1c0,37.7-30.7,68.4-68.4,68.4H80.1c-37.7,0-68.4-30.7-68.4-68.4V300v-61.5v-20.9v-61.5v-31.5 V94.2V75.4C11.7,37.7,42.4,7,80.1,7h280.7c37.7,0,68.4,30.7,68.4,68.4v80.8V256z M423,783.1V75.4c0-34.3-27.9-62.2-62.2-62.2H80.1 C45.8,13.2,18,41.1,18,75.4v707.6c0,34.3,27.8,62.2,62.2,62.2h280.7C395.2,845.2,423,817.4,423,783.1z",1,"st1"],["d","M423,75.4v707.6c0,34.3-27.8,62.2-62.2,62.2H80.1c-34.3,0-62.2-27.8-62.2-62.2V75.4c0-34.3,27.8-62.2,62.2-62.2 h280.7C395.2,13.2,423,41.1,423,75.4z M415.5,781.5V76.3c0-30.6-24.8-55.3-55.3-55.3H80.8c-30.5,0-55.3,24.8-55.3,55.3v705.2 c0,30.6,24.8,55.3,55.3,55.3h279.4C390.7,836.8,415.5,812,415.5,781.5z",1,"st2"],["d","M11.7,238.6V300H8.9c-0.8,0-1.5-0.5-1.5-1.2v-59.1c0-0.7,0.7-1.2,1.5-1.2H11.7z",1,"st0"],["d","M11.7,156.2v61.5H8.9c-0.8,0-1.5-0.5-1.5-1.2v-59.1c0-0.6,0.7-1.2,1.5-1.2H11.7z",1,"st0"],["d","M11.7,94.2v30.5H8.9c-0.8,0-1.5-0.5-1.5-1.2V95.3c0-0.7,0.7-1.2,1.5-1.2H11.7z",1,"st0"],["x1","11.7","y1","156.2","x2","11.7","y2","124.7",1,"st3"],["x1","11.7","y1","238.6","x2","11.7","y2","217.7",1,"st3"],["d","M429.3,256v527.1c0,37.7-30.7,68.4-68.4,68.4H80.1c-37.7,0-68.4-30.7-68.4-68.4V300",1,"st3"],["id","responsive-preview-frame",1,"responsive-preview-frame","responsive-preview-frame--mobile"],[1,"css-175oi2r",2,"flex","1 1 0%","background-color","rgb(238, 238, 238)"],[1,"css-175oi2r","r-123tt9","r-13awgt0"],[1,"css-175oi2r","r-1pi2tsx","r-1d2f490","r-u8s1d","r-ipm5af","r-13qz1uu",2,"transform","translateX(0px)"],[1,"css-175oi2r","r-1udh08x","r-13awgt0",2,"background-color","rgb(255, 255, 255)"],[1,"css-175oi2r","r-13awgt0"],[1,"css-175oi2r","r-150rngu","r-eqz5dr","r-16y2uox","r-1wbh5a2","r-11yh6sk","r-1rnoaur","r-agouwx","r-13awgt0","r-2eszeu"],[1,"css-175oi2r"],[1,"css-175oi2r",2,"padding-top","20px","padding-bottom","60px"],[1,"css-175oi2r",2,"height","685px","min-height","100%"],[1,"css-175oi2r","r-12vffkv",2,"position","absolute","transform","translateX(0px) translateY(0px)","width","100%"],[1,"css-175oi2r","r-12vffkv",2,"width","100%","margin-top","0px","margin-left","0px","left","0px","right","0px","height","685px"],[1,"css-175oi2r","r-12vffkv",2,"position","absolute","top","38px","transform","translateX(-15px) translateY(0px)","left","91.2821%","width","30px","height","auto","z-index","2"],[1,"css-175oi2r","r-12vffkv",2,"position","absolute","top","36px","transform","translateX(0px) translateY(0px)","left","35%","width","18.9744%","height","auto","z-index","3"],[1,"css-175oi2r","r-12vffkv",2,"position","relative"],[1,"css-175oi2r","r-105ug2t",2,"top","0px","left","0px","width","100%","height","auto","z-index","3","position","relative","margin-top","0px","margin-left","0px","right","0px","opacity","1"],[2,"display","flex","flex","1 1 0%","position","relative"],["dir","auto",1,"css-146c3p1",2,"color","rgb(113, 99, 203)","font-size","27px","font-weight","500","text-align","left","font-family","inherit","min-height","32px","flex","1 1 0%","width","100%"],[1,"css-175oi2r","r-12vffkv",2,"border-radius","10px"],["autoplay","",2,"margin-top","150px","border-radius","10px","margin-left","20px","margin-right","20px","width","90%","height","100%","transform","scaleX(-1)",3,"srcObject"],["video",""],["canvas",""],[2,"margin-top","-100px","z-index","1","text-align","center"],[1,"css-175oi2r","r-1p0dtai","r-1d2f490","r-u8s1d","r-zchlnj","r-ipm5af","r-184en5c","r-12vffkv",2,"padding-top","20px","padding-bottom","40px"],[1,"css-175oi2r","r-13awgt0","r-1mdbw0j","r-12vffkv"],[1,"css-175oi2r","r-1pi2tsx","r-1d2f490","r-u8s1d","r-ipm5af","r-13qz1uu","r-13w96dm",2,"opacity","1"],[1,"css-175oi2r","r-12vffkv",2,"position","absolute","top","32px","transform","translateX(-17px) translateY(0px)","left","10.2564%","width","34px","height","auto","z-index","1"],[1,"css-175oi2r","r-12vffkv",2,"height","auto","top","0px","left","0px","width","100%","z-index","1","position","relative","margin-left","0px","margin-top","0px","right","0px"],[1,"css-175oi2r",2,"height","34px","width","34px","display","flex","align-items","center","justify-content","center"],["tabindex","0",1,"css-175oi2r","r-1loqt21","r-1otgn73"],[1,"css-175oi2r",2,"position","absolute","top","3.4px","left","3.4px","width","61.2px","height","61.2px","border-radius","30.6px","background-color","rgb(113, 99, 203)","transform","scale(0.01)","opacity","0.3"],[1,"css-175oi2r","r-1awozwy","r-1777fci",2,"width","68px","height","68px"],["dir","auto",1,"css-146c3p1","r-lrvibr",2,"font-size","34px","color","rgb(113, 99, 203)","font-family","MaterialIcons","font-weight","normal","font-style","normal"],[1,"css-175oi2r","r-12vffkv",2,"height","auto","top","0px","left","0px","width","100%","z-index","2","position","relative","margin-left","0px","margin-top","0px","right","0px"],[1,"css-175oi2r",2,"height","30px","width","30px","display","flex","align-items","center","justify-content","center"],[1,"css-175oi2r",2,"position","absolute","top","3px","left","3px","width","54px","height","54px","border-radius","27px","background-color","rgb(113, 99, 203)","transform","scale(0.01)","opacity","0.3"],[1,"css-175oi2r","r-1awozwy","r-1777fci",2,"width","60px","height","60px"],["dir","auto",1,"css-146c3p1","r-lrvibr",2,"font-size","30px","color","rgb(113, 99, 203)","font-family","MaterialIcons","font-weight","normal","font-style","normal"],[1,"css-175oi2r","r-12vffkv",2,"position","absolute","top","36px","transform","translateX(0px) translateY(0px)","left","40.5128%","width","18.9744%","height","auto","z-index","3"],[1,"css-175oi2r","r-12vffkv",2,"position","absolute","top","169px","transform","translateX(0px) translateY(0px)","left","4.10256%","width","43.5897%","height","244px","z-index","4"],["tabindex","0",1,"css-175oi2r","r-lrvibr","r-1loqt21","r-1otgn73",2,"top","0px","left","0px","width","100%","height","246px","z-index","4","position","absolute","margin-top","0px","margin-left","0px","right","0px","opacity","1"],[1,"css-175oi2r",2,"flex-direction","column"],[1,"css-175oi2r",2,"flex-direction","column","opacity","1"],[1,"css-175oi2r","r-u8s1d",2,"box-shadow","rgb(113, 99, 203) 0px 1px 4px","border-radius","19px","border-width","0px","background-color","rgb(255, 255, 255)","inset","0px"],[1,"css-175oi2r","r-1p0dtai","r-1d2f490","r-1udh08x","r-u8s1d","r-zchlnj","r-ipm5af",2,"border-radius","19px"],[1,"css-175oi2r",2,"flex","1 1 0%","margin","0px"],[1,"css-175oi2r",2,"height","244px"],[1,"css-175oi2r","r-12vffkv",2,"position","absolute","top","43px","transform","translateX(0px) translateY(0px)","left","7.94118%","width","84.1176%","height","147px","z-index","5"],[1,"css-175oi2r","r-105ug2t",2,"top","0px","left","0px","width","100%","height","147px","z-index","5","position","absolute","margin-top","0px","margin-left","0px","right","0px","opacity","1"],[1,"css-175oi2r","r-u8s1d",2,"border-radius","0px","border-width","0px","background-color","rgba(0, 0, 0, 0)","inset","0px"],[1,"css-175oi2r","r-1p0dtai","r-1d2f490","r-1udh08x","r-u8s1d","r-zchlnj","r-ipm5af",2,"border-radius","0px"],[1,"css-175oi2r","r-1pi2tsx","r-u8s1d","r-13qz1uu","r-184en5c",2,"opacity","0"],[1,"css-175oi2r","r-1mlwlqe","r-1udh08x","r-417010",2,"width","143px","height","147px"],[1,"css-175oi2r","r-1niwhzg","r-vvn4in","r-u6sd8q","r-1p0dtai","r-1pi2tsx","r-1d2f490","r-u8s1d","r-zchlnj","r-ipm5af","r-13qz1uu","r-1wyyakw","r-ehq7j7",2,"background-image",'url("blob:https://previewer.adalo.com/d87d384e-605e-4da3-a6dd-cb9b70baba8e")'],["alt","","draggable","false","src","blob:https://previewer.adalo.com/d87d384e-605e-4da3-a6dd-cb9b70baba8e",1,"css-9pa8cd"],[1,"css-175oi2r","r-1mlwlqe","r-1udh08x","r-13awgt0","r-417010"],[1,"css-175oi2r","r-1niwhzg","r-vvn4in","r-u6sd8q","r-1p0dtai","r-1pi2tsx","r-1d2f490","r-u8s1d","r-zchlnj","r-ipm5af","r-13qz1uu","r-1wyyakw","r-ehq7j7",2,"background-image",'url("https://proton-resources-production.imgix.net/2c16d5d79019eaa91f9ad78a536d2e15eed2d77a4e2fb471f3ffea17dd3fe26f.png?h=147&dpr=2&auto=format%2Ccompress&orient=")'],["alt","","draggable","false","src","https://proton-resources-production.imgix.net/2c16d5d79019eaa91f9ad78a536d2e15eed2d77a4e2fb471f3ffea17dd3fe26f.png?h=147&dpr=2&auto=format%2Ccompress&orient=",1,"css-9pa8cd"],[1,"css-175oi2r",2,"height","147px"],[1,"css-175oi2r","r-12vffkv",2,"position","absolute","top","209px","transform","translateX(0px) translateY(0px)","left","27.9412%","width","51.1765%","height","auto","z-index","6"],[1,"css-175oi2r","r-105ug2t",2,"top","0px","left","0px","width","100%","height","auto","z-index","6","position","relative","margin-top","0px","margin-left","0px","right","0px","opacity","1"],["dir","auto",1,"css-146c3p1",2,"color","rgb(117, 117, 117)","font-size","16px","font-weight","500","text-align","left","font-family","inherit","min-height","19px","flex","1 1 0%","width","100%"],[1,"css-175oi2r","r-12vffkv",2,"position","absolute","top","169px","transform","translateX(0px) translateY(0px)","left","51.2821%","width","43.8462%","height","244px","z-index","7"],["tabindex","0",1,"css-175oi2r","r-lrvibr","r-1loqt21","r-1otgn73",2,"top","0px","left","0px","width","100%","height","246px","z-index","7","position","absolute","margin-top","0px","margin-left","0px","right","0px","opacity","1"],[1,"css-175oi2r","r-12vffkv",2,"position","absolute","top","46px","transform","translateX(0px) translateY(0px)","left","4.09357%","width","91.8129%","height","152px","z-index","8"],[1,"css-175oi2r","r-105ug2t",2,"top","0px","left","0px","width","100%","height","152px","z-index","8","position","absolute","margin-top","0px","margin-left","0px","right","0px","opacity","1"],[1,"css-175oi2r","r-1mlwlqe","r-1udh08x","r-417010",2,"width","157px","height","152px"],[1,"css-175oi2r","r-1niwhzg","r-vvn4in","r-u6sd8q","r-1p0dtai","r-1pi2tsx","r-1d2f490","r-u8s1d","r-zchlnj","r-ipm5af","r-13qz1uu","r-1wyyakw","r-ehq7j7",2,"background-image",'url("blob:https://previewer.adalo.com/572bf1d4-1ac3-4d52-8855-9b531994b5f6")'],["alt","","draggable","false","src","blob:https://previewer.adalo.com/572bf1d4-1ac3-4d52-8855-9b531994b5f6",1,"css-9pa8cd"],[1,"css-175oi2r","r-1niwhzg","r-vvn4in","r-u6sd8q","r-1p0dtai","r-1pi2tsx","r-1d2f490","r-u8s1d","r-zchlnj","r-ipm5af","r-13qz1uu","r-1wyyakw","r-ehq7j7",2,"background-image",'url("https://proton-resources-production.imgix.net/eb4667d62bea3c292c033b517d0b909d06731d2c5ba32c2555f5c68e1866e76a.png?w=157&dpr=2&auto=format%2Ccompress&orient=")'],["alt","","draggable","false","src","https://proton-resources-production.imgix.net/eb4667d62bea3c292c033b517d0b909d06731d2c5ba32c2555f5c68e1866e76a.png?w=157&dpr=2&auto=format%2Ccompress&orient=",1,"css-9pa8cd"],[1,"css-175oi2r",2,"height","152px"],[1,"css-175oi2r","r-12vffkv",2,"position","absolute","top","209px","transform","translateX(0px) translateY(0px)","left","27.9412%","width","51.1765%","height","auto","z-index","9"],[1,"css-175oi2r","r-105ug2t",2,"top","0px","left","0px","width","100%","height","auto","z-index","9","position","relative","margin-top","0px","margin-left","0px","right","0px","opacity","1"],[1,"css-175oi2r","r-12vffkv",2,"position","absolute","top","437px","transform","translateX(0px) translateY(0px)","left","4.10256%","width","43.8462%","height","244px","z-index","10"],["tabindex","0",1,"css-175oi2r","r-lrvibr","r-1loqt21","r-1otgn73",2,"top","0px","left","0px","width","100%","height","246px","z-index","10","position","absolute","margin-top","0px","margin-left","0px","right","0px","opacity","1"],[1,"css-175oi2r","r-12vffkv",2,"position","absolute","top","46px","transform","translateX(0px) translateY(0px)","left","4.09357%","width","91.8129%","height","152px","z-index","11"],[1,"css-175oi2r","r-105ug2t",2,"top","0px","left","0px","width","100%","height","152px","z-index","11","position","absolute","margin-top","0px","margin-left","0px","right","0px","opacity","1"],[1,"css-175oi2r","r-1niwhzg","r-vvn4in","r-u6sd8q","r-1p0dtai","r-1pi2tsx","r-1d2f490","r-u8s1d","r-zchlnj","r-ipm5af","r-13qz1uu","r-1wyyakw","r-ehq7j7",2,"background-image",'url("blob:https://previewer.adalo.com/1af2e07a-c6dd-4bf8-a10d-50c20184dc78")'],["alt","","draggable","false","src","blob:https://previewer.adalo.com/1af2e07a-c6dd-4bf8-a10d-50c20184dc78",1,"css-9pa8cd"],[1,"css-175oi2r","r-1niwhzg","r-vvn4in","r-u6sd8q","r-1p0dtai","r-1pi2tsx","r-1d2f490","r-u8s1d","r-zchlnj","r-ipm5af","r-13qz1uu","r-1wyyakw","r-ehq7j7",2,"background-image",'url("https://proton-resources-production.imgix.net/f0421588bfeaccbd87d25bb8641311615d0a0e06d4cd9ee910dca9309e4b6eb6.png?w=157&dpr=2&auto=format%2Ccompress&orient=")'],["alt","","draggable","false","src","https://proton-resources-production.imgix.net/f0421588bfeaccbd87d25bb8641311615d0a0e06d4cd9ee910dca9309e4b6eb6.png?w=157&dpr=2&auto=format%2Ccompress&orient=",1,"css-9pa8cd"],[1,"css-175oi2r","r-12vffkv",2,"position","absolute","top","209px","transform","translateX(0px) translateY(0px)","left","28.0702%","width","54.9708%","height","auto","z-index","12"],[1,"css-175oi2r","r-105ug2t",2,"top","0px","left","0px","width","100%","height","auto","z-index","12","position","relative","margin-top","0px","margin-left","0px","right","0px","opacity","1"],[1,"css-175oi2r","r-12vffkv",2,"position","absolute","top","437px","transform","translateX(0px) translateY(0px)","left","52.0513%","width","43.8462%","height","244px","z-index","13"],["tabindex","0",1,"css-175oi2r","r-lrvibr","r-1loqt21","r-1otgn73",2,"top","0px","left","0px","width","100%","height","248px","z-index","13","position","absolute","margin-top","0px","margin-left","0px","right","0px","opacity","1"],[1,"css-175oi2r","r-12vffkv",2,"position","absolute","top","48px","transform","translateX(0px) translateY(0px)","left","4.09357%","width","91.8129%","height","152px","z-index","14"],[1,"css-175oi2r","r-105ug2t",2,"top","0px","left","0px","width","100%","height","152px","z-index","14","position","absolute","margin-top","0px","margin-left","0px","right","0px","opacity","1"],[1,"css-175oi2r","r-1niwhzg","r-vvn4in","r-u6sd8q","r-1p0dtai","r-1pi2tsx","r-1d2f490","r-u8s1d","r-zchlnj","r-ipm5af","r-13qz1uu","r-1wyyakw","r-ehq7j7",2,"background-image",'url("blob:https://previewer.adalo.com/2786ad91-ca09-4f7b-9626-8120ed0cc9a9")'],["alt","","draggable","false","src","blob:https://previewer.adalo.com/2786ad91-ca09-4f7b-9626-8120ed0cc9a9",1,"css-9pa8cd"],[1,"css-175oi2r","r-1niwhzg","r-vvn4in","r-u6sd8q","r-1p0dtai","r-1pi2tsx","r-1d2f490","r-u8s1d","r-zchlnj","r-ipm5af","r-13qz1uu","r-1wyyakw","r-ehq7j7",2,"background-image",'url("https://proton-resources-production.imgix.net/9c895a6a087441c228055f96c3ef24a48352c165604661ade2724eefa70133eb.png?w=157&dpr=2&auto=format%2Ccompress&orient=")'],["alt","","draggable","false","src","https://proton-resources-production.imgix.net/9c895a6a087441c228055f96c3ef24a48352c165604661ade2724eefa70133eb.png?w=157&dpr=2&auto=format%2Ccompress&orient=",1,"css-9pa8cd"],[1,"css-175oi2r","r-12vffkv",2,"position","absolute","top","211px","transform","translateX(0px) translateY(0px)","left","28.0702%","width","54.9708%","height","auto","z-index","15"],[1,"css-175oi2r","r-105ug2t",2,"top","0px","left","0px","width","100%","height","auto","z-index","15","position","relative","margin-top","0px","margin-left","0px","right","0px","opacity","1"],[1,"css-175oi2r","r-12vffkv",2,"position","absolute","top","8px","transform","translateX(0px) translateY(0px)","left","68.4211%","width","29.8246%","height","auto","z-index","16"],[1,"css-175oi2r","r-105ug2t",2,"top","0px","left","0px","width","100%","height","auto","z-index","16","position","relative","margin-top","0px","margin-left","0px","right","0px","opacity","1"],["dir","auto",1,"css-146c3p1",2,"color","rgb(255, 44, 0)","font-size","16px","font-weight","500","text-align","left","font-family","inherit","min-height","19px","flex","1 1 0%","width","100%"],[1,"css-175oi2r","r-1d2f490","r-u8s1d","r-zchlnj","r-ipm5af"],[1,"css-175oi2r","r-1p0dtai","r-1d2f490","r-u8s1d","r-zchlnj"],[1,"status-bar-wrapper","status-bar-wrapper--responsive"],[1,"status-bar","status-bar-dark","status-bar-responsive"],[1,"status-bar-element","status-bar-element-responsive-time","status-bar-element-align-center"],[1,"status-bar-clock"],[1,"status-bar-element","status-bar-element-responsive","status-bar-element-align-center"],[1,"status-bar-element","status-bar-element-connection-bars-responsive","status-bar-element-align-center"],[1,"status-bar-icon","status-bar-icon-connection-bars-responsive"],[1,"status-bar-element","status-bar-element-wifi-responsive","status-bar-element-align-center"],[1,"status-bar-icon","status-bar-icon-wifi-responsive"],[1,"status-bar-element","status-bar-element-battery-responsive","status-bar-element-align-center"],[1,"status-bar-icon","status-bar-icon-battery-responsive"],[1,"app-border"]],template:function(e,r){1&e&&(K.TgZ(0,"div",0)(1,"div",1)(2,"div",2)(3,"div")(4,"h1",3),K._uU(5,"DiloConSe\xf1as"),K.qZA()(),K._UZ(6,"div",4),K.qZA(),K.TgZ(7,"div",5)(8,"div",6)(9,"div",7)(10,"div",8),K.O4$(),K.TgZ(11,"svg",9)(12,"style",10),K._uU(13," .st0 { fill: #424242; } .st1 { fill: #616161; } .st2 { fill: #333333; } .st3 { fill: none; } "),K.qZA(),K._UZ(14,"path",11)(15,"path",12)(16,"path",13)(17,"path",14)(18,"path",15)(19,"path",16)(20,"line",17)(21,"line",18)(22,"path",19),K.qZA()(),K.kcU(),K.TgZ(23,"div",20)(24,"div",21)(25,"div",22)(26,"div",23)(27,"div",24)(28,"div",25)(29,"div",25)(30,"div",26)(31,"div",27)(32,"div",28)(33,"div",29)(34,"div",30)(35,"div",31),K._UZ(36,"div",32),K.TgZ(37,"div",33)(38,"div",34)(39,"div",35)(40,"div",36)(41,"div",37),K._uU(42," Traductor"),K.qZA()()()()(),K.TgZ(43,"div",38),K._UZ(44,"video",39,40)(46,"canvas",null,41),K.TgZ(48,"h1",42),K._uU(49),K.qZA()()()()()()()()()(),K.TgZ(50,"div",43),K._UZ(51,"div",44),K.qZA()(),K._UZ(52,"div",45),K.qZA(),K.TgZ(53,"div",23)(54,"div",24)(55,"div",25)(56,"div",25)(57,"div",26)(58,"div",27)(59,"div",28)(60,"div",29)(61,"div",30)(62,"div",31)(63,"div",46)(64,"div",34)(65,"div",47)(66,"div",48)(67,"div",49),K._UZ(68,"div",50),K.TgZ(69,"div",51)(70,"div",52),K._uU(71," \ue7ff"),K.qZA()()()()()()(),K.TgZ(72,"div",32)(73,"div",34)(74,"div",53)(75,"div",54)(76,"div",49),K._UZ(77,"div",55),K.TgZ(78,"div",56)(79,"div",57),K._uU(80," \ue87f"),K.qZA()()()()()()(),K.TgZ(81,"div",58)(82,"div",34)(83,"div",35)(84,"div",36)(85,"div",37),K._uU(86," Inicio"),K.qZA()()()()(),K.TgZ(87,"div",59)(88,"div",60)(89,"div",61)(90,"div",62)(91,"div",63)(92,"div",64),K._UZ(93,"div",65),K.qZA()(),K.TgZ(94,"div",66)(95,"div",67)(96,"div",68)(97,"div",69)(98,"div",70)(99,"div",65)(100,"div",71)(101,"div",72),K._UZ(102,"div",73)(103,"img",74),K.qZA()(),K.TgZ(104,"div",75),K._UZ(105,"div",76)(106,"img",77),K.qZA()()()(),K._UZ(107,"div",78),K.qZA()(),K.TgZ(108,"div",79)(109,"div",34)(110,"div",80)(111,"div",36)(112,"div",81),K._uU(113," Lecciones"),K.qZA()()()()()()()()()(),K.TgZ(114,"div",82)(115,"div",83)(116,"div",61)(117,"div",62)(118,"div",63)(119,"div",64),K._UZ(120,"div",65),K.qZA()(),K.TgZ(121,"div",66)(122,"div",84)(123,"div",85)(124,"div",69)(125,"div",70)(126,"div",65)(127,"div",71)(128,"div",86),K._UZ(129,"div",87)(130,"img",88),K.qZA()(),K.TgZ(131,"div",75),K._UZ(132,"div",89)(133,"img",90),K.qZA()()()(),K._UZ(134,"div",91),K.qZA()(),K.TgZ(135,"div",92)(136,"div",34)(137,"div",93)(138,"div",36)(139,"div",81),K._uU(140," Diccionario"),K.qZA()()()()()()()()()(),K.TgZ(141,"div",94)(142,"div",95)(143,"div",61)(144,"div",62)(145,"div",63)(146,"div",64),K._UZ(147,"div",65),K.qZA()(),K.TgZ(148,"div",66)(149,"div",96)(150,"div",97)(151,"div",69)(152,"div",70)(153,"div",65)(154,"div",71)(155,"div",86),K._UZ(156,"div",98)(157,"img",99),K.qZA()(),K.TgZ(158,"div",75),K._UZ(159,"div",100)(160,"img",101),K.qZA()()()(),K._UZ(161,"div",91),K.qZA()(),K.TgZ(162,"div",102)(163,"div",34)(164,"div",103)(165,"div",36)(166,"div",81),K._uU(167," Videoteca"),K.qZA()()()()()()()()()(),K.TgZ(168,"div",104)(169,"div",105)(170,"div",61)(171,"div",62)(172,"div",63)(173,"div",64),K._UZ(174,"div",65),K.qZA()(),K.TgZ(175,"div",66)(176,"div",106)(177,"div",107)(178,"div",69)(179,"div",70)(180,"div",65)(181,"div",71)(182,"div",86),K._UZ(183,"div",108)(184,"img",109),K.qZA()(),K.TgZ(185,"div",75),K._UZ(186,"div",110)(187,"img",111),K.qZA()()()(),K._UZ(188,"div",91),K.qZA()(),K.TgZ(189,"div",112)(190,"div",34)(191,"div",113)(192,"div",36)(193,"div",81),K._uU(194," Traductor"),K.qZA()()()()(),K.TgZ(195,"div",114)(196,"div",34)(197,"div",115)(198,"div",36)(199,"div",116),K._uU(200," Demo"),K.qZA()()()()()()()()()()()()()()()()()(),K.TgZ(201,"div",43),K._UZ(202,"div",44),K.qZA()()()(),K._UZ(203,"div",117)(204,"div",118),K.qZA(),K.TgZ(205,"div",119)(206,"div",120)(207,"div",121)(208,"div",122),K._uU(209,"11:19"),K.qZA()(),K.TgZ(210,"div",123)(211,"div",124),K._UZ(212,"div",125),K.qZA(),K.TgZ(213,"div",126),K._UZ(214,"div",127),K.qZA(),K.TgZ(215,"div",128),K._UZ(216,"div",129),K.qZA()()()()()()()()(),K._UZ(217,"div",130),K.qZA()),2&e&&(K.xp6(44),K.Q6J("srcObject",r.stream),K.xp6(5),K.Oqu(r.gesto))},dependencies:[hG]}),n})();class Zk{}const jc="*";function Jk(n,t=null){return{type:2,steps:n,options:t}}function px(n){return{type:6,styles:n,offset:null}}function nA(n){Promise.resolve().then(n)}class Uy{constructor(t=0,e=0){this._onDoneFns=[],this._onStartFns=[],this._onDestroyFns=[],this._originalOnDoneFns=[],this._originalOnStartFns=[],this._started=!1,this._destroyed=!1,this._finished=!1,this._position=0,this.parentPlayer=null,this.totalTime=t+e}_onFinish(){this._finished||(this._finished=!0,this._onDoneFns.forEach(t=>t()),this._onDoneFns=[])}onStart(t){this._originalOnStartFns.push(t),this._onStartFns.push(t)}onDone(t){this._originalOnDoneFns.push(t),this._onDoneFns.push(t)}onDestroy(t){this._onDestroyFns.push(t)}hasStarted(){return this._started}init(){}play(){this.hasStarted()||(this._onStart(),this.triggerMicrotask()),this._started=!0}triggerMicrotask(){nA(()=>this._onFinish())}_onStart(){this._onStartFns.forEach(t=>t()),this._onStartFns=[]}pause(){}restart(){}finish(){this._onFinish()}destroy(){this._destroyed||(this._destroyed=!0,this.hasStarted()||this._onStart(),this.finish(),this._onDestroyFns.forEach(t=>t()),this._onDestroyFns=[])}reset(){this._started=!1,this._finished=!1,this._onStartFns=this._originalOnStartFns,this._onDoneFns=this._originalOnDoneFns}setPosition(t){this._position=this.totalTime?t*this.totalTime:1}getPosition(){return this.totalTime?this._position/this.totalTime:1}triggerCallback(t){const e="start"==t?this._onStartFns:this._onDoneFns;e.forEach(r=>r()),e.length=0}}class rA{constructor(t){this._onDoneFns=[],this._onStartFns=[],this._finished=!1,this._started=!1,this._destroyed=!1,this._onDestroyFns=[],this.parentPlayer=null,this.totalTime=0,this.players=t;let e=0,r=0,s=0;const o=this.players.length;0==o?nA(()=>this._onFinish()):this.players.forEach(l=>{l.onDone(()=>{++e==o&&this._onFinish()}),l.onDestroy(()=>{++r==o&&this._onDestroy()}),l.onStart(()=>{++s==o&&this._onStart()})}),this.totalTime=this.players.reduce((l,u)=>Math.max(l,u.totalTime),0)}_onFinish(){this._finished||(this._finished=!0,this._onDoneFns.forEach(t=>t()),this._onDoneFns=[])}init(){this.players.forEach(t=>t.init())}onStart(t){this._onStartFns.push(t)}_onStart(){this.hasStarted()||(this._started=!0,this._onStartFns.forEach(t=>t()),this._onStartFns=[])}onDone(t){this._onDoneFns.push(t)}onDestroy(t){this._onDestroyFns.push(t)}hasStarted(){return this._started}play(){this.parentPlayer||this.init(),this._onStart(),this.players.forEach(t=>t.play())}pause(){this.players.forEach(t=>t.pause())}restart(){this.players.forEach(t=>t.restart())}finish(){this._onFinish(),this.players.forEach(t=>t.finish())}destroy(){this._onDestroy()}_onDestroy(){this._destroyed||(this._destroyed=!0,this._onFinish(),this.players.forEach(t=>t.destroy()),this._onDestroyFns.forEach(t=>t()),this._onDestroyFns=[])}reset(){this.players.forEach(t=>t.reset()),this._destroyed=!1,this._finished=!1,this._started=!1}setPosition(t){const e=t*this.totalTime;this.players.forEach(r=>{const s=r.totalTime?Math.min(1,e/r.totalTime):1;r.setPosition(s)})}getPosition(){const t=this.players.reduce((e,r)=>null===e||r.totalTime>e.totalTime?r:e,null);return null!=t?t.getPosition():0}beforeDestroy(){this.players.forEach(t=>{t.beforeDestroy&&t.beforeDestroy()})}triggerCallback(t){const e="start"==t?this._onStartFns:this._onDoneFns;e.forEach(r=>r()),e.length=0}}function sA(n){return new K.vHH(3e3,!1)}function QG(){return"undefined"!=typeof window&&void 0!==window.document}function eI(){return"undefined"!=typeof process&&"[object process]"==={}.toString.call(process)}function ad(n){switch(n.length){case 0:return new Uy;case 1:return n[0];default:return new rA(n)}}function oA(n,t,e,r,s=new Map,o=new Map){const l=[],u=[];let d=-1,h=null;if(r.forEach(p=>{const g=p.get("offset"),y=g==d,b=y&&h||new Map;p.forEach((_,I)=>{let S=I,T=_;if("offset"!==I)switch(S=t.normalizePropertyName(S,l),T){case"!":T=s.get(I);break;case jc:T=o.get(I);break;default:T=t.normalizeStyleValue(I,S,T,l)}b.set(S,T)}),y||u.push(b),h=b,d=g}),l.length)throw function VG(n){return new K.vHH(3502,!1)}();return u}function tI(n,t,e,r){switch(t){case"start":n.onStart(()=>r(e&&nI(e,"start",n)));break;case"done":n.onDone(()=>r(e&&nI(e,"done",n)));break;case"destroy":n.onDestroy(()=>r(e&&nI(e,"destroy",n)))}}function nI(n,t,e){const r=e.totalTime,o=rI(n.element,n.triggerName,n.fromState,n.toState,t||n.phaseName,null==r?n.totalTime:r,!!e.disabled),l=n._data;return null!=l&&(o._data=l),o}function rI(n,t,e,r,s="",o=0,l){return{element:n,triggerName:t,fromState:e,toState:r,phaseName:s,totalTime:o,disabled:!!l}}function Ri(n,t,e){let r=n.get(t);return r||n.set(t,r=e),r}function iA(n){const t=n.indexOf(":");return[n.substring(1,t),n.slice(t+1)]}let sI=(n,t)=>!1,aA=(n,t,e)=>[],lA=null;function oI(n){const t=n.parentNode||n.host;return t===lA?null:t}(eI()||"undefined"!=typeof Element)&&(QG()?(lA=(()=>document.documentElement)(),sI=(n,t)=>{for(;t;){if(t===n)return!0;t=oI(t)}return!1}):sI=(n,t)=>n.contains(t),aA=(n,t,e)=>{if(e)return Array.from(n.querySelectorAll(t));const r=n.querySelector(t);return r?[r]:[]});let Ah=null,cA=!1;const uA=sI,dA=aA;let hA=(()=>{class n{validateStyleProperty(e){return function e6(n){Ah||(Ah=function t6(){return"undefined"!=typeof document?document.body:null}()||{},cA=!!Ah.style&&"WebkitAppearance"in Ah.style);let t=!0;return Ah.style&&!function JG(n){return"ebkit"==n.substring(1,6)}(n)&&(t=n in Ah.style,!t&&cA&&(t="Webkit"+n.charAt(0).toUpperCase()+n.slice(1)in Ah.style)),t}(e)}matchesElement(e,r){return!1}containsElement(e,r){return uA(e,r)}getParentElement(e){return oI(e)}query(e,r,s){return dA(e,r,s)}computeStyle(e,r,s){return s||""}animate(e,r,s,o,l,u=[],d){return new Uy(s,o)}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=K.Yz7({token:n,factory:n.\u0275fac}),n})(),iI=(()=>{class n{}return n.NOOP=new hA,n})();const aI="ng-enter",mx="ng-leave",gx="ng-trigger",yx=".ng-trigger",pA="ng-animating",lI=".ng-animating";function Gc(n){if("number"==typeof n)return n;const t=n.match(/^(-?[\.\d]+)(m?s)/);return!t||t.length<2?0:cI(parseFloat(t[1]),t[2])}function cI(n,t){return"s"===t?1e3*n:n}function vx(n,t,e){return n.hasOwnProperty("duration")?n:function s6(n,t,e){let s,o=0,l="";if("string"==typeof n){const u=n.match(/^(-?[\.\d]+)(m?s)(?:\s+(-?[\.\d]+)(m?s))?(?:\s+([-a-z]+(?:\(.+?\))?))?$/i);if(null===u)return t.push(sA()),{duration:0,delay:0,easing:""};s=cI(parseFloat(u[1]),u[2]);const d=u[3];null!=d&&(o=cI(parseFloat(d),u[4]));const h=u[5];h&&(l=h)}else s=n;if(!e){let u=!1,d=t.length;s<0&&(t.push(function vG(){return new K.vHH(3100,!1)}()),u=!0),o<0&&(t.push(function bG(){return new K.vHH(3101,!1)}()),u=!0),u&&t.splice(d,0,sA())}return{duration:s,delay:o,easing:l}}(n,t,e)}function zy(n,t={}){return Object.keys(n).forEach(e=>{t[e]=n[e]}),t}function mA(n){const t=new Map;return Object.keys(n).forEach(e=>{t.set(e,n[e])}),t}function ld(n,t=new Map,e){if(e)for(let[r,s]of e)t.set(r,s);for(let[r,s]of n)t.set(r,s);return t}function yA(n,t,e){return e?t+":"+e+";":""}function vA(n){let t="";for(let e=0;e<n.style.length;e++){const r=n.style.item(e);t+=yA(0,r,n.style.getPropertyValue(r))}for(const e in n.style)n.style.hasOwnProperty(e)&&!e.startsWith("_")&&(t+=yA(0,l6(e),n.style[e]));n.setAttribute("style",t)}function Zl(n,t,e){n.style&&(t.forEach((r,s)=>{const o=dI(s);e&&!e.has(s)&&e.set(s,n.style[o]),n.style[o]=r}),eI()&&vA(n))}function Rh(n,t){n.style&&(t.forEach((e,r)=>{const s=dI(r);n.style[s]=""}),eI()&&vA(n))}function Hy(n){return Array.isArray(n)?1==n.length?n[0]:Jk(n):n}const uI=new RegExp("{{\\s*(.+?)\\s*}}","g");function bA(n){let t=[];if("string"==typeof n){let e;for(;e=uI.exec(n);)t.push(e[1]);uI.lastIndex=0}return t}function Wy(n,t,e){const r=n.toString(),s=r.replace(uI,(o,l)=>{let u=t[l];return null==u&&(e.push(function xG(n){return new K.vHH(3003,!1)}()),u=""),u.toString()});return s==r?n:s}function bx(n){const t=[];let e=n.next();for(;!e.done;)t.push(e.value),e=n.next();return t}const a6=/-+([a-z0-9])/g;function dI(n){return n.replace(a6,(...t)=>t[1].toUpperCase())}function l6(n){return n.replace(/([a-z])([A-Z])/g,"$1-$2").toLowerCase()}function Mi(n,t,e){switch(t.type){case 7:return n.visitTrigger(t,e);case 0:return n.visitState(t,e);case 1:return n.visitTransition(t,e);case 2:return n.visitSequence(t,e);case 3:return n.visitGroup(t,e);case 4:return n.visitAnimate(t,e);case 5:return n.visitKeyframes(t,e);case 6:return n.visitStyle(t,e);case 8:return n.visitReference(t,e);case 9:return n.visitAnimateChild(t,e);case 10:return n.visitAnimateRef(t,e);case 11:return n.visitQuery(t,e);case 12:return n.visitStagger(t,e);default:throw function wG(n){return new K.vHH(3004,!1)}()}}function _A(n,t){return window.getComputedStyle(n)[t]}function p6(n,t){const e=[];return"string"==typeof n?n.split(/\s*,\s*/).forEach(r=>function m6(n,t,e){if(":"==n[0]){const d=function g6(n,t){switch(n){case":enter":return"void => *";case":leave":return"* => void";case":increment":return(e,r)=>parseFloat(r)>parseFloat(e);case":decrement":return(e,r)=>parseFloat(r)<parseFloat(e);default:return t.push(function $G(n){return new K.vHH(3016,!1)}()),"* => *"}}(n,e);if("function"==typeof d)return void t.push(d);n=d}const r=n.match(/^(\*|[-\w]+)\s*(<?[=-]>)\s*(\*|[-\w]+)$/);if(null==r||r.length<4)return e.push(function FG(n){return new K.vHH(3015,!1)}()),t;const s=r[1],o=r[2],l=r[3];t.push(xA(s,l));"<"==o[0]&&!("*"==s&&"*"==l)&&t.push(xA(l,s))}(r,e,t)):e.push(n),e}const Cx=new Set(["true","1"]),Sx=new Set(["false","0"]);function xA(n,t){const e=Cx.has(n)||Sx.has(n),r=Cx.has(t)||Sx.has(t);return(s,o)=>{let l="*"==n||n==s,u="*"==t||t==o;return!l&&e&&"boolean"==typeof s&&(l=s?Cx.has(n):Sx.has(n)),!u&&r&&"boolean"==typeof o&&(u=o?Cx.has(t):Sx.has(t)),l&&u}}const y6=new RegExp("s*:selfs*,?","g");function hI(n,t,e,r){return new v6(n).build(t,e,r)}class v6{constructor(t){this._driver=t}build(t,e,r){const s=new x6(e);return this._resetContextStyleTimingState(s),Mi(this,Hy(t),s)}_resetContextStyleTimingState(t){t.currentQuerySelector="",t.collectedStyles=new Map,t.collectedStyles.set("",new Map),t.currentTime=0}visitTrigger(t,e){let r=e.queryCount=0,s=e.depCount=0;const o=[],l=[];return"@"==t.name.charAt(0)&&e.errors.push(function SG(){return new K.vHH(3006,!1)}()),t.definitions.forEach(u=>{if(this._resetContextStyleTimingState(e),0==u.type){const d=u,h=d.name;h.toString().split(/\s*,\s*/).forEach(p=>{d.name=p,o.push(this.visitState(d,e))}),d.name=h}else if(1==u.type){const d=this.visitTransition(u,e);r+=d.queryCount,s+=d.depCount,l.push(d)}else e.errors.push(function EG(){return new K.vHH(3007,!1)}())}),{type:7,name:t.name,states:o,transitions:l,queryCount:r,depCount:s,options:null}}visitState(t,e){const r=this.visitStyle(t.styles,e),s=t.options&&t.options.params||null;if(r.containsDynamicStyles){const o=new Set,l=s||{};r.styles.forEach(u=>{u instanceof Map&&u.forEach(d=>{bA(d).forEach(h=>{l.hasOwnProperty(h)||o.add(h)})})}),o.size&&(bx(o.values()),e.errors.push(function IG(n,t){return new K.vHH(3008,!1)}()))}return{type:0,name:t.name,style:r,options:s?{params:s}:null}}visitTransition(t,e){e.queryCount=0,e.depCount=0;const r=Mi(this,Hy(t.animation),e);return{type:1,matchers:p6(t.expr,e.errors),animation:r,queryCount:e.queryCount,depCount:e.depCount,options:Mh(t.options)}}visitSequence(t,e){return{type:2,steps:t.steps.map(r=>Mi(this,r,e)),options:Mh(t.options)}}visitGroup(t,e){const r=e.currentTime;let s=0;const o=t.steps.map(l=>{e.currentTime=r;const u=Mi(this,l,e);return s=Math.max(s,e.currentTime),u});return e.currentTime=s,{type:3,steps:o,options:Mh(t.options)}}visitAnimate(t,e){const r=function C6(n,t){if(n.hasOwnProperty("duration"))return n;if("number"==typeof n)return fI(vx(n,t).duration,0,"");const e=n;if(e.split(/\s+/).some(o=>"{"==o.charAt(0)&&"{"==o.charAt(1))){const o=fI(0,0,"");return o.dynamic=!0,o.strValue=e,o}const s=vx(e,t);return fI(s.duration,s.delay,s.easing)}(t.timings,e.errors);e.currentAnimateTimings=r;let s,o=t.styles?t.styles:px({});if(5==o.type)s=this.visitKeyframes(o,e);else{let l=t.styles,u=!1;if(!l){u=!0;const h={};r.easing&&(h.easing=r.easing),l=px(h)}e.currentTime+=r.duration+r.delay;const d=this.visitStyle(l,e);d.isEmptyStep=u,s=d}return e.currentAnimateTimings=null,{type:4,timings:r,style:s,options:null}}visitStyle(t,e){const r=this._makeStyleAst(t,e);return this._validateStyleAst(r,e),r}_makeStyleAst(t,e){const r=[],s=Array.isArray(t.styles)?t.styles:[t.styles];for(let u of s)"string"==typeof u?u===jc?r.push(u):e.errors.push(new K.vHH(3002,!1)):r.push(mA(u));let o=!1,l=null;return r.forEach(u=>{if(u instanceof Map&&(u.has("easing")&&(l=u.get("easing"),u.delete("easing")),!o))for(let d of u.values())if(d.toString().indexOf("{{")>=0){o=!0;break}}),{type:6,styles:r,easing:l,offset:t.offset,containsDynamicStyles:o,options:null}}_validateStyleAst(t,e){const r=e.currentAnimateTimings;let s=e.currentTime,o=e.currentTime;r&&o>0&&(o-=r.duration+r.delay),t.styles.forEach(l=>{"string"!=typeof l&&l.forEach((u,d)=>{const h=e.collectedStyles.get(e.currentQuerySelector),p=h.get(d);let g=!0;p&&(o!=s&&o>=p.startTime&&s<=p.endTime&&(e.errors.push(function TG(n,t,e,r,s){return new K.vHH(3010,!1)}()),g=!1),o=p.startTime),g&&h.set(d,{startTime:o,endTime:s}),e.options&&function i6(n,t,e){const r=t.params||{},s=bA(n);s.length&&s.forEach(o=>{r.hasOwnProperty(o)||e.push(function _G(n){return new K.vHH(3001,!1)}())})}(u,e.options,e.errors)})})}visitKeyframes(t,e){const r={type:5,styles:[],options:null};if(!e.currentAnimateTimings)return e.errors.push(function NG(){return new K.vHH(3011,!1)}()),r;let o=0;const l=[];let u=!1,d=!1,h=0;const p=t.steps.map(T=>{const O=this._makeStyleAst(T,e);let V=null!=O.offset?O.offset:function w6(n){if("string"==typeof n)return null;let t=null;if(Array.isArray(n))n.forEach(e=>{if(e instanceof Map&&e.has("offset")){const r=e;t=parseFloat(r.get("offset")),r.delete("offset")}});else if(n instanceof Map&&n.has("offset")){const e=n;t=parseFloat(e.get("offset")),e.delete("offset")}return t}(O.styles),U=0;return null!=V&&(o++,U=O.offset=V),d=d||U<0||U>1,u=u||U<h,h=U,l.push(U),O});d&&e.errors.push(function kG(){return new K.vHH(3012,!1)}()),u&&e.errors.push(function AG(){return new K.vHH(3200,!1)}());const g=t.steps.length;let y=0;o>0&&o<g?e.errors.push(function RG(){return new K.vHH(3202,!1)}()):0==o&&(y=1/(g-1));const b=g-1,_=e.currentTime,I=e.currentAnimateTimings,S=I.duration;return p.forEach((T,O)=>{const V=y>0?O==b?1:y*O:l[O],U=V*S;e.currentTime=_+I.delay+U,I.duration=U,this._validateStyleAst(T,e),T.offset=V,r.styles.push(T)}),r}visitReference(t,e){return{type:8,animation:Mi(this,Hy(t.animation),e),options:Mh(t.options)}}visitAnimateChild(t,e){return e.depCount++,{type:9,options:Mh(t.options)}}visitAnimateRef(t,e){return{type:10,animation:this.visitReference(t.animation,e),options:Mh(t.options)}}visitQuery(t,e){const r=e.currentQuerySelector,s=t.options||{};e.queryCount++,e.currentQuery=t;const[o,l]=function b6(n){const t=!!n.split(/\s*,\s*/).find(e=>":self"==e);return t&&(n=n.replace(y6,"")),n=n.replace(/@\*/g,yx).replace(/@\w+/g,e=>yx+"-"+e.slice(1)).replace(/:animating/g,lI),[n,t]}(t.selector);e.currentQuerySelector=r.length?r+" "+o:o,Ri(e.collectedStyles,e.currentQuerySelector,new Map);const u=Mi(this,Hy(t.animation),e);return e.currentQuery=null,e.currentQuerySelector=r,{type:11,selector:o,limit:s.limit||0,optional:!!s.optional,includeSelf:l,animation:u,originalSelector:t.selector,options:Mh(t.options)}}visitStagger(t,e){e.currentQuery||e.errors.push(function MG(){return new K.vHH(3013,!1)}());const r="full"===t.timings?{duration:0,delay:0,easing:"full"}:vx(t.timings,e.errors,!0);return{type:12,animation:Mi(this,Hy(t.animation),e),timings:r,options:null}}}class x6{constructor(t){this.errors=t,this.queryCount=0,this.depCount=0,this.currentTransition=null,this.currentQuery=null,this.currentQuerySelector=null,this.currentAnimateTimings=null,this.currentTime=0,this.collectedStyles=new Map,this.options=null,this.unsupportedCSSPropertiesFound=new Set}}function Mh(n){return n?(n=zy(n)).params&&(n.params=function _6(n){return n?zy(n):null}(n.params)):n={},n}function fI(n,t,e){return{duration:n,delay:t,easing:e}}function pI(n,t,e,r,s,o,l=null,u=!1){return{type:1,element:n,keyframes:t,preStyleProps:e,postStyleProps:r,duration:s,delay:o,totalTime:s+o,easing:l,subTimeline:u}}class Ex{constructor(){this._map=new Map}get(t){return this._map.get(t)||[]}append(t,e){let r=this._map.get(t);r||this._map.set(t,r=[]),r.push(...e)}has(t){return this._map.has(t)}clear(){this._map.clear()}}const I6=new RegExp(":enter","g"),T6=new RegExp(":leave","g");function mI(n,t,e,r,s,o=new Map,l=new Map,u,d,h=[]){return(new N6).buildKeyframes(n,t,e,r,s,o,l,u,d,h)}class N6{buildKeyframes(t,e,r,s,o,l,u,d,h,p=[]){h=h||new Ex;const g=new gI(t,e,h,s,o,p,[]);g.options=d;const y=d.delay?Gc(d.delay):0;g.currentTimeline.delayNextStep(y),g.currentTimeline.setStyles([l],null,g.errors,d),Mi(this,r,g);const b=g.timelines.filter(_=>_.containsAnimation());if(b.length&&u.size){let _;for(let I=b.length-1;I>=0;I--){const S=b[I];if(S.element===e){_=S;break}}_&&!_.allowOnlyTimelineStyles()&&_.setStyles([u],null,g.errors,d)}return b.length?b.map(_=>_.buildKeyframes()):[pI(e,[],[],[],0,y,"",!1)]}visitTrigger(t,e){}visitState(t,e){}visitTransition(t,e){}visitAnimateChild(t,e){const r=e.subInstructions.get(e.element);if(r){const s=e.createSubContext(t.options),o=e.currentTimeline.currentTime,l=this._visitSubInstructions(r,s,s.options);o!=l&&e.transformIntoNewTimeline(l)}e.previousNode=t}visitAnimateRef(t,e){const r=e.createSubContext(t.options);r.transformIntoNewTimeline(),this._applyAnimationRefDelays([t.options,t.animation.options],e,r),this.visitReference(t.animation,r),e.transformIntoNewTimeline(r.currentTimeline.currentTime),e.previousNode=t}_applyAnimationRefDelays(t,e,r){var s;for(const o of t){const l=null==o?void 0:o.delay;if(l){const u="number"==typeof l?l:Gc(Wy(l,null!==(s=null==o?void 0:o.params)&&void 0!==s?s:{},e.errors));r.delayNextStep(u)}}}_visitSubInstructions(t,e,r){let o=e.currentTimeline.currentTime;const l=null!=r.duration?Gc(r.duration):null,u=null!=r.delay?Gc(r.delay):null;return 0!==l&&t.forEach(d=>{const h=e.appendInstructionToTimeline(d,l,u);o=Math.max(o,h.duration+h.delay)}),o}visitReference(t,e){e.updateOptions(t.options,!0),Mi(this,t.animation,e),e.previousNode=t}visitSequence(t,e){const r=e.subContextCount;let s=e;const o=t.options;if(o&&(o.params||o.delay)&&(s=e.createSubContext(o),s.transformIntoNewTimeline(),null!=o.delay)){6==s.previousNode.type&&(s.currentTimeline.snapshotCurrentStyles(),s.previousNode=Ix);const l=Gc(o.delay);s.delayNextStep(l)}t.steps.length&&(t.steps.forEach(l=>Mi(this,l,s)),s.currentTimeline.applyStylesToKeyframe(),s.subContextCount>r&&s.transformIntoNewTimeline()),e.previousNode=t}visitGroup(t,e){const r=[];let s=e.currentTimeline.currentTime;const o=t.options&&t.options.delay?Gc(t.options.delay):0;t.steps.forEach(l=>{const u=e.createSubContext(t.options);o&&u.delayNextStep(o),Mi(this,l,u),s=Math.max(s,u.currentTimeline.currentTime),r.push(u.currentTimeline)}),r.forEach(l=>e.currentTimeline.mergeTimelineCollectedStyles(l)),e.transformIntoNewTimeline(s),e.previousNode=t}_visitTiming(t,e){if(t.dynamic){const r=t.strValue;return vx(e.params?Wy(r,e.params,e.errors):r,e.errors)}return{duration:t.duration,delay:t.delay,easing:t.easing}}visitAnimate(t,e){const r=e.currentAnimateTimings=this._visitTiming(t.timings,e),s=e.currentTimeline;r.delay&&(e.incrementTime(r.delay),s.snapshotCurrentStyles());const o=t.style;5==o.type?this.visitKeyframes(o,e):(e.incrementTime(r.duration),this.visitStyle(o,e),s.applyStylesToKeyframe()),e.currentAnimateTimings=null,e.previousNode=t}visitStyle(t,e){const r=e.currentTimeline,s=e.currentAnimateTimings;!s&&r.hasCurrentStyleProperties()&&r.forwardFrame();const o=s&&s.easing||t.easing;t.isEmptyStep?r.applyEmptyStep(o):r.setStyles(t.styles,o,e.errors,e.options),e.previousNode=t}visitKeyframes(t,e){const r=e.currentAnimateTimings,s=e.currentTimeline.duration,o=r.duration,u=e.createSubContext().currentTimeline;u.easing=r.easing,t.styles.forEach(d=>{u.forwardTime((d.offset||0)*o),u.setStyles(d.styles,d.easing,e.errors,e.options),u.applyStylesToKeyframe()}),e.currentTimeline.mergeTimelineCollectedStyles(u),e.transformIntoNewTimeline(s+o),e.previousNode=t}visitQuery(t,e){const r=e.currentTimeline.currentTime,s=t.options||{},o=s.delay?Gc(s.delay):0;o&&(6===e.previousNode.type||0==r&&e.currentTimeline.hasCurrentStyleProperties())&&(e.currentTimeline.snapshotCurrentStyles(),e.previousNode=Ix);let l=r;const u=e.invokeQuery(t.selector,t.originalSelector,t.limit,t.includeSelf,!!s.optional,e.errors);e.currentQueryTotal=u.length;let d=null;u.forEach((h,p)=>{e.currentQueryIndex=p;const g=e.createSubContext(t.options,h);o&&g.delayNextStep(o),h===e.element&&(d=g.currentTimeline),Mi(this,t.animation,g),g.currentTimeline.applyStylesToKeyframe(),l=Math.max(l,g.currentTimeline.currentTime)}),e.currentQueryIndex=0,e.currentQueryTotal=0,e.transformIntoNewTimeline(l),d&&(e.currentTimeline.mergeTimelineCollectedStyles(d),e.currentTimeline.snapshotCurrentStyles()),e.previousNode=t}visitStagger(t,e){const r=e.parentContext,s=e.currentTimeline,o=t.timings,l=Math.abs(o.duration),u=l*(e.currentQueryTotal-1);let d=l*e.currentQueryIndex;switch(o.duration<0?"reverse":o.easing){case"reverse":d=u-d;break;case"full":d=r.currentStaggerTime}const p=e.currentTimeline;d&&p.delayNextStep(d);const g=p.currentTime;Mi(this,t.animation,e),e.previousNode=t,r.currentStaggerTime=s.currentTime-g+(s.startTime-r.currentTimeline.startTime)}}const Ix={};class gI{constructor(t,e,r,s,o,l,u,d){this._driver=t,this.element=e,this.subInstructions=r,this._enterClassName=s,this._leaveClassName=o,this.errors=l,this.timelines=u,this.parentContext=null,this.currentAnimateTimings=null,this.previousNode=Ix,this.subContextCount=0,this.options={},this.currentQueryIndex=0,this.currentQueryTotal=0,this.currentStaggerTime=0,this.currentTimeline=d||new Dx(this._driver,e,0),u.push(this.currentTimeline)}get params(){return this.options.params}updateOptions(t,e){if(!t)return;const r=t;let s=this.options;null!=r.duration&&(s.duration=Gc(r.duration)),null!=r.delay&&(s.delay=Gc(r.delay));const o=r.params;if(o){let l=s.params;l||(l=this.options.params={}),Object.keys(o).forEach(u=>{(!e||!l.hasOwnProperty(u))&&(l[u]=Wy(o[u],l,this.errors))})}}_copyOptions(){const t={};if(this.options){const e=this.options.params;if(e){const r=t.params={};Object.keys(e).forEach(s=>{r[s]=e[s]})}}return t}createSubContext(t=null,e,r){const s=e||this.element,o=new gI(this._driver,s,this.subInstructions,this._enterClassName,this._leaveClassName,this.errors,this.timelines,this.currentTimeline.fork(s,r||0));return o.previousNode=this.previousNode,o.currentAnimateTimings=this.currentAnimateTimings,o.options=this._copyOptions(),o.updateOptions(t),o.currentQueryIndex=this.currentQueryIndex,o.currentQueryTotal=this.currentQueryTotal,o.parentContext=this,this.subContextCount++,o}transformIntoNewTimeline(t){return this.previousNode=Ix,this.currentTimeline=this.currentTimeline.fork(this.element,t),this.timelines.push(this.currentTimeline),this.currentTimeline}appendInstructionToTimeline(t,e,r){const s={duration:null!=e?e:t.duration,delay:this.currentTimeline.currentTime+(null!=r?r:0)+t.delay,easing:""},o=new k6(this._driver,t.element,t.keyframes,t.preStyleProps,t.postStyleProps,s,t.stretchStartingKeyframe);return this.timelines.push(o),s}incrementTime(t){this.currentTimeline.forwardTime(this.currentTimeline.duration+t)}delayNextStep(t){t>0&&this.currentTimeline.delayNextStep(t)}invokeQuery(t,e,r,s,o,l){let u=[];if(s&&u.push(this.element),t.length>0){t=(t=t.replace(I6,"."+this._enterClassName)).replace(T6,"."+this._leaveClassName);let h=this._driver.query(this.element,t,1!=r);0!==r&&(h=r<0?h.slice(h.length+r,h.length):h.slice(0,r)),u.push(...h)}return!o&&0==u.length&&l.push(function OG(n){return new K.vHH(3014,!1)}()),u}}class Dx{constructor(t,e,r,s){this._driver=t,this.element=e,this.startTime=r,this._elementTimelineStylesLookup=s,this.duration=0,this._previousKeyframe=new Map,this._currentKeyframe=new Map,this._keyframes=new Map,this._styleSummary=new Map,this._localTimelineStyles=new Map,this._pendingStyles=new Map,this._backFill=new Map,this._currentEmptyStepKeyframe=null,this._elementTimelineStylesLookup||(this._elementTimelineStylesLookup=new Map),this._globalTimelineStyles=this._elementTimelineStylesLookup.get(e),this._globalTimelineStyles||(this._globalTimelineStyles=this._localTimelineStyles,this._elementTimelineStylesLookup.set(e,this._localTimelineStyles)),this._loadKeyframe()}containsAnimation(){switch(this._keyframes.size){case 0:return!1;case 1:return this.hasCurrentStyleProperties();default:return!0}}hasCurrentStyleProperties(){return this._currentKeyframe.size>0}get currentTime(){return this.startTime+this.duration}delayNextStep(t){const e=1===this._keyframes.size&&this._pendingStyles.size;this.duration||e?(this.forwardTime(this.currentTime+t),e&&this.snapshotCurrentStyles()):this.startTime+=t}fork(t,e){return this.applyStylesToKeyframe(),new Dx(this._driver,t,e||this.currentTime,this._elementTimelineStylesLookup)}_loadKeyframe(){this._currentKeyframe&&(this._previousKeyframe=this._currentKeyframe),this._currentKeyframe=this._keyframes.get(this.duration),this._currentKeyframe||(this._currentKeyframe=new Map,this._keyframes.set(this.duration,this._currentKeyframe))}forwardFrame(){this.duration+=1,this._loadKeyframe()}forwardTime(t){this.applyStylesToKeyframe(),this.duration=t,this._loadKeyframe()}_updateStyle(t,e){this._localTimelineStyles.set(t,e),this._globalTimelineStyles.set(t,e),this._styleSummary.set(t,{time:this.currentTime,value:e})}allowOnlyTimelineStyles(){return this._currentEmptyStepKeyframe!==this._currentKeyframe}applyEmptyStep(t){t&&this._previousKeyframe.set("easing",t);for(let[e,r]of this._globalTimelineStyles)this._backFill.set(e,r||jc),this._currentKeyframe.set(e,jc);this._currentEmptyStepKeyframe=this._currentKeyframe}setStyles(t,e,r,s){var o;e&&this._previousKeyframe.set("easing",e);const l=s&&s.params||{},u=function A6(n,t){const e=new Map;let r;return n.forEach(s=>{if("*"===s){r=r||t.keys();for(let o of r)e.set(o,jc)}else ld(s,e)}),e}(t,this._globalTimelineStyles);for(let[d,h]of u){const p=Wy(h,l,r);this._pendingStyles.set(d,p),this._localTimelineStyles.has(d)||this._backFill.set(d,null!==(o=this._globalTimelineStyles.get(d))&&void 0!==o?o:jc),this._updateStyle(d,p)}}applyStylesToKeyframe(){0!=this._pendingStyles.size&&(this._pendingStyles.forEach((t,e)=>{this._currentKeyframe.set(e,t)}),this._pendingStyles.clear(),this._localTimelineStyles.forEach((t,e)=>{this._currentKeyframe.has(e)||this._currentKeyframe.set(e,t)}))}snapshotCurrentStyles(){for(let[t,e]of this._localTimelineStyles)this._pendingStyles.set(t,e),this._updateStyle(t,e)}getFinalKeyframe(){return this._keyframes.get(this.duration)}get properties(){const t=[];for(let e in this._currentKeyframe)t.push(e);return t}mergeTimelineCollectedStyles(t){t._styleSummary.forEach((e,r)=>{const s=this._styleSummary.get(r);(!s||e.time>s.time)&&this._updateStyle(r,e.value)})}buildKeyframes(){this.applyStylesToKeyframe();const t=new Set,e=new Set,r=1===this._keyframes.size&&0===this.duration;let s=[];this._keyframes.forEach((u,d)=>{const h=ld(u,new Map,this._backFill);h.forEach((p,g)=>{"!"===p?t.add(g):p===jc&&e.add(g)}),r||h.set("offset",d/this.duration),s.push(h)});const o=t.size?bx(t.values()):[],l=e.size?bx(e.values()):[];if(r){const u=s[0],d=new Map(u);u.set("offset",0),d.set("offset",1),s=[u,d]}return pI(this.element,s,o,l,this.duration,this.startTime,this.easing,!1)}}class k6 extends Dx{constructor(t,e,r,s,o,l,u=!1){super(t,e,l.delay),this.keyframes=r,this.preStyleProps=s,this.postStyleProps=o,this._stretchStartingKeyframe=u,this.timings={duration:l.duration,delay:l.delay,easing:l.easing}}containsAnimation(){return this.keyframes.length>1}buildKeyframes(){let t=this.keyframes,{delay:e,duration:r,easing:s}=this.timings;if(this._stretchStartingKeyframe&&e){const o=[],l=r+e,u=e/l,d=ld(t[0]);d.set("offset",0),o.push(d);const h=ld(t[0]);h.set("offset",SA(u)),o.push(h);const p=t.length-1;for(let g=1;g<=p;g++){let y=ld(t[g]);const b=y.get("offset");y.set("offset",SA((e+b*r)/l)),o.push(y)}r=l,e=0,s="",t=o}return pI(this.element,t,this.preStyleProps,this.postStyleProps,r,e,s,!0)}}function SA(n,t=3){const e=Math.pow(10,t-1);return Math.round(n*e)/e}class yI{}const R6=new Set(["width","height","minWidth","minHeight","maxWidth","maxHeight","left","top","bottom","right","fontSize","outlineWidth","outlineOffset","paddingTop","paddingLeft","paddingBottom","paddingRight","marginTop","marginLeft","marginBottom","marginRight","borderRadius","borderWidth","borderTopWidth","borderLeftWidth","borderRightWidth","borderBottomWidth","textIndent","perspective"]);class M6 extends yI{normalizePropertyName(t,e){return dI(t)}normalizeStyleValue(t,e,r,s){let o="";const l=r.toString().trim();if(R6.has(e)&&0!==r&&"0"!==r)if("number"==typeof r)o="px";else{const u=r.match(/^[+-]?[\d\.]+([a-z]*)$/);u&&0==u[1].length&&s.push(function CG(n,t){return new K.vHH(3005,!1)}())}return l+o}}function EA(n,t,e,r,s,o,l,u,d,h,p,g,y){return{type:0,element:n,triggerName:t,isRemovalTransition:s,fromState:e,fromStyles:o,toState:r,toStyles:l,timelines:u,queriedElements:d,preStyleProps:h,postStyleProps:p,totalTime:g,errors:y}}const vI={};class IA{constructor(t,e,r){this._triggerName=t,this.ast=e,this._stateStyles=r}match(t,e,r,s){return function O6(n,t,e,r,s){return n.some(o=>o(t,e,r,s))}(this.ast.matchers,t,e,r,s)}buildStyles(t,e,r){let s=this._stateStyles.get("*");return void 0!==t&&(s=this._stateStyles.get(null==t?void 0:t.toString())||s),s?s.buildStyles(e,r):new Map}build(t,e,r,s,o,l,u,d,h,p){var g;const y=[],b=this.ast.options&&this.ast.options.params||vI,I=this.buildStyles(r,u&&u.params||vI,y),S=d&&d.params||vI,T=this.buildStyles(s,S,y),O=new Set,V=new Map,U=new Map,j="void"===s,te={params:F6(S,b),delay:null===(g=this.ast.options)||void 0===g?void 0:g.delay},se=p?[]:mI(t,e,this.ast.animation,o,l,I,T,te,h,y);let le=0;if(se.forEach(be=>{le=Math.max(be.duration+be.delay,le)}),y.length)return EA(e,this._triggerName,r,s,j,I,T,[],[],V,U,le,y);se.forEach(be=>{const Me=be.element,He=Ri(V,Me,new Set);be.preStyleProps.forEach(je=>He.add(je));const We=Ri(U,Me,new Set);be.postStyleProps.forEach(je=>We.add(je)),Me!==e&&O.add(Me)});const Ce=bx(O.values());return EA(e,this._triggerName,r,s,j,I,T,se,Ce,V,U,le)}}function F6(n,t){const e=zy(t);for(const r in n)n.hasOwnProperty(r)&&null!=n[r]&&(e[r]=n[r]);return e}class $6{constructor(t,e,r){this.styles=t,this.defaultParams=e,this.normalizer=r}buildStyles(t,e){const r=new Map,s=zy(this.defaultParams);return Object.keys(t).forEach(o=>{const l=t[o];null!==l&&(s[o]=l)}),this.styles.styles.forEach(o=>{"string"!=typeof o&&o.forEach((l,u)=>{l&&(l=Wy(l,s,e));const d=this.normalizer.normalizePropertyName(u,e);l=this.normalizer.normalizeStyleValue(u,d,l,e),r.set(d,l)})}),r}}class L6{constructor(t,e,r){this.name=t,this.ast=e,this._normalizer=r,this.transitionFactories=[],this.states=new Map,e.states.forEach(s=>{this.states.set(s.name,new $6(s.style,s.options&&s.options.params||{},r))}),DA(this.states,"true","1"),DA(this.states,"false","0"),e.transitions.forEach(s=>{this.transitionFactories.push(new IA(t,s,this.states))}),this.fallbackTransition=function B6(n,t,e){return new IA(n,{type:1,animation:{type:2,steps:[],options:null},matchers:[(l,u)=>!0],options:null,queryCount:0,depCount:0},t)}(t,this.states)}get containsQueries(){return this.ast.queryCount>0}matchTransition(t,e,r,s){return this.transitionFactories.find(l=>l.match(t,e,r,s))||null}matchStyles(t,e,r){return this.fallbackTransition.buildStyles(t,e,r)}}function DA(n,t,e){n.has(t)?n.has(e)||n.set(e,n.get(t)):n.has(e)&&n.set(t,n.get(e))}const V6=new Ex;class U6{constructor(t,e,r){this.bodyNode=t,this._driver=e,this._normalizer=r,this._animations=new Map,this._playersById=new Map,this.players=[]}register(t,e){const r=[],o=hI(this._driver,e,r,[]);if(r.length)throw function UG(n){return new K.vHH(3503,!1)}();this._animations.set(t,o)}_buildPlayer(t,e,r){const s=t.element,o=oA(0,this._normalizer,0,t.keyframes,e,r);return this._driver.animate(s,o,t.duration,t.delay,t.easing,[],!0)}create(t,e,r={}){const s=[],o=this._animations.get(t);let l;const u=new Map;if(o?(l=mI(this._driver,e,o,aI,mx,new Map,new Map,r,V6,s),l.forEach(p=>{const g=Ri(u,p.element,new Map);p.postStyleProps.forEach(y=>g.set(y,null))})):(s.push(function zG(){return new K.vHH(3300,!1)}()),l=[]),s.length)throw function HG(n){return new K.vHH(3504,!1)}();u.forEach((p,g)=>{p.forEach((y,b)=>{p.set(b,this._driver.computeStyle(g,b,jc))})});const h=ad(l.map(p=>{const g=u.get(p.element);return this._buildPlayer(p,new Map,g)}));return this._playersById.set(t,h),h.onDestroy(()=>this.destroy(t)),this.players.push(h),h}destroy(t){const e=this._getPlayer(t);e.destroy(),this._playersById.delete(t);const r=this.players.indexOf(e);r>=0&&this.players.splice(r,1)}_getPlayer(t){const e=this._playersById.get(t);if(!e)throw function WG(n){return new K.vHH(3301,!1)}();return e}listen(t,e,r,s){const o=rI(e,"","","");return tI(this._getPlayer(t),r,o,s),()=>{}}command(t,e,r,s){if("register"==r)return void this.register(t,s[0]);if("create"==r)return void this.create(t,e,s[0]||{});const o=this._getPlayer(t);switch(r){case"play":o.play();break;case"pause":o.pause();break;case"reset":o.reset();break;case"restart":o.restart();break;case"finish":o.finish();break;case"init":o.init();break;case"setPosition":o.setPosition(parseFloat(s[0]));break;case"destroy":this.destroy(t)}}}const TA="ng-animate-queued",bI="ng-animate-disabled",G6=[],NA={namespaceId:"",setForRemoval:!1,setForMove:!1,hasAnimation:!1,removedBeforeQueried:!1},K6={namespaceId:"",setForMove:!1,setForRemoval:!1,hasAnimation:!1,removedBeforeQueried:!0},pa="__ng_removed";class _I{constructor(t,e=""){this.namespaceId=e;const r=t&&t.hasOwnProperty("value");if(this.value=function Z6(n){return null!=n?n:null}(r?t.value:t),r){const o=zy(t);delete o.value,this.options=o}else this.options={};this.options.params||(this.options.params={})}get params(){return this.options.params}absorbOptions(t){const e=t.params;if(e){const r=this.options.params;Object.keys(e).forEach(s=>{null==r[s]&&(r[s]=e[s])})}}}const jy="void",xI=new _I(jy);class q6{constructor(t,e,r){this.id=t,this.hostElement=e,this._engine=r,this.players=[],this._triggers=new Map,this._queue=[],this._elementListeners=new Map,this._hostClassName="ng-tns-"+t,ma(e,this._hostClassName)}listen(t,e,r,s){if(!this._triggers.has(e))throw function jG(n,t){return new K.vHH(3302,!1)}();if(null==r||0==r.length)throw function GG(n){return new K.vHH(3303,!1)}();if(!function Q6(n){return"start"==n||"done"==n}(r))throw function KG(n,t){return new K.vHH(3400,!1)}();const o=Ri(this._elementListeners,t,[]),l={name:e,phase:r,callback:s};o.push(l);const u=Ri(this._engine.statesByElement,t,new Map);return u.has(e)||(ma(t,gx),ma(t,gx+"-"+e),u.set(e,xI)),()=>{this._engine.afterFlush(()=>{const d=o.indexOf(l);d>=0&&o.splice(d,1),this._triggers.has(e)||u.delete(e)})}}register(t,e){return!this._triggers.has(t)&&(this._triggers.set(t,e),!0)}_getTrigger(t){const e=this._triggers.get(t);if(!e)throw function qG(n){return new K.vHH(3401,!1)}();return e}trigger(t,e,r,s=!0){const o=this._getTrigger(e),l=new wI(this.id,e,t);let u=this._engine.statesByElement.get(t);u||(ma(t,gx),ma(t,gx+"-"+e),this._engine.statesByElement.set(t,u=new Map));let d=u.get(e);const h=new _I(r,this.id);if(!(r&&r.hasOwnProperty("value"))&&d&&h.absorbOptions(d.options),u.set(e,h),d||(d=xI),h.value!==jy&&d.value===h.value){if(!function t5(n,t){const e=Object.keys(n),r=Object.keys(t);if(e.length!=r.length)return!1;for(let s=0;s<e.length;s++){const o=e[s];if(!t.hasOwnProperty(o)||n[o]!==t[o])return!1}return!0}(d.params,h.params)){const I=[],S=o.matchStyles(d.value,d.params,I),T=o.matchStyles(h.value,h.params,I);I.length?this._engine.reportError(I):this._engine.afterFlush(()=>{Rh(t,S),Zl(t,T)})}return}const y=Ri(this._engine.playersByElement,t,[]);y.forEach(I=>{I.namespaceId==this.id&&I.triggerName==e&&I.queued&&I.destroy()});let b=o.matchTransition(d.value,h.value,t,h.params),_=!1;if(!b){if(!s)return;b=o.fallbackTransition,_=!0}return this._engine.totalQueuedPlayers++,this._queue.push({element:t,triggerName:e,transition:b,fromState:d,toState:h,player:l,isFallbackTransition:_}),_||(ma(t,TA),l.onStart(()=>{Fp(t,TA)})),l.onDone(()=>{let I=this.players.indexOf(l);I>=0&&this.players.splice(I,1);const S=this._engine.playersByElement.get(t);if(S){let T=S.indexOf(l);T>=0&&S.splice(T,1)}}),this.players.push(l),y.push(l),l}deregister(t){this._triggers.delete(t),this._engine.statesByElement.forEach(e=>e.delete(t)),this._elementListeners.forEach((e,r)=>{this._elementListeners.set(r,e.filter(s=>s.name!=t))})}clearElementCache(t){this._engine.statesByElement.delete(t),this._elementListeners.delete(t);const e=this._engine.playersByElement.get(t);e&&(e.forEach(r=>r.destroy()),this._engine.playersByElement.delete(t))}_signalRemovalForInnerTriggers(t,e){const r=this._engine.driver.query(t,yx,!0);r.forEach(s=>{if(s[pa])return;const o=this._engine.fetchNamespacesByElement(s);o.size?o.forEach(l=>l.triggerLeaveAnimation(s,e,!1,!0)):this.clearElementCache(s)}),this._engine.afterFlushAnimationsDone(()=>r.forEach(s=>this.clearElementCache(s)))}triggerLeaveAnimation(t,e,r,s){const o=this._engine.statesByElement.get(t),l=new Map;if(o){const u=[];if(o.forEach((d,h)=>{if(l.set(h,d.value),this._triggers.has(h)){const p=this.trigger(t,h,jy,s);p&&u.push(p)}}),u.length)return this._engine.markElementAsRemoved(this.id,t,!0,e,l),r&&ad(u).onDone(()=>this._engine.processLeaveNode(t)),!0}return!1}prepareLeaveAnimationListeners(t){const e=this._elementListeners.get(t),r=this._engine.statesByElement.get(t);if(e&&r){const s=new Set;e.forEach(o=>{const l=o.name;if(s.has(l))return;s.add(l);const d=this._triggers.get(l).fallbackTransition,h=r.get(l)||xI,p=new _I(jy),g=new wI(this.id,l,t);this._engine.totalQueuedPlayers++,this._queue.push({element:t,triggerName:l,transition:d,fromState:h,toState:p,player:g,isFallbackTransition:!0})})}}removeNode(t,e){const r=this._engine;if(t.childElementCount&&this._signalRemovalForInnerTriggers(t,e),this.triggerLeaveAnimation(t,e,!0))return;let s=!1;if(r.totalAnimations){const o=r.players.length?r.playersByQueriedElement.get(t):[];if(o&&o.length)s=!0;else{let l=t;for(;l=l.parentNode;)if(r.statesByElement.get(l)){s=!0;break}}}if(this.prepareLeaveAnimationListeners(t),s)r.markElementAsRemoved(this.id,t,!1,e);else{const o=t[pa];(!o||o===NA)&&(r.afterFlush(()=>this.clearElementCache(t)),r.destroyInnerAnimations(t),r._onRemovalComplete(t,e))}}insertNode(t,e){ma(t,this._hostClassName)}drainQueuedTransitions(t){const e=[];return this._queue.forEach(r=>{const s=r.player;if(s.destroyed)return;const o=r.element,l=this._elementListeners.get(o);l&&l.forEach(u=>{if(u.name==r.triggerName){const d=rI(o,r.triggerName,r.fromState.value,r.toState.value);d._data=t,tI(r.player,u.phase,d,u.callback)}}),s.markedForDestroy?this._engine.afterFlush(()=>{s.destroy()}):e.push(r)}),this._queue=[],e.sort((r,s)=>{const o=r.transition.ast.depCount,l=s.transition.ast.depCount;return 0==o||0==l?o-l:this._engine.driver.containsElement(r.element,s.element)?1:-1})}destroy(t){this.players.forEach(e=>e.destroy()),this._signalRemovalForInnerTriggers(this.hostElement,t)}elementContainsData(t){let e=!1;return this._elementListeners.has(t)&&(e=!0),e=!!this._queue.find(r=>r.element===t)||e,e}}class X6{constructor(t,e,r){this.bodyNode=t,this.driver=e,this._normalizer=r,this.players=[],this.newHostElements=new Map,this.playersByElement=new Map,this.playersByQueriedElement=new Map,this.statesByElement=new Map,this.disabledNodes=new Set,this.totalAnimations=0,this.totalQueuedPlayers=0,this._namespaceLookup={},this._namespaceList=[],this._flushFns=[],this._whenQuietFns=[],this.namespacesByHostElement=new Map,this.collectedEnterElements=[],this.collectedLeaveElements=[],this.onRemovalComplete=(s,o)=>{}}_onRemovalComplete(t,e){this.onRemovalComplete(t,e)}get queuedPlayers(){const t=[];return this._namespaceList.forEach(e=>{e.players.forEach(r=>{r.queued&&t.push(r)})}),t}createNamespace(t,e){const r=new q6(t,e,this);return this.bodyNode&&this.driver.containsElement(this.bodyNode,e)?this._balanceNamespaceList(r,e):(this.newHostElements.set(e,r),this.collectEnterElement(e)),this._namespaceLookup[t]=r}_balanceNamespaceList(t,e){const r=this._namespaceList,s=this.namespacesByHostElement;if(r.length-1>=0){let l=!1,u=this.driver.getParentElement(e);for(;u;){const d=s.get(u);if(d){const h=r.indexOf(d);r.splice(h+1,0,t),l=!0;break}u=this.driver.getParentElement(u)}l||r.unshift(t)}else r.push(t);return s.set(e,t),t}register(t,e){let r=this._namespaceLookup[t];return r||(r=this.createNamespace(t,e)),r}registerTrigger(t,e,r){let s=this._namespaceLookup[t];s&&s.register(e,r)&&this.totalAnimations++}destroy(t,e){if(!t)return;const r=this._fetchNamespace(t);this.afterFlush(()=>{this.namespacesByHostElement.delete(r.hostElement),delete this._namespaceLookup[t];const s=this._namespaceList.indexOf(r);s>=0&&this._namespaceList.splice(s,1)}),this.afterFlushAnimationsDone(()=>r.destroy(e))}_fetchNamespace(t){return this._namespaceLookup[t]}fetchNamespacesByElement(t){const e=new Set,r=this.statesByElement.get(t);if(r)for(let s of r.values())if(s.namespaceId){const o=this._fetchNamespace(s.namespaceId);o&&e.add(o)}return e}trigger(t,e,r,s){if(Tx(e)){const o=this._fetchNamespace(t);if(o)return o.trigger(e,r,s),!0}return!1}insertNode(t,e,r,s){if(!Tx(e))return;const o=e[pa];if(o&&o.setForRemoval){o.setForRemoval=!1,o.setForMove=!0;const l=this.collectedLeaveElements.indexOf(e);l>=0&&this.collectedLeaveElements.splice(l,1)}if(t){const l=this._fetchNamespace(t);l&&l.insertNode(e,r)}s&&this.collectEnterElement(e)}collectEnterElement(t){this.collectedEnterElements.push(t)}markElementAsDisabled(t,e){e?this.disabledNodes.has(t)||(this.disabledNodes.add(t),ma(t,bI)):this.disabledNodes.has(t)&&(this.disabledNodes.delete(t),Fp(t,bI))}removeNode(t,e,r,s){if(Tx(e)){const o=t?this._fetchNamespace(t):null;if(o?o.removeNode(e,s):this.markElementAsRemoved(t,e,!1,s),r){const l=this.namespacesByHostElement.get(e);l&&l.id!==t&&l.removeNode(e,s)}}else this._onRemovalComplete(e,s)}markElementAsRemoved(t,e,r,s,o){this.collectedLeaveElements.push(e),e[pa]={namespaceId:t,setForRemoval:s,hasAnimation:r,removedBeforeQueried:!1,previousTriggersValues:o}}listen(t,e,r,s,o){return Tx(e)?this._fetchNamespace(t).listen(e,r,s,o):()=>{}}_buildInstruction(t,e,r,s,o){return t.transition.build(this.driver,t.element,t.fromState.value,t.toState.value,r,s,t.fromState.options,t.toState.options,e,o)}destroyInnerAnimations(t){let e=this.driver.query(t,yx,!0);e.forEach(r=>this.destroyActiveAnimationsForElement(r)),0!=this.playersByQueriedElement.size&&(e=this.driver.query(t,lI,!0),e.forEach(r=>this.finishActiveQueriedAnimationOnElement(r)))}destroyActiveAnimationsForElement(t){const e=this.playersByElement.get(t);e&&e.forEach(r=>{r.queued?r.markedForDestroy=!0:r.destroy()})}finishActiveQueriedAnimationOnElement(t){const e=this.playersByQueriedElement.get(t);e&&e.forEach(r=>r.finish())}whenRenderingDone(){return new Promise(t=>{if(this.players.length)return ad(this.players).onDone(()=>t());t()})}processLeaveNode(t){var e;const r=t[pa];if(r&&r.setForRemoval){if(t[pa]=NA,r.namespaceId){this.destroyInnerAnimations(t);const s=this._fetchNamespace(r.namespaceId);s&&s.clearElementCache(t)}this._onRemovalComplete(t,r.setForRemoval)}!(null===(e=t.classList)||void 0===e)&&e.contains(bI)&&this.markElementAsDisabled(t,!1),this.driver.query(t,".ng-animate-disabled",!0).forEach(s=>{this.markElementAsDisabled(s,!1)})}flush(t=-1){let e=[];if(this.newHostElements.size&&(this.newHostElements.forEach((r,s)=>this._balanceNamespaceList(r,s)),this.newHostElements.clear()),this.totalAnimations&&this.collectedEnterElements.length)for(let r=0;r<this.collectedEnterElements.length;r++)ma(this.collectedEnterElements[r],"ng-star-inserted");if(this._namespaceList.length&&(this.totalQueuedPlayers||this.collectedLeaveElements.length)){const r=[];try{e=this._flushAnimations(r,t)}finally{for(let s=0;s<r.length;s++)r[s]()}}else for(let r=0;r<this.collectedLeaveElements.length;r++)this.processLeaveNode(this.collectedLeaveElements[r]);if(this.totalQueuedPlayers=0,this.collectedEnterElements.length=0,this.collectedLeaveElements.length=0,this._flushFns.forEach(r=>r()),this._flushFns=[],this._whenQuietFns.length){const r=this._whenQuietFns;this._whenQuietFns=[],e.length?ad(e).onDone(()=>{r.forEach(s=>s())}):r.forEach(s=>s())}}reportError(t){throw function XG(n){return new K.vHH(3402,!1)}()}_flushAnimations(t,e){const r=new Ex,s=[],o=new Map,l=[],u=new Map,d=new Map,h=new Map,p=new Set;this.disabledNodes.forEach(Se=>{p.add(Se);const ke=this.driver.query(Se,".ng-animate-queued",!0);for(let De=0;De<ke.length;De++)p.add(ke[De])});const g=this.bodyNode,y=Array.from(this.statesByElement.keys()),b=RA(y,this.collectedEnterElements),_=new Map;let I=0;b.forEach((Se,ke)=>{const De=aI+I++;_.set(ke,De),Se.forEach(Be=>ma(Be,De))});const S=[],T=new Set,O=new Set;for(let Se=0;Se<this.collectedLeaveElements.length;Se++){const ke=this.collectedLeaveElements[Se],De=ke[pa];De&&De.setForRemoval&&(S.push(ke),T.add(ke),De.hasAnimation?this.driver.query(ke,".ng-star-inserted",!0).forEach(Be=>T.add(Be)):O.add(ke))}const V=new Map,U=RA(y,Array.from(T));U.forEach((Se,ke)=>{const De=mx+I++;V.set(ke,De),Se.forEach(Be=>ma(Be,De))}),t.push(()=>{b.forEach((Se,ke)=>{const De=_.get(ke);Se.forEach(Be=>Fp(Be,De))}),U.forEach((Se,ke)=>{const De=V.get(ke);Se.forEach(Be=>Fp(Be,De))}),S.forEach(Se=>{this.processLeaveNode(Se)})});const j=[],te=[];for(let Se=this._namespaceList.length-1;Se>=0;Se--)this._namespaceList[Se].drainQueuedTransitions(e).forEach(De=>{const Be=De.player,rt=De.element;if(j.push(Be),this.collectedEnterElements.length){const Vt=rt[pa];if(Vt&&Vt.setForMove){if(Vt.previousTriggersValues&&Vt.previousTriggersValues.has(De.triggerName)){const tn=Vt.previousTriggersValues.get(De.triggerName),Yt=this.statesByElement.get(De.element);if(Yt&&Yt.has(De.triggerName)){const vn=Yt.get(De.triggerName);vn.value=tn,Yt.set(De.triggerName,vn)}}return void Be.destroy()}}const pt=!g||!this.driver.containsElement(g,rt),wt=V.get(rt),gt=_.get(rt),yt=this._buildInstruction(De,r,gt,wt,pt);if(yt.errors&&yt.errors.length)return void te.push(yt);if(pt)return Be.onStart(()=>Rh(rt,yt.fromStyles)),Be.onDestroy(()=>Zl(rt,yt.toStyles)),void s.push(Be);if(De.isFallbackTransition)return Be.onStart(()=>Rh(rt,yt.fromStyles)),Be.onDestroy(()=>Zl(rt,yt.toStyles)),void s.push(Be);const It=[];yt.timelines.forEach(Vt=>{Vt.stretchStartingKeyframe=!0,this.disabledNodes.has(Vt.element)||It.push(Vt)}),yt.timelines=It,r.append(rt,yt.timelines),l.push({instruction:yt,player:Be,element:rt}),yt.queriedElements.forEach(Vt=>Ri(u,Vt,[]).push(Be)),yt.preStyleProps.forEach((Vt,tn)=>{if(Vt.size){let Yt=d.get(tn);Yt||d.set(tn,Yt=new Set),Vt.forEach((vn,wn)=>Yt.add(wn))}}),yt.postStyleProps.forEach((Vt,tn)=>{let Yt=h.get(tn);Yt||h.set(tn,Yt=new Set),Vt.forEach((vn,wn)=>Yt.add(wn))})});if(te.length){const Se=[];te.forEach(ke=>{Se.push(function YG(n,t){return new K.vHH(3505,!1)}())}),j.forEach(ke=>ke.destroy()),this.reportError(Se)}const se=new Map,le=new Map;l.forEach(Se=>{const ke=Se.element;r.has(ke)&&(le.set(ke,ke),this._beforeAnimationBuild(Se.player.namespaceId,Se.instruction,se))}),s.forEach(Se=>{const ke=Se.element;this._getPreviousPlayers(ke,!1,Se.namespaceId,Se.triggerName,null).forEach(Be=>{Ri(se,ke,[]).push(Be),Be.destroy()})});const Ce=S.filter(Se=>OA(Se,d,h)),be=new Map;AA(be,this.driver,O,h,jc).forEach(Se=>{OA(Se,d,h)&&Ce.push(Se)});const He=new Map;b.forEach((Se,ke)=>{AA(He,this.driver,new Set(Se),d,"!")}),Ce.forEach(Se=>{var ke,De;const Be=be.get(Se),rt=He.get(Se);be.set(Se,new Map([...Array.from(null!==(ke=null==Be?void 0:Be.entries())&&void 0!==ke?ke:[]),...Array.from(null!==(De=null==rt?void 0:rt.entries())&&void 0!==De?De:[])]))});const We=[],je=[],Ke={};l.forEach(Se=>{const{element:ke,player:De,instruction:Be}=Se;if(r.has(ke)){if(p.has(ke))return De.onDestroy(()=>Zl(ke,Be.toStyles)),De.disabled=!0,De.overrideTotalTime(Be.totalTime),void s.push(De);let rt=Ke;if(le.size>1){let wt=ke;const gt=[];for(;wt=wt.parentNode;){const yt=le.get(wt);if(yt){rt=yt;break}gt.push(wt)}gt.forEach(yt=>le.set(yt,rt))}const pt=this._buildAnimation(De.namespaceId,Be,se,o,He,be);if(De.setRealPlayer(pt),rt===Ke)We.push(De);else{const wt=this.playersByElement.get(rt);wt&&wt.length&&(De.parentPlayer=ad(wt)),s.push(De)}}else Rh(ke,Be.fromStyles),De.onDestroy(()=>Zl(ke,Be.toStyles)),je.push(De),p.has(ke)&&s.push(De)}),je.forEach(Se=>{const ke=o.get(Se.element);if(ke&&ke.length){const De=ad(ke);Se.setRealPlayer(De)}}),s.forEach(Se=>{Se.parentPlayer?Se.syncPlayerEvents(Se.parentPlayer):Se.destroy()});for(let Se=0;Se<S.length;Se++){const ke=S[Se],De=ke[pa];if(Fp(ke,mx),De&&De.hasAnimation)continue;let Be=[];if(u.size){let pt=u.get(ke);pt&&pt.length&&Be.push(...pt);let wt=this.driver.query(ke,lI,!0);for(let gt=0;gt<wt.length;gt++){let yt=u.get(wt[gt]);yt&&yt.length&&Be.push(...yt)}}const rt=Be.filter(pt=>!pt.destroyed);rt.length?J6(this,ke,rt):this.processLeaveNode(ke)}return S.length=0,We.forEach(Se=>{this.players.push(Se),Se.onDone(()=>{Se.destroy();const ke=this.players.indexOf(Se);this.players.splice(ke,1)}),Se.play()}),We}elementContainsData(t,e){let r=!1;const s=e[pa];return s&&s.setForRemoval&&(r=!0),this.playersByElement.has(e)&&(r=!0),this.playersByQueriedElement.has(e)&&(r=!0),this.statesByElement.has(e)&&(r=!0),this._fetchNamespace(t).elementContainsData(e)||r}afterFlush(t){this._flushFns.push(t)}afterFlushAnimationsDone(t){this._whenQuietFns.push(t)}_getPreviousPlayers(t,e,r,s,o){let l=[];if(e){const u=this.playersByQueriedElement.get(t);u&&(l=u)}else{const u=this.playersByElement.get(t);if(u){const d=!o||o==jy;u.forEach(h=>{h.queued||!d&&h.triggerName!=s||l.push(h)})}}return(r||s)&&(l=l.filter(u=>!(r&&r!=u.namespaceId||s&&s!=u.triggerName))),l}_beforeAnimationBuild(t,e,r){const o=e.element,l=e.isRemovalTransition?void 0:t,u=e.isRemovalTransition?void 0:e.triggerName;for(const d of e.timelines){const h=d.element,p=h!==o,g=Ri(r,h,[]);this._getPreviousPlayers(h,p,l,u,e.toState).forEach(b=>{const _=b.getRealPlayer();_.beforeDestroy&&_.beforeDestroy(),b.destroy(),g.push(b)})}Rh(o,e.fromStyles)}_buildAnimation(t,e,r,s,o,l){const u=e.triggerName,d=e.element,h=[],p=new Set,g=new Set,y=e.timelines.map(_=>{const I=_.element;p.add(I);const S=I[pa];if(S&&S.removedBeforeQueried)return new Uy(_.duration,_.delay);const T=I!==d,O=function e5(n){const t=[];return MA(n,t),t}((r.get(I)||G6).map(se=>se.getRealPlayer())).filter(se=>!!se.element&&se.element===I),V=o.get(I),U=l.get(I),j=oA(0,this._normalizer,0,_.keyframes,V,U),te=this._buildPlayer(_,j,O);if(_.subTimeline&&s&&g.add(I),T){const se=new wI(t,u,I);se.setRealPlayer(te),h.push(se)}return te});h.forEach(_=>{Ri(this.playersByQueriedElement,_.element,[]).push(_),_.onDone(()=>function Y6(n,t,e){let r=n.get(t);if(r){if(r.length){const s=r.indexOf(e);r.splice(s,1)}0==r.length&&n.delete(t)}return r}(this.playersByQueriedElement,_.element,_))}),p.forEach(_=>ma(_,pA));const b=ad(y);return b.onDestroy(()=>{p.forEach(_=>Fp(_,pA)),Zl(d,e.toStyles)}),g.forEach(_=>{Ri(s,_,[]).push(b)}),b}_buildPlayer(t,e,r){return e.length>0?this.driver.animate(t.element,e,t.duration,t.delay,t.easing,r):new Uy(t.duration,t.delay)}}class wI{constructor(t,e,r){this.namespaceId=t,this.triggerName=e,this.element=r,this._player=new Uy,this._containsRealPlayer=!1,this._queuedCallbacks=new Map,this.destroyed=!1,this.markedForDestroy=!1,this.disabled=!1,this.queued=!0,this.totalTime=0}setRealPlayer(t){this._containsRealPlayer||(this._player=t,this._queuedCallbacks.forEach((e,r)=>{e.forEach(s=>tI(t,r,void 0,s))}),this._queuedCallbacks.clear(),this._containsRealPlayer=!0,this.overrideTotalTime(t.totalTime),this.queued=!1)}getRealPlayer(){return this._player}overrideTotalTime(t){this.totalTime=t}syncPlayerEvents(t){const e=this._player;e.triggerCallback&&t.onStart(()=>e.triggerCallback("start")),t.onDone(()=>this.finish()),t.onDestroy(()=>this.destroy())}_queueEvent(t,e){Ri(this._queuedCallbacks,t,[]).push(e)}onDone(t){this.queued&&this._queueEvent("done",t),this._player.onDone(t)}onStart(t){this.queued&&this._queueEvent("start",t),this._player.onStart(t)}onDestroy(t){this.queued&&this._queueEvent("destroy",t),this._player.onDestroy(t)}init(){this._player.init()}hasStarted(){return!this.queued&&this._player.hasStarted()}play(){!this.queued&&this._player.play()}pause(){!this.queued&&this._player.pause()}restart(){!this.queued&&this._player.restart()}finish(){this._player.finish()}destroy(){this.destroyed=!0,this._player.destroy()}reset(){!this.queued&&this._player.reset()}setPosition(t){this.queued||this._player.setPosition(t)}getPosition(){return this.queued?0:this._player.getPosition()}triggerCallback(t){const e=this._player;e.triggerCallback&&e.triggerCallback(t)}}function Tx(n){return n&&1===n.nodeType}function kA(n,t){const e=n.style.display;return n.style.display=null!=t?t:"none",e}function AA(n,t,e,r,s){const o=[];e.forEach(d=>o.push(kA(d)));const l=[];r.forEach((d,h)=>{const p=new Map;d.forEach(g=>{const y=t.computeStyle(h,g,s);p.set(g,y),(!y||0==y.length)&&(h[pa]=K6,l.push(h))}),n.set(h,p)});let u=0;return e.forEach(d=>kA(d,o[u++])),l}function RA(n,t){const e=new Map;if(n.forEach(u=>e.set(u,[])),0==t.length)return e;const s=new Set(t),o=new Map;function l(u){if(!u)return 1;let d=o.get(u);if(d)return d;const h=u.parentNode;return d=e.has(h)?h:s.has(h)?1:l(h),o.set(u,d),d}return t.forEach(u=>{const d=l(u);1!==d&&e.get(d).push(u)}),e}function ma(n,t){var e;null===(e=n.classList)||void 0===e||e.add(t)}function Fp(n,t){var e;null===(e=n.classList)||void 0===e||e.remove(t)}function J6(n,t,e){ad(e).onDone(()=>n.processLeaveNode(t))}function MA(n,t){for(let e=0;e<n.length;e++){const r=n[e];r instanceof rA?MA(r.players,t):t.push(r)}}function OA(n,t,e){const r=e.get(n);if(!r)return!1;let s=t.get(n);return s?r.forEach(o=>s.add(o)):t.set(n,r),e.delete(n),!0}class Nx{constructor(t,e,r){this.bodyNode=t,this._driver=e,this._normalizer=r,this._triggerCache={},this.onRemovalComplete=(s,o)=>{},this._transitionEngine=new X6(t,e,r),this._timelineEngine=new U6(t,e,r),this._transitionEngine.onRemovalComplete=(s,o)=>this.onRemovalComplete(s,o)}registerTrigger(t,e,r,s,o){const l=t+"-"+s;let u=this._triggerCache[l];if(!u){const d=[],p=hI(this._driver,o,d,[]);if(d.length)throw function BG(n,t){return new K.vHH(3404,!1)}();u=function P6(n,t,e){return new L6(n,t,e)}(s,p,this._normalizer),this._triggerCache[l]=u}this._transitionEngine.registerTrigger(e,s,u)}register(t,e){this._transitionEngine.register(t,e)}destroy(t,e){this._transitionEngine.destroy(t,e)}onInsert(t,e,r,s){this._transitionEngine.insertNode(t,e,r,s)}onRemove(t,e,r,s){this._transitionEngine.removeNode(t,e,s||!1,r)}disableAnimations(t,e){this._transitionEngine.markElementAsDisabled(t,e)}process(t,e,r,s){if("@"==r.charAt(0)){const[o,l]=iA(r);this._timelineEngine.command(o,e,l,s)}else this._transitionEngine.trigger(t,e,r,s)}listen(t,e,r,s,o){if("@"==r.charAt(0)){const[l,u]=iA(r);return this._timelineEngine.listen(l,e,u,o)}return this._transitionEngine.listen(t,e,r,s,o)}flush(t=-1){this._transitionEngine.flush(t)}get players(){return this._transitionEngine.players.concat(this._timelineEngine.players)}whenRenderingDone(){return this._transitionEngine.whenRenderingDone()}}let r5=(()=>{class n{constructor(e,r,s){this._element=e,this._startStyles=r,this._endStyles=s,this._state=0;let o=n.initialStylesByElement.get(e);o||n.initialStylesByElement.set(e,o=new Map),this._initialStyles=o}start(){this._state<1&&(this._startStyles&&Zl(this._element,this._startStyles,this._initialStyles),this._state=1)}finish(){this.start(),this._state<2&&(Zl(this._element,this._initialStyles),this._endStyles&&(Zl(this._element,this._endStyles),this._endStyles=null),this._state=1)}destroy(){this.finish(),this._state<3&&(n.initialStylesByElement.delete(this._element),this._startStyles&&(Rh(this._element,this._startStyles),this._endStyles=null),this._endStyles&&(Rh(this._element,this._endStyles),this._endStyles=null),Zl(this._element,this._initialStyles),this._state=3)}}return n.initialStylesByElement=new WeakMap,n})();function CI(n){let t=null;return n.forEach((e,r)=>{(function s5(n){return"display"===n||"position"===n})(r)&&(t=t||new Map,t.set(r,e))}),t}class FA{constructor(t,e,r,s){this.element=t,this.keyframes=e,this.options=r,this._specialStyles=s,this._onDoneFns=[],this._onStartFns=[],this._onDestroyFns=[],this._initialized=!1,this._finished=!1,this._started=!1,this._destroyed=!1,this._originalOnDoneFns=[],this._originalOnStartFns=[],this.time=0,this.parentPlayer=null,this.currentSnapshot=new Map,this._duration=r.duration,this._delay=r.delay||0,this.time=this._duration+this._delay}_onFinish(){this._finished||(this._finished=!0,this._onDoneFns.forEach(t=>t()),this._onDoneFns=[])}init(){this._buildPlayer(),this._preparePlayerBeforeStart()}_buildPlayer(){if(this._initialized)return;this._initialized=!0;const t=this.keyframes;this.domPlayer=this._triggerWebAnimation(this.element,t,this.options),this._finalKeyframe=t.length?t[t.length-1]:new Map,this.domPlayer.addEventListener("finish",()=>this._onFinish())}_preparePlayerBeforeStart(){this._delay?this._resetDomPlayerState():this.domPlayer.pause()}_convertKeyframesToObject(t){const e=[];return t.forEach(r=>{e.push(Object.fromEntries(r))}),e}_triggerWebAnimation(t,e,r){return t.animate(this._convertKeyframesToObject(e),r)}onStart(t){this._originalOnStartFns.push(t),this._onStartFns.push(t)}onDone(t){this._originalOnDoneFns.push(t),this._onDoneFns.push(t)}onDestroy(t){this._onDestroyFns.push(t)}play(){this._buildPlayer(),this.hasStarted()||(this._onStartFns.forEach(t=>t()),this._onStartFns=[],this._started=!0,this._specialStyles&&this._specialStyles.start()),this.domPlayer.play()}pause(){this.init(),this.domPlayer.pause()}finish(){this.init(),this._specialStyles&&this._specialStyles.finish(),this._onFinish(),this.domPlayer.finish()}reset(){this._resetDomPlayerState(),this._destroyed=!1,this._finished=!1,this._started=!1,this._onStartFns=this._originalOnStartFns,this._onDoneFns=this._originalOnDoneFns}_resetDomPlayerState(){this.domPlayer&&this.domPlayer.cancel()}restart(){this.reset(),this.play()}hasStarted(){return this._started}destroy(){this._destroyed||(this._destroyed=!0,this._resetDomPlayerState(),this._onFinish(),this._specialStyles&&this._specialStyles.destroy(),this._onDestroyFns.forEach(t=>t()),this._onDestroyFns=[])}setPosition(t){void 0===this.domPlayer&&this.init(),this.domPlayer.currentTime=t*this.time}getPosition(){return this.domPlayer.currentTime/this.time}get totalTime(){return this._delay+this._duration}beforeDestroy(){const t=new Map;this.hasStarted()&&this._finalKeyframe.forEach((r,s)=>{"offset"!==s&&t.set(s,this._finished?r:_A(this.element,s))}),this.currentSnapshot=t}triggerCallback(t){const e="start"===t?this._onStartFns:this._onDoneFns;e.forEach(r=>r()),e.length=0}}class o5{validateStyleProperty(t){return!0}validateAnimatableStyleProperty(t){return!0}matchesElement(t,e){return!1}containsElement(t,e){return uA(t,e)}getParentElement(t){return oI(t)}query(t,e,r){return dA(t,e,r)}computeStyle(t,e,r){return window.getComputedStyle(t)[e]}animate(t,e,r,s,o,l=[]){const d={duration:r,delay:s,fill:0==s?"both":"forwards"};o&&(d.easing=o);const h=new Map,p=l.filter(b=>b instanceof FA);(function c6(n,t){return 0===n||0===t})(r,s)&&p.forEach(b=>{b.currentSnapshot.forEach((_,I)=>h.set(I,_))});let g=function o6(n){return n.length?n[0]instanceof Map?n:n.map(t=>mA(t)):[]}(e).map(b=>ld(b));g=function u6(n,t,e){if(e.size&&t.length){let r=t[0],s=[];if(e.forEach((o,l)=>{r.has(l)||s.push(l),r.set(l,o)}),s.length)for(let o=1;o<t.length;o++){let l=t[o];s.forEach(u=>l.set(u,_A(n,u)))}}return t}(t,g,h);const y=function n5(n,t){let e=null,r=null;return Array.isArray(t)&&t.length?(e=CI(t[0]),t.length>1&&(r=CI(t[t.length-1]))):t instanceof Map&&(e=CI(t)),e||r?new r5(n,e,r):null}(t,g);return new FA(t,g,d,y)}}let a5=(()=>{class n extends Zk{constructor(e,r){super(),this._nextAnimationId=0,this._renderer=e.createRenderer(r.body,{id:"0",encapsulation:K.ifc.None,styles:[],data:{animation:[]}})}build(e){const r=this._nextAnimationId.toString();this._nextAnimationId++;const s=Array.isArray(e)?Jk(e):e;return $A(this._renderer,null,r,"register",[s]),new l5(r,this._renderer)}}return n.\u0275fac=function(e){return new(e||n)(K.LFG(K.FYo),K.LFG(kh.K0))},n.\u0275prov=K.Yz7({token:n,factory:n.\u0275fac}),n})();class l5 extends class gG{}{constructor(t,e){super(),this._id=t,this._renderer=e}create(t,e){return new c5(this._id,t,e||{},this._renderer)}}class c5{constructor(t,e,r,s){this.id=t,this.element=e,this._renderer=s,this.parentPlayer=null,this._started=!1,this.totalTime=0,this._command("create",r)}_listen(t,e){return this._renderer.listen(this.element,`@@${this.id}:${t}`,e)}_command(t,...e){return $A(this._renderer,this.element,this.id,t,e)}onDone(t){this._listen("done",t)}onStart(t){this._listen("start",t)}onDestroy(t){this._listen("destroy",t)}init(){this._command("init")}hasStarted(){return this._started}play(){this._command("play"),this._started=!0}pause(){this._command("pause")}restart(){this._command("restart")}finish(){this._command("finish")}destroy(){this._command("destroy")}reset(){this._command("reset"),this._started=!1}setPosition(t){this._command("setPosition",t)}getPosition(){var t,e;return null!==(e=null===(t=this._renderer.engine.players[+this.id])||void 0===t?void 0:t.getPosition())&&void 0!==e?e:0}}function $A(n,t,e,r,s){return n.setProperty(t,`@@${e}:${r}`,s)}const PA="@.disabled";let u5=(()=>{class n{constructor(e,r,s){this.delegate=e,this.engine=r,this._zone=s,this._currentId=0,this._microtaskId=1,this._animationCallbacksBuffer=[],this._rendererCache=new Map,this._cdRecurDepth=0,this.promise=Promise.resolve(0),r.onRemovalComplete=(o,l)=>{const u=null==l?void 0:l.parentNode(o);u&&l.removeChild(u,o)}}createRenderer(e,r){const o=this.delegate.createRenderer(e,r);if(!(e&&r&&r.data&&r.data.animation)){let p=this._rendererCache.get(o);return p||(p=new LA("",o,this.engine,()=>this._rendererCache.delete(o)),this._rendererCache.set(o,p)),p}const l=r.id,u=r.id+"-"+this._currentId;this._currentId++,this.engine.register(u,e);const d=p=>{Array.isArray(p)?p.forEach(d):this.engine.registerTrigger(l,u,e,p.name,p)};return r.data.animation.forEach(d),new d5(this,u,o,this.engine)}begin(){this._cdRecurDepth++,this.delegate.begin&&this.delegate.begin()}_scheduleCountTask(){this.promise.then(()=>{this._microtaskId++})}scheduleListenerCallback(e,r,s){e>=0&&e<this._microtaskId?this._zone.run(()=>r(s)):(0==this._animationCallbacksBuffer.length&&Promise.resolve(null).then(()=>{this._zone.run(()=>{this._animationCallbacksBuffer.forEach(o=>{const[l,u]=o;l(u)}),this._animationCallbacksBuffer=[]})}),this._animationCallbacksBuffer.push([r,s]))}end(){this._cdRecurDepth--,0==this._cdRecurDepth&&this._zone.runOutsideAngular(()=>{this._scheduleCountTask(),this.engine.flush(this._microtaskId)}),this.delegate.end&&this.delegate.end()}whenRenderingDone(){return this.engine.whenRenderingDone()}}return n.\u0275fac=function(e){return new(e||n)(K.LFG(K.FYo),K.LFG(Nx),K.LFG(K.R0b))},n.\u0275prov=K.Yz7({token:n,factory:n.\u0275fac}),n})();class LA{constructor(t,e,r,s){this.namespaceId=t,this.delegate=e,this.engine=r,this._onDestroy=s,this.destroyNode=this.delegate.destroyNode?o=>e.destroyNode(o):null}get data(){return this.delegate.data}destroy(){var t;this.engine.destroy(this.namespaceId,this.delegate),this.delegate.destroy(),null===(t=this._onDestroy)||void 0===t||t.call(this)}createElement(t,e){return this.delegate.createElement(t,e)}createComment(t){return this.delegate.createComment(t)}createText(t){return this.delegate.createText(t)}appendChild(t,e){this.delegate.appendChild(t,e),this.engine.onInsert(this.namespaceId,e,t,!1)}insertBefore(t,e,r,s=!0){this.delegate.insertBefore(t,e,r),this.engine.onInsert(this.namespaceId,e,t,s)}removeChild(t,e,r){this.engine.onRemove(this.namespaceId,e,this.delegate,r)}selectRootElement(t,e){return this.delegate.selectRootElement(t,e)}parentNode(t){return this.delegate.parentNode(t)}nextSibling(t){return this.delegate.nextSibling(t)}setAttribute(t,e,r,s){this.delegate.setAttribute(t,e,r,s)}removeAttribute(t,e,r){this.delegate.removeAttribute(t,e,r)}addClass(t,e){this.delegate.addClass(t,e)}removeClass(t,e){this.delegate.removeClass(t,e)}setStyle(t,e,r,s){this.delegate.setStyle(t,e,r,s)}removeStyle(t,e,r){this.delegate.removeStyle(t,e,r)}setProperty(t,e,r){"@"==e.charAt(0)&&e==PA?this.disableAnimations(t,!!r):this.delegate.setProperty(t,e,r)}setValue(t,e){this.delegate.setValue(t,e)}listen(t,e,r){return this.delegate.listen(t,e,r)}disableAnimations(t,e){this.engine.disableAnimations(t,e)}}class d5 extends LA{constructor(t,e,r,s,o){super(e,r,s,o),this.factory=t,this.namespaceId=e}setProperty(t,e,r){"@"==e.charAt(0)?"."==e.charAt(1)&&e==PA?this.disableAnimations(t,r=void 0===r||!!r):this.engine.process(this.namespaceId,t,e.slice(1),r):this.delegate.setProperty(t,e,r)}listen(t,e,r){if("@"==e.charAt(0)){const s=function h5(n){switch(n){case"body":return document.body;case"document":return document;case"window":return window;default:return n}}(t);let o=e.slice(1),l="";return"@"!=o.charAt(0)&&([o,l]=function f5(n){const t=n.indexOf(".");return[n.substring(0,t),n.slice(t+1)]}(o)),this.engine.listen(this.namespaceId,s,o,l,u=>{this.factory.scheduleListenerCallback(u._data||-1,r,u)})}return this.delegate.listen(t,e,r)}}const BA=[{provide:Zk,useClass:a5},{provide:yI,useFactory:function m5(){return new M6}},{provide:Nx,useClass:(()=>{class n extends Nx{constructor(e,r,s,o){super(e.body,r,s)}ngOnDestroy(){this.flush()}}return n.\u0275fac=function(e){return new(e||n)(K.LFG(kh.K0),K.LFG(iI),K.LFG(yI),K.LFG(K.z2F))},n.\u0275prov=K.Yz7({token:n,factory:n.\u0275fac}),n})()},{provide:K.FYo,useFactory:function g5(n,t,e){return new u5(n,t,e)},deps:[ze.se,Nx,K.R0b]}],SI=[{provide:iI,useFactory:()=>new o5},{provide:K.QbO,useValue:"BrowserAnimations"},...BA],VA=[{provide:iI,useClass:hA},{provide:K.QbO,useValue:"NoopAnimations"},...BA];let EI,y5=(()=>{class n{static withConfig(e){return{ngModule:n,providers:e.disableAnimations?VA:SI}}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=K.oAB({type:n}),n.\u0275inj=K.cJS({providers:SI,imports:[ze.b2]}),n})();try{EI="undefined"!=typeof Intl&&Intl.v8BreakIterator}catch(n){EI=!1}let nl,v5=(()=>{class n{constructor(e){this._platformId=e,this.isBrowser=this._platformId?(0,kh.NF)(this._platformId):"object"==typeof document&&!!document,this.EDGE=this.isBrowser&&/(edge)/i.test(navigator.userAgent),this.TRIDENT=this.isBrowser&&/(msie|trident)/i.test(navigator.userAgent),this.BLINK=this.isBrowser&&!(!window.chrome&&!EI)&&"undefined"!=typeof CSS&&!this.EDGE&&!this.TRIDENT,this.WEBKIT=this.isBrowser&&/AppleWebKit/i.test(navigator.userAgent)&&!this.BLINK&&!this.EDGE&&!this.TRIDENT,this.IOS=this.isBrowser&&/iPad|iPhone|iPod/.test(navigator.userAgent)&&!("MSStream"in window),this.FIREFOX=this.isBrowser&&/(firefox|minefield)/i.test(navigator.userAgent),this.ANDROID=this.isBrowser&&/android/i.test(navigator.userAgent)&&!this.TRIDENT,this.SAFARI=this.isBrowser&&/safari/i.test(navigator.userAgent)&&this.WEBKIT}}return n.\u0275fac=function(e){return new(e||n)(K.LFG(K.Lbi))},n.\u0275prov=K.Yz7({token:n,factory:n.\u0275fac,providedIn:"root"}),n})(),b5=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=K.oAB({type:n}),n.\u0275inj=K.cJS({}),n})();nl="undefined"!=typeof global?global:"undefined"!=typeof window?window:{};var zA=Y(727);class C5 extends zA.w0{constructor(t,e){super()}schedule(t,e=0){return this}}const Rx={setInterval(n,t,...e){const{delegate:r}=Rx;return null!=r&&r.setInterval?r.setInterval(n,t,...e):setInterval(n,t,...e)},clearInterval(n){const{delegate:t}=Rx;return((null==t?void 0:t.clearInterval)||clearInterval)(n)},delegate:void 0};var S5=Y(8737);class HA extends C5{constructor(t,e){super(t,e),this.scheduler=t,this.work=e,this.pending=!1}schedule(t,e=0){var r;if(this.closed)return this;this.state=t;const s=this.id,o=this.scheduler;return null!=s&&(this.id=this.recycleAsyncId(o,s,e)),this.pending=!0,this.delay=e,this.id=null!==(r=this.id)&&void 0!==r?r:this.requestAsyncId(o,this.id,e),this}requestAsyncId(t,e,r=0){return Rx.setInterval(t.flush.bind(t,this),r)}recycleAsyncId(t,e,r=0){if(null!=r&&this.delay===r&&!1===this.pending)return e;null!=e&&Rx.clearInterval(e)}execute(t,e){if(this.closed)return new Error("executing a cancelled action");this.pending=!1;const r=this._execute(t,e);if(r)return r;!1===this.pending&&null!=this.id&&(this.id=this.recycleAsyncId(this.scheduler,this.id,null))}_execute(t,e){let s,r=!1;try{this.work(t)}catch(o){r=!0,s=o||new Error("Scheduled action threw falsy error")}if(r)return this.unsubscribe(),s}unsubscribe(){if(!this.closed){const{id:t,scheduler:e}=this,{actions:r}=e;this.work=this.state=this.scheduler=null,this.pending=!1,(0,S5.P)(r,this),null!=t&&(this.id=this.recycleAsyncId(e,t,null)),this.delay=null,super.unsubscribe()}}}const Ky={schedule(n){let t=requestAnimationFrame,e=cancelAnimationFrame;const{delegate:r}=Ky;r&&(t=r.requestAnimationFrame,e=r.cancelAnimationFrame);const s=t(o=>{e=void 0,n(o)});return new zA.w0(()=>null==e?void 0:e(s))},requestAnimationFrame(...n){const{delegate:t}=Ky;return((null==t?void 0:t.requestAnimationFrame)||requestAnimationFrame)(...n)},cancelAnimationFrame(...n){const{delegate:t}=Ky;return((null==t?void 0:t.cancelAnimationFrame)||cancelAnimationFrame)(...n)},delegate:void 0},WA={now:()=>(WA.delegate||Date).now(),delegate:void 0};class qy{constructor(t,e=qy.now){this.schedulerActionCtor=t,this.now=e}schedule(t,e=0,r){return new this.schedulerActionCtor(this,t).schedule(r,e)}}qy.now=WA.now;class jA extends qy{constructor(t,e=qy.now){super(t,e),this.actions=[],this._active=!1}flush(t){const{actions:e}=this;if(this._active)return void e.push(t);let r;this._active=!0;do{if(r=t.execute(t.state,t.delay))break}while(t=e.shift());if(this._active=!1,r){for(;t=e.shift();)t.unsubscribe();throw r}}}new class I5 extends jA{flush(t){this._active=!0;const e=this._scheduled;this._scheduled=void 0;const{actions:r}=this;let s;t=t||r.shift();do{if(s=t.execute(t.state,t.delay))break}while((t=r[0])&&t.id===e&&r.shift());if(this._active=!1,s){for(;(t=r[0])&&t.id===e&&r.shift();)t.unsubscribe();throw s}}}(class E5 extends HA{constructor(t,e){super(t,e),this.scheduler=t,this.work=e}requestAsyncId(t,e,r=0){return null!==r&&r>0?super.requestAsyncId(t,e,r):(t.actions.push(this),t._scheduled||(t._scheduled=Ky.requestAnimationFrame(()=>t.flush(void 0))))}recycleAsyncId(t,e,r=0){var s;if(null!=r?r>0:this.delay>0)return super.recycleAsyncId(t,e,r);const{actions:o}=t;null!=e&&(null===(s=o[o.length-1])||void 0===s?void 0:s.id)!==e&&(Ky.cancelAnimationFrame(e),t._scheduled=void 0)}});let TI,T5=1;const Mx={};function GA(n){return n in Mx&&(delete Mx[n],!0)}const N5={setImmediate(n){const t=T5++;return Mx[t]=!0,TI||(TI=Promise.resolve()),TI.then(()=>GA(t)&&n()),t},clearImmediate(n){GA(n)}},{setImmediate:k5,clearImmediate:A5}=N5,Ox={setImmediate(...n){const{delegate:t}=Ox;return((null==t?void 0:t.setImmediate)||k5)(...n)},clearImmediate(n){const{delegate:t}=Ox;return((null==t?void 0:t.clearImmediate)||A5)(n)},delegate:void 0};new class M5 extends jA{flush(t){this._active=!0;const e=this._scheduled;this._scheduled=void 0;const{actions:r}=this;let s;t=t||r.shift();do{if(s=t.execute(t.state,t.delay))break}while((t=r[0])&&t.id===e&&r.shift());if(this._active=!1,s){for(;(t=r[0])&&t.id===e&&r.shift();)t.unsubscribe();throw s}}}(class R5 extends HA{constructor(t,e){super(t,e),this.scheduler=t,this.work=e}requestAsyncId(t,e,r=0){return null!==r&&r>0?super.requestAsyncId(t,e,r):(t.actions.push(this),t._scheduled||(t._scheduled=Ox.setImmediate(t.flush.bind(t,void 0))))}recycleAsyncId(t,e,r=0){var s;if(null!=r?r>0:this.delay>0)return super.recycleAsyncId(t,e,r);const{actions:o}=t;null!=e&&(null===(s=o[o.length-1])||void 0===s?void 0:s.id)!==e&&(Ox.clearImmediate(e),t._scheduled=void 0)}});let KA=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=K.oAB({type:n}),n.\u0275inj=K.cJS({}),n})();const qA=new K.GfV("13.0.0"),QA="cdk-high-contrast-black-on-white",JA="cdk-high-contrast-white-on-black",NI="cdk-high-contrast-active";let q5=(()=>{class n{constructor(e,r){this._platform=e,this._document=r}getHighContrastMode(){if(!this._platform.isBrowser)return 0;const e=this._document.createElement("div");e.style.backgroundColor="rgb(1,2,3)",e.style.position="absolute",this._document.body.appendChild(e);const r=this._document.defaultView||window,s=r&&r.getComputedStyle?r.getComputedStyle(e):null,o=(s&&s.backgroundColor||"").replace(/ /g,"");switch(e.remove(),o){case"rgb(0,0,0)":return 2;case"rgb(255,255,255)":return 1}return 0}_applyBodyHighContrastModeCssClasses(){if(!this._hasCheckedHighContrastMode&&this._platform.isBrowser&&this._document.body){const e=this._document.body.classList;e.remove(NI),e.remove(QA),e.remove(JA),this._hasCheckedHighContrastMode=!0;const r=this.getHighContrastMode();1===r?(e.add(NI),e.add(QA)):2===r&&(e.add(NI),e.add(JA))}}}return n.\u0275fac=function(e){return new(e||n)(K.LFG(v5),K.LFG(kh.K0))},n.\u0275prov=K.Yz7({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();const eR=new K.GfV("13.0.0"),Y5=new K.OlP("mat-sanity-checks",{providedIn:"root",factory:function X5(){return!0}});let tR=(()=>{class n{constructor(e,r,s){this._hasDoneGlobalChecks=!1,this._document=s,e._applyBodyHighContrastModeCssClasses(),this._sanityChecks=r,this._hasDoneGlobalChecks||(this._checkDoctypeIsDefined(),this._checkThemeIsPresent(),this._checkCdkVersionMatch(),this._hasDoneGlobalChecks=!0)}_checkIsEnabled(e){return!(!(0,K.X6Q)()||function w5(){return void 0!==nl.__karma__&&!!nl.__karma__||void 0!==nl.jasmine&&!!nl.jasmine||void 0!==nl.jest&&!!nl.jest||void 0!==nl.Mocha&&!!nl.Mocha}())&&("boolean"==typeof this._sanityChecks?this._sanityChecks:!!this._sanityChecks[e])}_checkDoctypeIsDefined(){this._checkIsEnabled("doctype")&&!this._document.doctype&&console.warn("Current document does not have a doctype. This may cause some Angular Material components not to behave as expected.")}_checkThemeIsPresent(){if(!this._checkIsEnabled("theme")||!this._document.body||"function"!=typeof getComputedStyle)return;const e=this._document.createElement("div");e.classList.add("mat-theme-loaded-marker"),this._document.body.appendChild(e);const r=getComputedStyle(e);r&&"none"!==r.display&&console.warn("Could not find Angular Material core theme. Most Material components may not work as expected. For more info refer to the theming guide: https://material.angular.io/guide/theming"),e.remove()}_checkCdkVersionMatch(){this._checkIsEnabled("version")&&eR.full!==qA.full&&console.warn("The Angular Material version ("+eR.full+") does not match the Angular CDK version ("+qA.full+").\nPlease ensure the versions of these two packages exactly match.")}}return n.\u0275fac=function(e){return new(e||n)(K.LFG(q5),K.LFG(Y5,8),K.LFG(kh.K0))},n.\u0275mod=K.oAB({type:n}),n.\u0275inj=K.cJS({imports:[[Yk],Yk]}),n})(),r8=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=K.oAB({type:n}),n.\u0275inj=K.cJS({imports:[[kh.ez,tR,b5,KA],KA,tR]}),n})(),s8=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=K.oAB({type:n,bootstrap:[mG]}),n.\u0275inj=K.cJS({imports:[ze.b2,dt,y5,r8]}),n})();(0,K.G48)(),ze.q6().bootstrapModule(s8).catch(n=>console.error(n))},2333:Lt=>{Lt.exports=Y;var ot=null;try{ot=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch(ie){}function Y(ie,X,ze){this.low=0|ie,this.high=0|X,this.unsigned=!!ze}function P(ie){return!0===(ie&&ie.__isLong__)}Object.defineProperty(Y.prototype,"__isLong__",{value:!0}),Y.isLong=P;var ae={},Oe={};function ve(ie,X){var ze,K,_t;return X?(_t=0<=(ie>>>=0)&&ie<256)&&(K=Oe[ie])?K:(ze=Fe(ie,(0|ie)<0?-1:0,!0),_t&&(Oe[ie]=ze),ze):(_t=-128<=(ie|=0)&&ie<128)&&(K=ae[ie])?K:(ze=Fe(ie,ie<0?-1:0,!1),_t&&(ae[ie]=ze),ze)}function Le(ie,X){if(isNaN(ie))return X?bt:vt;if(X){if(ie<0)return bt;if(ie>=Ge)return Ze}else{if(ie<=-$e)return Xe;if(ie+1>=$e)return at}return ie<0?Le(-ie,X).neg():Fe(ie%_e|0,ie/_e|0,X)}function Fe(ie,X,ze){return new Y(ie,X,ze)}Y.fromInt=ve,Y.fromNumber=Le,Y.fromBits=Fe;var ct=Math.pow;function nt(ie,X,ze){if(0===ie.length)throw Error("empty string");if("NaN"===ie||"Infinity"===ie||"+Infinity"===ie||"-Infinity"===ie)return vt;if("number"==typeof X?(ze=X,X=!1):X=!!X,(ze=ze||10)<2||36<ze)throw RangeError("radix");var K;if((K=ie.indexOf("-"))>0)throw Error("interior hyphen");if(0===K)return nt(ie.substring(1),X,ze).neg();for(var _t=Le(ct(ze,8)),Ot=vt,dt=0;dt<ie.length;dt+=8){var qe=Math.min(8,ie.length-dt),xe=parseInt(ie.substring(dt,dt+qe),ze);if(qe<8){var et=Le(ct(ze,qe));Ot=Ot.mul(et).add(Le(xe))}else Ot=(Ot=Ot.mul(_t)).add(Le(xe))}return Ot.unsigned=X,Ot}function he(ie,X){return"number"==typeof ie?Le(ie,X):"string"==typeof ie?nt(ie,X):Fe(ie.low,ie.high,"boolean"==typeof X?X:ie.unsigned)}Y.fromString=nt,Y.fromValue=he;var _e=4294967296,Ge=_e*_e,$e=Ge/2,ut=ve(1<<24),vt=ve(0);Y.ZERO=vt;var bt=ve(0,!0);Y.UZERO=bt;var Jt=ve(1);Y.ONE=Jt;var Cn=ve(1,!0);Y.UONE=Cn;var Dt=ve(-1);Y.NEG_ONE=Dt;var at=Fe(-1,2147483647,!1);Y.MAX_VALUE=at;var Ze=Fe(-1,-1,!0);Y.MAX_UNSIGNED_VALUE=Ze;var Xe=Fe(0,-2147483648,!1);Y.MIN_VALUE=Xe;var Ue=Y.prototype;Ue.toInt=function(){return this.unsigned?this.low>>>0:this.low},Ue.toNumber=function(){return this.unsigned?(this.high>>>0)*_e+(this.low>>>0):this.high*_e+(this.low>>>0)},Ue.toString=function(X){if((X=X||10)<2||36<X)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative()){if(this.eq(Xe)){var ze=Le(X),K=this.div(ze),_t=K.mul(ze).sub(this);return K.toString(X)+_t.toInt().toString(X)}return"-"+this.neg().toString(X)}for(var Ot=Le(ct(X,6),this.unsigned),dt=this,qe="";;){var xe=dt.div(Ot),ht=(dt.sub(xe.mul(Ot)).toInt()>>>0).toString(X);if((dt=xe).isZero())return ht+qe;for(;ht.length<6;)ht="0"+ht;qe=""+ht+qe}},Ue.getHighBits=function(){return this.high},Ue.getHighBitsUnsigned=function(){return this.high>>>0},Ue.getLowBits=function(){return this.low},Ue.getLowBitsUnsigned=function(){return this.low>>>0},Ue.getNumBitsAbs=function(){if(this.isNegative())return this.eq(Xe)?64:this.neg().getNumBitsAbs();for(var X=0!=this.high?this.high:this.low,ze=31;ze>0&&0==(X&1<<ze);ze--);return 0!=this.high?ze+33:ze+1},Ue.isZero=function(){return 0===this.high&&0===this.low},Ue.eqz=Ue.isZero,Ue.isNegative=function(){return!this.unsigned&&this.high<0},Ue.isPositive=function(){return this.unsigned||this.high>=0},Ue.isOdd=function(){return 1==(1&this.low)},Ue.isEven=function(){return 0==(1&this.low)},Ue.equals=function(X){return P(X)||(X=he(X)),(this.unsigned===X.unsigned||this.high>>>31!=1||X.high>>>31!=1)&&this.high===X.high&&this.low===X.low},Ue.eq=Ue.equals,Ue.notEquals=function(X){return!this.eq(X)},Ue.neq=Ue.notEquals,Ue.ne=Ue.notEquals,Ue.lessThan=function(X){return this.comp(X)<0},Ue.lt=Ue.lessThan,Ue.lessThanOrEqual=function(X){return this.comp(X)<=0},Ue.lte=Ue.lessThanOrEqual,Ue.le=Ue.lessThanOrEqual,Ue.greaterThan=function(X){return this.comp(X)>0},Ue.gt=Ue.greaterThan,Ue.greaterThanOrEqual=function(X){return this.comp(X)>=0},Ue.gte=Ue.greaterThanOrEqual,Ue.ge=Ue.greaterThanOrEqual,Ue.compare=function(X){if(P(X)||(X=he(X)),this.eq(X))return 0;var ze=this.isNegative(),K=X.isNegative();return ze&&!K?-1:!ze&&K?1:this.unsigned?X.high>>>0>this.high>>>0||X.high===this.high&&X.low>>>0>this.low>>>0?-1:1:this.sub(X).isNegative()?-1:1},Ue.comp=Ue.compare,Ue.negate=function(){return!this.unsigned&&this.eq(Xe)?Xe:this.not().add(Jt)},Ue.neg=Ue.negate,Ue.add=function(X){P(X)||(X=he(X));var ht=0,ce=0,ue=0,me=0;return ue+=(me+=(65535&this.low)+(65535&X.low))>>>16,ce+=(ue+=(this.low>>>16)+(X.low>>>16))>>>16,ht+=(ce+=(65535&this.high)+(65535&X.high))>>>16,ht+=(this.high>>>16)+(X.high>>>16),Fe((ue&=65535)<<16|(me&=65535),(ht&=65535)<<16|(ce&=65535),this.unsigned)},Ue.subtract=function(X){return P(X)||(X=he(X)),this.add(X.neg())},Ue.sub=Ue.subtract,Ue.multiply=function(X){if(this.isZero())return vt;if(P(X)||(X=he(X)),ot)return Fe(ot.mul(this.low,this.high,X.low,X.high),ot.get_high(),this.unsigned);if(X.isZero())return vt;if(this.eq(Xe))return X.isOdd()?Xe:vt;if(X.eq(Xe))return this.isOdd()?Xe:vt;if(this.isNegative())return X.isNegative()?this.neg().mul(X.neg()):this.neg().mul(X).neg();if(X.isNegative())return this.mul(X.neg()).neg();if(this.lt(ut)&&X.lt(ut))return Le(this.toNumber()*X.toNumber(),this.unsigned);var _t=65535&this.high,Ot=this.low>>>16,dt=65535&this.low,xe=65535&X.high,et=X.low>>>16,ht=65535&X.low,ce=0,ue=0,me=0,Ae=0;return me+=(Ae+=dt*ht)>>>16,ue+=(me+=Ot*ht)>>>16,me&=65535,ue+=(me+=dt*et)>>>16,ce+=(ue+=_t*ht)>>>16,ue&=65535,ce+=(ue+=Ot*et)>>>16,ue&=65535,ce+=(ue+=dt*xe)>>>16,ce+=(this.high>>>16)*ht+_t*et+Ot*xe+dt*(X.high>>>16),Fe((me&=65535)<<16|(Ae&=65535),(ce&=65535)<<16|(ue&=65535),this.unsigned)},Ue.mul=Ue.multiply,Ue.divide=function(X){if(P(X)||(X=he(X)),X.isZero())throw Error("division by zero");var K,_t,Ot;if(ot)return this.unsigned||-2147483648!==this.high||-1!==X.low||-1!==X.high?Fe((this.unsigned?ot.div_u:ot.div_s)(this.low,this.high,X.low,X.high),ot.get_high(),this.unsigned):this;if(this.isZero())return this.unsigned?bt:vt;if(this.unsigned){if(X.unsigned||(X=X.toUnsigned()),X.gt(this))return bt;if(X.gt(this.shru(1)))return Cn;Ot=bt}else{if(this.eq(Xe))return X.eq(Jt)||X.eq(Dt)?Xe:X.eq(Xe)?Jt:(K=this.shr(1).div(X).shl(1)).eq(vt)?X.isNegative()?Jt:Dt:(_t=this.sub(X.mul(K)),Ot=K.add(_t.div(X)));if(X.eq(Xe))return this.unsigned?bt:vt;if(this.isNegative())return X.isNegative()?this.neg().div(X.neg()):this.neg().div(X).neg();if(X.isNegative())return this.div(X.neg()).neg();Ot=vt}for(_t=this;_t.gte(X);){K=Math.max(1,Math.floor(_t.toNumber()/X.toNumber()));for(var qe=Math.ceil(Math.log(K)/Math.LN2),xe=qe<=48?1:ct(2,qe-48),et=Le(K),ht=et.mul(X);ht.isNegative()||ht.gt(_t);)ht=(et=Le(K-=xe,this.unsigned)).mul(X);et.isZero()&&(et=Jt),Ot=Ot.add(et),_t=_t.sub(ht)}return Ot},Ue.div=Ue.divide,Ue.modulo=function(X){return P(X)||(X=he(X)),ot?Fe((this.unsigned?ot.rem_u:ot.rem_s)(this.low,this.high,X.low,X.high),ot.get_high(),this.unsigned):this.sub(this.div(X).mul(X))},Ue.mod=Ue.modulo,Ue.rem=Ue.modulo,Ue.not=function(){return Fe(~this.low,~this.high,this.unsigned)},Ue.and=function(X){return P(X)||(X=he(X)),Fe(this.low&X.low,this.high&X.high,this.unsigned)},Ue.or=function(X){return P(X)||(X=he(X)),Fe(this.low|X.low,this.high|X.high,this.unsigned)},Ue.xor=function(X){return P(X)||(X=he(X)),Fe(this.low^X.low,this.high^X.high,this.unsigned)},Ue.shiftLeft=function(X){return P(X)&&(X=X.toInt()),0==(X&=63)?this:X<32?Fe(this.low<<X,this.high<<X|this.low>>>32-X,this.unsigned):Fe(0,this.low<<X-32,this.unsigned)},Ue.shl=Ue.shiftLeft,Ue.shiftRight=function(X){return P(X)&&(X=X.toInt()),0==(X&=63)?this:X<32?Fe(this.low>>>X|this.high<<32-X,this.high>>X,this.unsigned):Fe(this.high>>X-32,this.high>=0?0:-1,this.unsigned)},Ue.shr=Ue.shiftRight,Ue.shiftRightUnsigned=function(X){if(P(X)&&(X=X.toInt()),0==(X&=63))return this;var ze=this.high;return X<32?Fe(this.low>>>X|ze<<32-X,ze>>>X,this.unsigned):Fe(32===X?ze:ze>>>X-32,0,this.unsigned)},Ue.shru=Ue.shiftRightUnsigned,Ue.shr_u=Ue.shiftRightUnsigned,Ue.toSigned=function(){return this.unsigned?Fe(this.low,this.high,!1):this},Ue.toUnsigned=function(){return this.unsigned?this:Fe(this.low,this.high,!0)},Ue.toBytes=function(X){return X?this.toBytesLE():this.toBytesBE()},Ue.toBytesLE=function(){var X=this.high,ze=this.low;return[255&ze,ze>>>8&255,ze>>>16&255,ze>>>24,255&X,X>>>8&255,X>>>16&255,X>>>24]},Ue.toBytesBE=function(){var X=this.high,ze=this.low;return[X>>>24,X>>>16&255,X>>>8&255,255&X,ze>>>24,ze>>>16&255,ze>>>8&255,255&ze]},Y.fromBytes=function(X,ze,K){return K?Y.fromBytesLE(X,ze):Y.fromBytesBE(X,ze)},Y.fromBytesLE=function(X,ze){return new Y(X[0]|X[1]<<8|X[2]<<16|X[3]<<24,X[4]|X[5]<<8|X[6]<<16|X[7]<<24,ze)},Y.fromBytesBE=function(X,ze){return new Y(X[4]<<24|X[5]<<16|X[6]<<8|X[7],X[0]<<24|X[1]<<16|X[2]<<8|X[3],ze)}},6899:function(Lt){"undefined"!=typeof self&&self,Lt.exports=function(ot){var Y={};function P(ae){if(Y[ae])return Y[ae].exports;var Oe=Y[ae]={i:ae,l:!1,exports:{}};return ot[ae].call(Oe.exports,Oe,Oe.exports,P),Oe.l=!0,Oe.exports}return P.m=ot,P.c=Y,P.d=function(ae,Oe,ve){P.o(ae,Oe)||Object.defineProperty(ae,Oe,{enumerable:!0,get:ve})},P.r=function(ae){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(ae,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(ae,"__esModule",{value:!0})},P.t=function(ae,Oe){if(1&Oe&&(ae=P(ae)),8&Oe||4&Oe&&"object"==typeof ae&&ae&&ae.__esModule)return ae;var ve=Object.create(null);if(P.r(ve),Object.defineProperty(ve,"default",{enumerable:!0,value:ae}),2&Oe&&"string"!=typeof ae)for(var Le in ae)P.d(ve,Le,function(Fe){return ae[Fe]}.bind(null,Le));return ve},P.n=function(ae){var Oe=ae&&ae.__esModule?function(){return ae.default}:function(){return ae};return P.d(Oe,"a",Oe),Oe},P.o=function(ae,Oe){return Object.prototype.hasOwnProperty.call(ae,Oe)},P.p="",P(P.s=0)}([function(ot,Y,P){"use strict";P.r(Y);var ae={};function Oe(qe){return(Oe="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(xe){return typeof xe}:function(xe){return xe&&"function"==typeof Symbol&&xe.constructor===Symbol&&xe!==Symbol.prototype?"symbol":typeof xe})(qe)}P.r(ae),P.d(ae,"VictoryGesture",function(){return X}),P.d(ae,"ThumbsUpGesture",function(){return dt});var ve={Thumb:0,Index:1,Middle:2,Ring:3,Pinky:4,all:[0,1,2,3,4],nameMapping:{0:"Thumb",1:"Index",2:"Middle",3:"Ring",4:"Pinky"},pointsMapping:{0:[[0,1],[1,2],[2,3],[3,4]],1:[[0,5],[5,6],[6,7],[7,8]],2:[[0,9],[9,10],[10,11],[11,12]],3:[[0,13],[13,14],[14,15],[15,16]],4:[[0,17],[17,18],[18,19],[19,20]]},getName:function(qe){return void 0!==Oe(this.nameMapping[qe])&&this.nameMapping[qe]},getPoints:function(qe){return void 0!==Oe(this.pointsMapping[qe])&&this.pointsMapping[qe]}},Le={NoCurl:0,HalfCurl:1,FullCurl:2,nameMapping:{0:"No Curl",1:"Half Curl",2:"Full Curl"},getName:function(qe){return void 0!==Oe(this.nameMapping[qe])&&this.nameMapping[qe]}},Fe={VerticalUp:0,VerticalDown:1,HorizontalLeft:2,HorizontalRight:3,DiagonalUpRight:4,DiagonalUpLeft:5,DiagonalDownRight:6,DiagonalDownLeft:7,nameMapping:{0:"Vertical Up",1:"Vertical Down",2:"Horizontal Left",3:"Horizontal Right",4:"Diagonal Up Right",5:"Diagonal Up Left",6:"Diagonal Down Right",7:"Diagonal Down Left"},getName:function(qe){return void 0!==Oe(this.nameMapping[qe])&&this.nameMapping[qe]}};function ct(qe,xe){var et="undefined"!=typeof Symbol&&qe[Symbol.iterator]||qe["@@iterator"];if(!et){if(Array.isArray(qe)||(et=function(Te,Ve){if(Te){if("string"==typeof Te)return nt(Te,undefined);var xt=Object.prototype.toString.call(Te).slice(8,-1);if("Object"===xt&&Te.constructor&&(xt=Te.constructor.name),"Map"===xt||"Set"===xt)return Array.from(Te);if("Arguments"===xt||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(xt))return nt(Te,undefined)}}(qe))||xe&&qe&&"number"==typeof qe.length){et&&(qe=et);var ht=0,ce=function(){};return{s:ce,n:function(){return ht>=qe.length?{done:!0}:{done:!1,value:qe[ht++]}},e:function(Te){throw Te},f:ce}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var ue,me=!0,Ae=!1;return{s:function(){et=et.call(qe)},n:function(){var Te=et.next();return me=Te.done,Te},e:function(Te){Ae=!0,ue=Te},f:function(){try{me||null==et.return||et.return()}finally{if(Ae)throw ue}}}}function nt(qe,xe){(null==xe||xe>qe.length)&&(xe=qe.length);for(var et=0,ht=new Array(xe);et<xe;et++)ht[et]=qe[et];return ht}function he(qe,xe){var et=Object.keys(qe);if(Object.getOwnPropertySymbols){var ht=Object.getOwnPropertySymbols(qe);xe&&(ht=ht.filter(function(ce){return Object.getOwnPropertyDescriptor(qe,ce).enumerable})),et.push.apply(et,ht)}return et}function Ie(qe){for(var xe=1;xe<arguments.length;xe++){var et=null!=arguments[xe]?arguments[xe]:{};xe%2?he(Object(et),!0).forEach(function(ht){we(qe,ht,et[ht])}):Object.getOwnPropertyDescriptors?Object.defineProperties(qe,Object.getOwnPropertyDescriptors(et)):he(Object(et)).forEach(function(ht){Object.defineProperty(qe,ht,Object.getOwnPropertyDescriptor(et,ht))})}return qe}function we(qe,xe,et){return xe in qe?Object.defineProperty(qe,xe,{value:et,enumerable:!0,configurable:!0,writable:!0}):qe[xe]=et,qe}function _e(qe,xe){for(var et=0;et<xe.length;et++){var ht=xe[et];ht.enumerable=ht.enumerable||!1,ht.configurable=!0,"value"in ht&&(ht.writable=!0),Object.defineProperty(qe,ht.key,ht)}}var Ge=function(){function qe(ce){(function(ue,me){if(!(ue instanceof me))throw new TypeError("Cannot call a class as a function")})(this,qe),this.options=Ie(Ie({},{HALF_CURL_START_LIMIT:60,NO_CURL_START_LIMIT:130,DISTANCE_VOTE_POWER:1.1,SINGLE_ANGLE_VOTE_POWER:.9,TOTAL_ANGLE_VOTE_POWER:1.6}),ce)}var xe,et;return xe=qe,(et=[{key:"estimate",value:function(ce){var ue,me=[],Ae=[],Te=ct(ve.all);try{for(Te.s();!(ue=Te.n()).done;){var Ve,Pt=ve.getPoints(ue.value),qt=[],it=[],ln=ct(Pt);try{for(ln.s();!(Ve=ln.n()).done;){var G=Ve.value,Ee=this.getSlopes(ce[G[0]],ce[G[1]]),In=Ee[1];qt.push(Ee[0]),it.push(In)}}catch(Kn){ln.e(Kn)}finally{ln.f()}me.push(qt),Ae.push(it)}}catch(Kn){Te.e(Kn)}finally{Te.f()}var un,kn=[],Fr=[],wr=ct(ve.all);try{for(wr.s();!(un=wr.n()).done;){var us=un.value,vr=us==ve.Thumb?1:0,$r=ve.getPoints(us),Dr=ce[$r[vr][0]],Tt=ce[$r[vr+1][1]],St=ce[$r[3][1]],Rt=this.estimateFingerCurl(Dr,Tt,St),Ft=this.calculateFingerDirection(Dr,Tt,St,me[us].slice(vr));kn[us]=Rt,Fr[us]=Ft}}catch(Kn){wr.e(Kn)}finally{wr.f()}return{curls:kn,directions:Fr}}},{key:"getSlopes",value:function(ce,ue){var me=this.calculateSlope(ce[0],ce[1],ue[0],ue[1]);return 2==ce.length?me:[me,this.calculateSlope(ce[1],ce[2],ue[1],ue[2])]}},{key:"angleOrientationAt",value:function(ce){var ue=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,me=0,Ae=0,Te=0;return ce>=75&&ce<=105?me=1*ue:ce>=25&&ce<=155?Ae=1*ue:Te=1*ue,[me,Ae,Te]}},{key:"estimateFingerCurl",value:function(ce,ue,me){var Ae=ce[0]-ue[0],Te=ce[0]-me[0],Ve=ue[0]-me[0],xt=ce[1]-ue[1],Pt=ce[1]-me[1],qt=ue[1]-me[1],it=ce[2]-ue[2],ln=ce[2]-me[2],G=ue[2]-me[2],bn=Math.sqrt(Ae*Ae+xt*xt+it*it),Bt=Math.sqrt(Te*Te+Pt*Pt+ln*ln),Ee=Math.sqrt(Ve*Ve+qt*qt+G*G),cn=(Ee*Ee+bn*bn-Bt*Bt)/(2*Ee*bn);cn>1?cn=1:cn<-1&&(cn=-1);var In=Math.acos(cn);return(In=57.2958*In%180)>this.options.NO_CURL_START_LIMIT?Le.NoCurl:In>this.options.HALF_CURL_START_LIMIT?Le.HalfCurl:Le.FullCurl}},{key:"estimateHorizontalDirection",value:function(ce,ue,me,Ae){return Ae==Math.abs(ce)?ce>0?Fe.HorizontalLeft:Fe.HorizontalRight:Ae==Math.abs(ue)?ue>0?Fe.HorizontalLeft:Fe.HorizontalRight:me>0?Fe.HorizontalLeft:Fe.HorizontalRight}},{key:"estimateVerticalDirection",value:function(ce,ue,me,Ae){return Ae==Math.abs(ce)?ce<0?Fe.VerticalDown:Fe.VerticalUp:Ae==Math.abs(ue)?ue<0?Fe.VerticalDown:Fe.VerticalUp:me<0?Fe.VerticalDown:Fe.VerticalUp}},{key:"estimateDiagonalDirection",value:function(ce,ue,me,Ae,Te,Ve,xt,Pt){var qt=this.estimateVerticalDirection(ce,ue,me,Ae),it=this.estimateHorizontalDirection(Te,Ve,xt,Pt);return qt==Fe.VerticalUp?it==Fe.HorizontalLeft?Fe.DiagonalUpLeft:Fe.DiagonalUpRight:it==Fe.HorizontalLeft?Fe.DiagonalDownLeft:Fe.DiagonalDownRight}},{key:"calculateFingerDirection",value:function(ce,ue,me,Ae){var Te=ce[0]-ue[0],Ve=ce[0]-me[0],xt=ue[0]-me[0],Pt=ce[1]-ue[1],qt=ce[1]-me[1],it=ue[1]-me[1],ln=Math.max(Math.abs(Te),Math.abs(Ve),Math.abs(xt)),G=Math.max(Math.abs(Pt),Math.abs(qt),Math.abs(it)),bn=0,Bt=0,Ee=0,cn=G/(ln+1e-5);cn>1.5?bn+=this.options.DISTANCE_VOTE_POWER:cn>.66?Bt+=this.options.DISTANCE_VOTE_POWER:Ee+=this.options.DISTANCE_VOTE_POWER;var In=Math.sqrt(Te*Te+Pt*Pt),un=Math.sqrt(Ve*Ve+qt*qt),kn=Math.sqrt(xt*xt+it*it),Fr=Math.max(In,un,kn),wr=ce[0],us=ce[1],vr=me[0],$r=me[1];Fr==In?(vr=me[0],$r=me[1]):Fr==kn&&(wr=ue[0],us=ue[1]);var St=this.getSlopes([wr,us],[vr,$r]),Rt=this.angleOrientationAt(St,this.options.TOTAL_ANGLE_VOTE_POWER);bn+=Rt[0],Bt+=Rt[1],Ee+=Rt[2];var Ft,Kn=ct(Ae);try{for(Kn.s();!(Ft=Kn.n()).done;){var An=this.angleOrientationAt(Ft.value,this.options.SINGLE_ANGLE_VOTE_POWER);bn+=An[0],Bt+=An[1],Ee+=An[2]}}catch(Cr){Kn.e(Cr)}finally{Kn.f()}return bn==Math.max(bn,Bt,Ee)?this.estimateVerticalDirection(qt,Pt,it,G):Ee==Math.max(Bt,Ee)?this.estimateHorizontalDirection(Ve,Te,xt,ln):this.estimateDiagonalDirection(qt,Pt,it,G,Ve,Te,xt,ln)}},{key:"calculateSlope",value:function(ce,ue,me,Ae){var Ve=180*Math.atan((ue-Ae)/(ce-me))/Math.PI;return Ve<=0?Ve=-Ve:Ve>0&&(Ve=180-Ve),Ve}}])&&_e(xe.prototype,et),qe}();function $e(qe,xe){var et="undefined"!=typeof Symbol&&qe[Symbol.iterator]||qe["@@iterator"];if(!et){if(Array.isArray(qe)||(et=function(Te,Ve){if(Te){if("string"==typeof Te)return ut(Te,undefined);var xt=Object.prototype.toString.call(Te).slice(8,-1);if("Object"===xt&&Te.constructor&&(xt=Te.constructor.name),"Map"===xt||"Set"===xt)return Array.from(Te);if("Arguments"===xt||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(xt))return ut(Te,undefined)}}(qe))||xe&&qe&&"number"==typeof qe.length){et&&(qe=et);var ht=0,ce=function(){};return{s:ce,n:function(){return ht>=qe.length?{done:!0}:{done:!1,value:qe[ht++]}},e:function(Te){throw Te},f:ce}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var ue,me=!0,Ae=!1;return{s:function(){et=et.call(qe)},n:function(){var Te=et.next();return me=Te.done,Te},e:function(Te){Ae=!0,ue=Te},f:function(){try{me||null==et.return||et.return()}finally{if(Ae)throw ue}}}}function ut(qe,xe){(null==xe||xe>qe.length)&&(xe=qe.length);for(var et=0,ht=new Array(xe);et<xe;et++)ht[et]=qe[et];return ht}function vt(qe,xe){if(!(qe instanceof xe))throw new TypeError("Cannot call a class as a function")}function bt(qe,xe){for(var et=0;et<xe.length;et++){var ht=xe[et];ht.enumerable=ht.enumerable||!1,ht.configurable=!0,"value"in ht&&(ht.writable=!0),Object.defineProperty(qe,ht.key,ht)}}var Jt=function(){function qe(ce){var ue=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};vt(this,qe),this.estimator=new Ge(ue),this.gestures=ce}var xe,et;return xe=qe,(et=[{key:"estimate",value:function(ce,ue){var me,Ae=[],Te=this.estimator.estimate(ce),Ve=[],xt=$e(ve.all);try{for(xt.s();!(me=xt.n()).done;){var Pt=me.value;Ve.push([ve.getName(Pt),Le.getName(Te.curls[Pt]),Fe.getName(Te.directions[Pt])])}}catch(bn){xt.e(bn)}finally{xt.f()}var qt,it=$e(this.gestures);try{for(it.s();!(qt=it.n()).done;){var ln=qt.value,G=ln.matchAgainst(Te.curls,Te.directions);G>=ue&&Ae.push({name:ln.name,score:G})}}catch(bn){it.e(bn)}finally{it.f()}return{poseData:Ve,gestures:Ae}}}])&&bt(xe.prototype,et),qe}();function Cn(qe,xe){return function(et){if(Array.isArray(et))return et}(qe)||function(et,ht){var ce=null==et?null:"undefined"!=typeof Symbol&&et[Symbol.iterator]||et["@@iterator"];if(null!=ce){var ue,me,Ae=[],Te=!0,Ve=!1;try{for(ce=ce.call(et);!(Te=(ue=ce.next()).done)&&(Ae.push(ue.value),!ht||Ae.length!==ht);Te=!0);}catch(xt){Ve=!0,me=xt}finally{try{Te||null==ce.return||ce.return()}finally{if(Ve)throw me}}return Ae}}(qe,xe)||at(qe,xe)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function Dt(qe,xe){var et="undefined"!=typeof Symbol&&qe[Symbol.iterator]||qe["@@iterator"];if(!et){if(Array.isArray(qe)||(et=at(qe))||xe&&qe&&"number"==typeof qe.length){et&&(qe=et);var ht=0,ce=function(){};return{s:ce,n:function(){return ht>=qe.length?{done:!0}:{done:!1,value:qe[ht++]}},e:function(Te){throw Te},f:ce}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var ue,me=!0,Ae=!1;return{s:function(){et=et.call(qe)},n:function(){var Te=et.next();return me=Te.done,Te},e:function(Te){Ae=!0,ue=Te},f:function(){try{me||null==et.return||et.return()}finally{if(Ae)throw ue}}}}function at(qe,xe){if(qe){if("string"==typeof qe)return Ze(qe,xe);var et=Object.prototype.toString.call(qe).slice(8,-1);return"Object"===et&&qe.constructor&&(et=qe.constructor.name),"Map"===et||"Set"===et?Array.from(qe):"Arguments"===et||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(et)?Ze(qe,xe):void 0}}function Ze(qe,xe){(null==xe||xe>qe.length)&&(xe=qe.length);for(var et=0,ht=new Array(xe);et<xe;et++)ht[et]=qe[et];return ht}function Xe(qe,xe){for(var et=0;et<xe.length;et++){var ht=xe[et];ht.enumerable=ht.enumerable||!1,ht.configurable=!0,"value"in ht&&(ht.writable=!0),Object.defineProperty(qe,ht.key,ht)}}var Ue=function(){function qe(ce){(function(ue,me){if(!(ue instanceof me))throw new TypeError("Cannot call a class as a function")})(this,qe),this.name=ce,this.curls={},this.directions={}}var xe,et;return xe=qe,(et=[{key:"addCurl",value:function(ce,ue){var me=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;void 0===this.curls[ce]&&(this.curls[ce]=[]),this.curls[ce].push([ue,me])}},{key:"addDirection",value:function(ce,ue){var me=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;void 0===this.directions[ce]&&(this.directions[ce]=[]),this.directions[ce].push([ue,me])}},{key:"matchAgainst",value:function(ce,ue){var me=0,Ae=0;for(var Te in ce){var Ve=ce[Te],xt=this.curls[Te];if(void 0!==xt){Ae++;var Pt,qt=!1,it=0,ln=Dt(xt);try{for(ln.s();!(Pt=ln.n()).done;){var G=Cn(Pt.value,2),Bt=G[1];if(Ve==G[0]){me+=Bt,it=Math.max(it,Bt),qt=!0;break}}}catch(Dr){ln.e(Dr)}finally{ln.f()}qt||(me-=it)}}for(var Ee in ue){var cn=ue[Ee],In=this.directions[Ee];if(void 0!==In){Ae++;var un,kn=!1,Fr=0,wr=Dt(In);try{for(wr.s();!(un=wr.n()).done;){var us=Cn(un.value,2),$r=us[1];if(cn==us[0]){me+=$r,Fr=Math.max(Fr,$r),kn=!0;break}}}catch(Dr){wr.e(Dr)}finally{wr.f()}kn||(me-=Fr)}}return me/Ae*10}}])&&Xe(xe.prototype,et),qe}(),ie=new Ue("victory");ie.addDirection(ve.Thumb,Fe.VerticalUp,1),ie.addDirection(ve.Thumb,Fe.DiagonalUpLeft,1),ie.addDirection(ve.Thumb,Fe.DiagonalUpRight,1),ie.addCurl(ve.Index,Le.NoCurl,1),ie.addDirection(ve.Index,Fe.VerticalUp,1),ie.addDirection(ve.Index,Fe.DiagonalUpLeft,1),ie.addDirection(ve.Index,Fe.DiagonalUpRight,1),ie.addDirection(ve.Index,Fe.HorizontalLeft,1),ie.addDirection(ve.Index,Fe.HorizontalRight,1),ie.addCurl(ve.Middle,Le.NoCurl,1),ie.addDirection(ve.Middle,Fe.VerticalUp,1),ie.addDirection(ve.Middle,Fe.DiagonalUpLeft,1),ie.addDirection(ve.Middle,Fe.DiagonalUpRight,1),ie.addDirection(ve.Middle,Fe.HorizontalLeft,1),ie.addDirection(ve.Middle,Fe.HorizontalRight,1),ie.addCurl(ve.Ring,Le.FullCurl,1),ie.addCurl(ve.Ring,Le.HalfCurl,.9),ie.addCurl(ve.Pinky,Le.FullCurl,1),ie.addCurl(ve.Pinky,Le.HalfCurl,.9);var X=ie,ze=new Ue("thumbs_up");ze.addCurl(ve.Thumb,Le.NoCurl,1),ze.addDirection(ve.Thumb,Fe.VerticalUp,1),ze.addDirection(ve.Thumb,Fe.DiagonalUpLeft,.9),ze.addDirection(ve.Thumb,Fe.DiagonalUpRight,.9);for(var K=0,_t=[ve.Index,ve.Middle,ve.Ring,ve.Pinky];K<_t.length;K++){var Ot=_t[K];ze.addCurl(Ot,Le.FullCurl,1),ze.addCurl(Ot,Le.HalfCurl,.9)}ze.addDirection(ve.Index,Fe.DiagonalUpLeft,1),ze.addDirection(ve.Index,Fe.HorizontalLeft,1),ze.addDirection(ve.Index,Fe.HorizontalRight,1),ze.addDirection(ve.Index,Fe.DiagonalUpRight,1);var dt=ze;Y.default={GestureEstimator:Jt,GestureDescription:Ue,Finger:ve,FingerCurl:Le,FingerDirection:Fe,Gestures:ae}}]).default},9751:(Lt,ot,Y)=>{"use strict";Y.d(ot,{y:()=>nt});var P=Y(2961),ae=Y(727),Oe=Y(8822),ve=Y(9635),Le=Y(2416),Fe=Y(576),ct=Y(2806);let nt=(()=>{class _e{constructor($e){$e&&(this._subscribe=$e)}lift($e){const ut=new _e;return ut.source=this,ut.operator=$e,ut}subscribe($e,ut,vt){const bt=function we(_e){return _e&&_e instanceof P.Lv||function Ie(_e){return _e&&(0,Fe.m)(_e.next)&&(0,Fe.m)(_e.error)&&(0,Fe.m)(_e.complete)}(_e)&&(0,ae.Nn)(_e)}($e)?$e:new P.Hp($e,ut,vt);return(0,ct.x)(()=>{const{operator:Jt,source:Cn}=this;bt.add(Jt?Jt.call(bt,Cn):Cn?this._subscribe(bt):this._trySubscribe(bt))}),bt}_trySubscribe($e){try{return this._subscribe($e)}catch(ut){$e.error(ut)}}forEach($e,ut){return new(ut=he(ut))((vt,bt)=>{const Jt=new P.Hp({next:Cn=>{try{$e(Cn)}catch(Dt){bt(Dt),Jt.unsubscribe()}},error:bt,complete:vt});this.subscribe(Jt)})}_subscribe($e){var ut;return null===(ut=this.source)||void 0===ut?void 0:ut.subscribe($e)}[Oe.L](){return this}pipe(...$e){return(0,ve.U)($e)(this)}toPromise($e){return new($e=he($e))((ut,vt)=>{let bt;this.subscribe(Jt=>bt=Jt,Jt=>vt(Jt),()=>ut(bt))})}}return _e.create=Ge=>new _e(Ge),_e})();function he(_e){var Ge;return null!==(Ge=null!=_e?_e:Le.v.Promise)&&void 0!==Ge?Ge:Promise}},7579:(Lt,ot,Y)=>{"use strict";Y.d(ot,{x:()=>ct});var P=Y(9751),ae=Y(727);const ve=(0,Y(3888).d)(he=>function(){he(this),this.name="ObjectUnsubscribedError",this.message="object unsubscribed"});var Le=Y(8737),Fe=Y(2806);let ct=(()=>{class he extends P.y{constructor(){super(),this.closed=!1,this.currentObservers=null,this.observers=[],this.isStopped=!1,this.hasError=!1,this.thrownError=null}lift(we){const _e=new nt(this,this);return _e.operator=we,_e}_throwIfClosed(){if(this.closed)throw new ve}next(we){(0,Fe.x)(()=>{if(this._throwIfClosed(),!this.isStopped){this.currentObservers||(this.currentObservers=Array.from(this.observers));for(const _e of this.currentObservers)_e.next(we)}})}error(we){(0,Fe.x)(()=>{if(this._throwIfClosed(),!this.isStopped){this.hasError=this.isStopped=!0,this.thrownError=we;const{observers:_e}=this;for(;_e.length;)_e.shift().error(we)}})}complete(){(0,Fe.x)(()=>{if(this._throwIfClosed(),!this.isStopped){this.isStopped=!0;const{observers:we}=this;for(;we.length;)we.shift().complete()}})}unsubscribe(){this.isStopped=this.closed=!0,this.observers=this.currentObservers=null}get observed(){var we;return(null===(we=this.observers)||void 0===we?void 0:we.length)>0}_trySubscribe(we){return this._throwIfClosed(),super._trySubscribe(we)}_subscribe(we){return this._throwIfClosed(),this._checkFinalizedStatuses(we),this._innerSubscribe(we)}_innerSubscribe(we){const{hasError:_e,isStopped:Ge,observers:$e}=this;return _e||Ge?ae.Lc:(this.currentObservers=null,$e.push(we),new ae.w0(()=>{this.currentObservers=null,(0,Le.P)($e,we)}))}_checkFinalizedStatuses(we){const{hasError:_e,thrownError:Ge,isStopped:$e}=this;_e?we.error(Ge):$e&&we.complete()}asObservable(){const we=new P.y;return we.source=this,we}}return he.create=(Ie,we)=>new nt(Ie,we),he})();class nt extends ct{constructor(Ie,we){super(),this.destination=Ie,this.source=we}next(Ie){var we,_e;null===(_e=null===(we=this.destination)||void 0===we?void 0:we.next)||void 0===_e||_e.call(we,Ie)}error(Ie){var we,_e;null===(_e=null===(we=this.destination)||void 0===we?void 0:we.error)||void 0===_e||_e.call(we,Ie)}complete(){var Ie,we;null===(we=null===(Ie=this.destination)||void 0===Ie?void 0:Ie.complete)||void 0===we||we.call(Ie)}_subscribe(Ie){var we,_e;return null!==(_e=null===(we=this.source)||void 0===we?void 0:we.subscribe(Ie))&&void 0!==_e?_e:ae.Lc}}},2961:(Lt,ot,Y)=>{"use strict";Y.d(ot,{Hp:()=>vt,Lv:()=>_e});var P=Y(576),ae=Y(727),Oe=Y(2416),ve=Y(7849);function Le(){}const Fe=he("C",void 0,void 0);function he(at,Ze,Xe){return{kind:at,value:Ze,error:Xe}}var Ie=Y(3410),we=Y(2806);class _e extends ae.w0{constructor(Ze){super(),this.isStopped=!1,Ze?(this.destination=Ze,(0,ae.Nn)(Ze)&&Ze.add(this)):this.destination=Dt}static create(Ze,Xe,Ue){return new vt(Ze,Xe,Ue)}next(Ze){this.isStopped?Cn(function nt(at){return he("N",at,void 0)}(Ze),this):this._next(Ze)}error(Ze){this.isStopped?Cn(function ct(at){return he("E",void 0,at)}(Ze),this):(this.isStopped=!0,this._error(Ze))}complete(){this.isStopped?Cn(Fe,this):(this.isStopped=!0,this._complete())}unsubscribe(){this.closed||(this.isStopped=!0,super.unsubscribe(),this.destination=null)}_next(Ze){this.destination.next(Ze)}_error(Ze){try{this.destination.error(Ze)}finally{this.unsubscribe()}}_complete(){try{this.destination.complete()}finally{this.unsubscribe()}}}const Ge=Function.prototype.bind;function $e(at,Ze){return Ge.call(at,Ze)}class ut{constructor(Ze){this.partialObserver=Ze}next(Ze){const{partialObserver:Xe}=this;if(Xe.next)try{Xe.next(Ze)}catch(Ue){bt(Ue)}}error(Ze){const{partialObserver:Xe}=this;if(Xe.error)try{Xe.error(Ze)}catch(Ue){bt(Ue)}else bt(Ze)}complete(){const{partialObserver:Ze}=this;if(Ze.complete)try{Ze.complete()}catch(Xe){bt(Xe)}}}class vt extends _e{constructor(Ze,Xe,Ue){let ie;if(super(),(0,P.m)(Ze)||!Ze)ie={next:null!=Ze?Ze:void 0,error:null!=Xe?Xe:void 0,complete:null!=Ue?Ue:void 0};else{let X;this&&Oe.v.useDeprecatedNextContext?(X=Object.create(Ze),X.unsubscribe=()=>this.unsubscribe(),ie={next:Ze.next&&$e(Ze.next,X),error:Ze.error&&$e(Ze.error,X),complete:Ze.complete&&$e(Ze.complete,X)}):ie=Ze}this.destination=new ut(ie)}}function bt(at){Oe.v.useDeprecatedSynchronousErrorHandling?(0,we.O)(at):(0,ve.h)(at)}function Cn(at,Ze){const{onStoppedNotification:Xe}=Oe.v;Xe&&Ie.z.setTimeout(()=>Xe(at,Ze))}const Dt={closed:!0,next:Le,error:function Jt(at){throw at},complete:Le}},727:(Lt,ot,Y)=>{"use strict";Y.d(ot,{Lc:()=>Fe,w0:()=>Le,Nn:()=>ct});var P=Y(576);const Oe=(0,Y(3888).d)(he=>function(we){he(this),this.message=we?`${we.length} errors occurred during unsubscription:\n${we.map((_e,Ge)=>`${Ge+1}) ${_e.toString()}`).join("\n  ")}`:"",this.name="UnsubscriptionError",this.errors=we});var ve=Y(8737);class Le{constructor(Ie){this.initialTeardown=Ie,this.closed=!1,this._parentage=null,this._finalizers=null}unsubscribe(){let Ie;if(!this.closed){this.closed=!0;const{_parentage:we}=this;if(we)if(this._parentage=null,Array.isArray(we))for(const $e of we)$e.remove(this);else we.remove(this);const{initialTeardown:_e}=this;if((0,P.m)(_e))try{_e()}catch($e){Ie=$e instanceof Oe?$e.errors:[$e]}const{_finalizers:Ge}=this;if(Ge){this._finalizers=null;for(const $e of Ge)try{nt($e)}catch(ut){Ie=null!=Ie?Ie:[],ut instanceof Oe?Ie=[...Ie,...ut.errors]:Ie.push(ut)}}if(Ie)throw new Oe(Ie)}}add(Ie){var we;if(Ie&&Ie!==this)if(this.closed)nt(Ie);else{if(Ie instanceof Le){if(Ie.closed||Ie._hasParent(this))return;Ie._addParent(this)}(this._finalizers=null!==(we=this._finalizers)&&void 0!==we?we:[]).push(Ie)}}_hasParent(Ie){const{_parentage:we}=this;return we===Ie||Array.isArray(we)&&we.includes(Ie)}_addParent(Ie){const{_parentage:we}=this;this._parentage=Array.isArray(we)?(we.push(Ie),we):we?[we,Ie]:Ie}_removeParent(Ie){const{_parentage:we}=this;we===Ie?this._parentage=null:Array.isArray(we)&&(0,ve.P)(we,Ie)}remove(Ie){const{_finalizers:we}=this;we&&(0,ve.P)(we,Ie),Ie instanceof Le&&Ie._removeParent(this)}}Le.EMPTY=(()=>{const he=new Le;return he.closed=!0,he})();const Fe=Le.EMPTY;function ct(he){return he instanceof Le||he&&"closed"in he&&(0,P.m)(he.remove)&&(0,P.m)(he.add)&&(0,P.m)(he.unsubscribe)}function nt(he){(0,P.m)(he)?he():he.unsubscribe()}},2416:(Lt,ot,Y)=>{"use strict";Y.d(ot,{v:()=>P});const P={onUnhandledError:null,onStoppedNotification:null,Promise:void 0,useDeprecatedSynchronousErrorHandling:!1,useDeprecatedNextContext:!1}},515:(Lt,ot,Y)=>{"use strict";Y.d(ot,{E:()=>ae});const ae=new(Y(9751).y)(Le=>Le.complete())},2076:(Lt,ot,Y)=>{"use strict";Y.d(ot,{D:()=>Ue});var P=Y(8421),ae=Y(9672),Oe=Y(4482),ve=Y(5403);function Le(ie,X=0){return(0,Oe.e)((ze,K)=>{ze.subscribe((0,ve.x)(K,_t=>(0,ae.f)(K,ie,()=>K.next(_t),X),()=>(0,ae.f)(K,ie,()=>K.complete(),X),_t=>(0,ae.f)(K,ie,()=>K.error(_t),X)))})}function Fe(ie,X=0){return(0,Oe.e)((ze,K)=>{K.add(ie.schedule(()=>ze.subscribe(K),X))})}var he=Y(9751),we=Y(2202),_e=Y(576);function $e(ie,X){if(!ie)throw new Error("Iterable cannot be null");return new he.y(ze=>{(0,ae.f)(ze,X,()=>{const K=ie[Symbol.asyncIterator]();(0,ae.f)(ze,X,()=>{K.next().then(_t=>{_t.done?ze.complete():ze.next(_t.value)})},0,!0)})})}var ut=Y(3670),vt=Y(8239),bt=Y(1144),Jt=Y(6495),Cn=Y(2206),Dt=Y(4532),at=Y(3260);function Ue(ie,X){return X?function Xe(ie,X){if(null!=ie){if((0,ut.c)(ie))return function ct(ie,X){return(0,P.Xf)(ie).pipe(Fe(X),Le(X))}(ie,X);if((0,bt.z)(ie))return function Ie(ie,X){return new he.y(ze=>{let K=0;return X.schedule(function(){K===ie.length?ze.complete():(ze.next(ie[K++]),ze.closed||this.schedule())})})}(ie,X);if((0,vt.t)(ie))return function nt(ie,X){return(0,P.Xf)(ie).pipe(Fe(X),Le(X))}(ie,X);if((0,Cn.D)(ie))return $e(ie,X);if((0,Jt.T)(ie))return function Ge(ie,X){return new he.y(ze=>{let K;return(0,ae.f)(ze,X,()=>{K=ie[we.h](),(0,ae.f)(ze,X,()=>{let _t,Ot;try{({value:_t,done:Ot}=K.next())}catch(dt){return void ze.error(dt)}Ot?ze.complete():ze.next(_t)},0,!0)}),()=>(0,_e.m)(null==K?void 0:K.return)&&K.return()})}(ie,X);if((0,at.L)(ie))return function Ze(ie,X){return $e((0,at.Q)(ie),X)}(ie,X)}throw(0,Dt.z)(ie)}(ie,X):(0,P.Xf)(ie)}},8421:(Lt,ot,Y)=>{"use strict";Y.d(ot,{Xf:()=>Ge});var P=Y(7582),ae=Y(1144),Oe=Y(8239),ve=Y(9751),Le=Y(3670),Fe=Y(2206),ct=Y(4532),nt=Y(6495),he=Y(3260),Ie=Y(576),we=Y(7849),_e=Y(8822);function Ge(at){if(at instanceof ve.y)return at;if(null!=at){if((0,Le.c)(at))return function $e(at){return new ve.y(Ze=>{const Xe=at[_e.L]();if((0,Ie.m)(Xe.subscribe))return Xe.subscribe(Ze);throw new TypeError("Provided object does not correctly implement Symbol.observable")})}(at);if((0,ae.z)(at))return function ut(at){return new ve.y(Ze=>{for(let Xe=0;Xe<at.length&&!Ze.closed;Xe++)Ze.next(at[Xe]);Ze.complete()})}(at);if((0,Oe.t)(at))return function vt(at){return new ve.y(Ze=>{at.then(Xe=>{Ze.closed||(Ze.next(Xe),Ze.complete())},Xe=>Ze.error(Xe)).then(null,we.h)})}(at);if((0,Fe.D)(at))return Jt(at);if((0,nt.T)(at))return function bt(at){return new ve.y(Ze=>{for(const Xe of at)if(Ze.next(Xe),Ze.closed)return;Ze.complete()})}(at);if((0,he.L)(at))return function Cn(at){return Jt((0,he.Q)(at))}(at)}throw(0,ct.z)(at)}function Jt(at){return new ve.y(Ze=>{(function Dt(at,Ze){var Xe,Ue,ie,X;return(0,P.mG)(this,void 0,void 0,function*(){try{for(Xe=(0,P.KL)(at);!(Ue=yield Xe.next()).done;)if(Ze.next(Ue.value),Ze.closed)return}catch(ze){ie={error:ze}}finally{try{Ue&&!Ue.done&&(X=Xe.return)&&(yield X.call(Xe))}finally{if(ie)throw ie.error}}Ze.complete()})})(at,Ze).catch(Xe=>Ze.error(Xe))})}},5403:(Lt,ot,Y)=>{"use strict";Y.d(ot,{x:()=>ae});var P=Y(2961);function ae(ve,Le,Fe,ct,nt){return new Oe(ve,Le,Fe,ct,nt)}class Oe extends P.Lv{constructor(Le,Fe,ct,nt,he,Ie){super(Le),this.onFinalize=he,this.shouldUnsubscribe=Ie,this._next=Fe?function(we){try{Fe(we)}catch(_e){Le.error(_e)}}:super._next,this._error=nt?function(we){try{nt(we)}catch(_e){Le.error(_e)}finally{this.unsubscribe()}}:super._error,this._complete=ct?function(){try{ct()}catch(we){Le.error(we)}finally{this.unsubscribe()}}:super._complete}unsubscribe(){var Le;if(!this.shouldUnsubscribe||this.shouldUnsubscribe()){const{closed:Fe}=this;super.unsubscribe(),!Fe&&(null===(Le=this.onFinalize)||void 0===Le||Le.call(this))}}}},4004:(Lt,ot,Y)=>{"use strict";Y.d(ot,{U:()=>Oe});var P=Y(4482),ae=Y(5403);function Oe(ve,Le){return(0,P.e)((Fe,ct)=>{let nt=0;Fe.subscribe((0,ae.x)(ct,he=>{ct.next(ve.call(Le,he,nt++))}))})}},8189:(Lt,ot,Y)=>{"use strict";Y.d(ot,{J:()=>Oe});var P=Y(5577),ae=Y(4671);function Oe(ve=1/0){return(0,P.z)(ae.y,ve)}},5577:(Lt,ot,Y)=>{"use strict";Y.d(ot,{z:()=>nt});var P=Y(4004),ae=Y(8421),Oe=Y(4482),ve=Y(9672),Le=Y(5403),ct=Y(576);function nt(he,Ie,we=1/0){return(0,ct.m)(Ie)?nt((_e,Ge)=>(0,P.U)(($e,ut)=>Ie(_e,$e,Ge,ut))((0,ae.Xf)(he(_e,Ge))),we):("number"==typeof Ie&&(we=Ie),(0,Oe.e)((_e,Ge)=>function Fe(he,Ie,we,_e,Ge,$e,ut,vt){const bt=[];let Jt=0,Cn=0,Dt=!1;const at=()=>{Dt&&!bt.length&&!Jt&&Ie.complete()},Ze=Ue=>Jt<_e?Xe(Ue):bt.push(Ue),Xe=Ue=>{$e&&Ie.next(Ue),Jt++;let ie=!1;(0,ae.Xf)(we(Ue,Cn++)).subscribe((0,Le.x)(Ie,X=>{null==Ge||Ge(X),$e?Ze(X):Ie.next(X)},()=>{ie=!0},void 0,()=>{if(ie)try{for(Jt--;bt.length&&Jt<_e;){const X=bt.shift();ut?(0,ve.f)(Ie,ut,()=>Xe(X)):Xe(X)}at()}catch(X){Ie.error(X)}}))};return he.subscribe((0,Le.x)(Ie,Ze,()=>{Dt=!0,at()})),()=>{null==vt||vt()}}(_e,Ge,he,we)))}},3410:(Lt,ot,Y)=>{"use strict";Y.d(ot,{z:()=>P});const P={setTimeout(ae,Oe,...ve){const{delegate:Le}=P;return null!=Le&&Le.setTimeout?Le.setTimeout(ae,Oe,...ve):setTimeout(ae,Oe,...ve)},clearTimeout(ae){const{delegate:Oe}=P;return((null==Oe?void 0:Oe.clearTimeout)||clearTimeout)(ae)},delegate:void 0}},2202:(Lt,ot,Y)=>{"use strict";Y.d(ot,{h:()=>ae});const ae=function P(){return"function"==typeof Symbol&&Symbol.iterator?Symbol.iterator:"@@iterator"}()},8822:(Lt,ot,Y)=>{"use strict";Y.d(ot,{L:()=>P});const P="function"==typeof Symbol&&Symbol.observable||"@@observable"},7669:(Lt,ot,Y)=>{"use strict";Y.d(ot,{_6:()=>Fe,jO:()=>ve,yG:()=>Le});var P=Y(576);function Oe(ct){return ct[ct.length-1]}function ve(ct){return(0,P.m)(Oe(ct))?ct.pop():void 0}function Le(ct){return function ae(ct){return ct&&(0,P.m)(ct.schedule)}(Oe(ct))?ct.pop():void 0}function Fe(ct,nt){return"number"==typeof Oe(ct)?ct.pop():nt}},8737:(Lt,ot,Y)=>{"use strict";function P(ae,Oe){if(ae){const ve=ae.indexOf(Oe);0<=ve&&ae.splice(ve,1)}}Y.d(ot,{P:()=>P})},3888:(Lt,ot,Y)=>{"use strict";function P(ae){const ve=ae(Le=>{Error.call(Le),Le.stack=(new Error).stack});return ve.prototype=Object.create(Error.prototype),ve.prototype.constructor=ve,ve}Y.d(ot,{d:()=>P})},2806:(Lt,ot,Y)=>{"use strict";Y.d(ot,{O:()=>ve,x:()=>Oe});var P=Y(2416);let ae=null;function Oe(Le){if(P.v.useDeprecatedSynchronousErrorHandling){const Fe=!ae;if(Fe&&(ae={errorThrown:!1,error:null}),Le(),Fe){const{errorThrown:ct,error:nt}=ae;if(ae=null,ct)throw nt}}else Le()}function ve(Le){P.v.useDeprecatedSynchronousErrorHandling&&ae&&(ae.errorThrown=!0,ae.error=Le)}},9672:(Lt,ot,Y)=>{"use strict";function P(ae,Oe,ve,Le=0,Fe=!1){const ct=Oe.schedule(function(){ve(),Fe?ae.add(this.schedule(null,Le)):this.unsubscribe()},Le);if(ae.add(ct),!Fe)return ct}Y.d(ot,{f:()=>P})},4671:(Lt,ot,Y)=>{"use strict";function P(ae){return ae}Y.d(ot,{y:()=>P})},1144:(Lt,ot,Y)=>{"use strict";Y.d(ot,{z:()=>P});const P=ae=>ae&&"number"==typeof ae.length&&"function"!=typeof ae},2206:(Lt,ot,Y)=>{"use strict";Y.d(ot,{D:()=>ae});var P=Y(576);function ae(Oe){return Symbol.asyncIterator&&(0,P.m)(null==Oe?void 0:Oe[Symbol.asyncIterator])}},576:(Lt,ot,Y)=>{"use strict";function P(ae){return"function"==typeof ae}Y.d(ot,{m:()=>P})},3670:(Lt,ot,Y)=>{"use strict";Y.d(ot,{c:()=>Oe});var P=Y(8822),ae=Y(576);function Oe(ve){return(0,ae.m)(ve[P.L])}},6495:(Lt,ot,Y)=>{"use strict";Y.d(ot,{T:()=>Oe});var P=Y(2202),ae=Y(576);function Oe(ve){return(0,ae.m)(null==ve?void 0:ve[P.h])}},8239:(Lt,ot,Y)=>{"use strict";Y.d(ot,{t:()=>ae});var P=Y(576);function ae(Oe){return(0,P.m)(null==Oe?void 0:Oe.then)}},3260:(Lt,ot,Y)=>{"use strict";Y.d(ot,{L:()=>ve,Q:()=>Oe});var P=Y(7582),ae=Y(576);function Oe(Le){return(0,P.FC)(this,arguments,function*(){const ct=Le.getReader();try{for(;;){const{value:nt,done:he}=yield(0,P.qq)(ct.read());if(he)return yield(0,P.qq)(void 0);yield yield(0,P.qq)(nt)}}finally{ct.releaseLock()}})}function ve(Le){return(0,ae.m)(null==Le?void 0:Le.getReader)}},4482:(Lt,ot,Y)=>{"use strict";Y.d(ot,{A:()=>ae,e:()=>Oe});var P=Y(576);function ae(ve){return(0,P.m)(null==ve?void 0:ve.lift)}function Oe(ve){return Le=>{if(ae(Le))return Le.lift(function(Fe){try{return ve(Fe,this)}catch(ct){this.error(ct)}});throw new TypeError("Unable to lift unknown Observable type")}}},9635:(Lt,ot,Y)=>{"use strict";Y.d(ot,{U:()=>Oe,z:()=>ae});var P=Y(4671);function ae(...ve){return Oe(ve)}function Oe(ve){return 0===ve.length?P.y:1===ve.length?ve[0]:function(Fe){return ve.reduce((ct,nt)=>nt(ct),Fe)}}},7849:(Lt,ot,Y)=>{"use strict";Y.d(ot,{h:()=>Oe});var P=Y(2416),ae=Y(3410);function Oe(ve){ae.z.setTimeout(()=>{const{onUnhandledError:Le}=P.v;if(!Le)throw ve;Le(ve)})}},4532:(Lt,ot,Y)=>{"use strict";function P(ae){return new TypeError(`You provided ${null!==ae&&"object"==typeof ae?"an invalid object":`'${ae}'`} where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.`)}Y.d(ot,{z:()=>P})},340:(Lt,ot,Y)=>{var P=Y(9471),ae=Y(2992),Oe=Y(7657),ve=Y(5583),Le=Y(1929),Fe=Y(8083),ct=Y(3818);ct.alea=P,ct.xor128=ae,ct.xorwow=Oe,ct.xorshift7=ve,ct.xor4096=Le,ct.tychei=Fe,Lt.exports=ct},9471:function(Lt,ot,Y){var P;!function(ae,Oe,ve){function Le(he){var Ie=this,we=function nt(){var he=4022871197;return function(we){we=String(we);for(var _e=0;_e<we.length;_e++){var Ge=.02519603282416938*(he+=we.charCodeAt(_e));Ge-=he=Ge>>>0,he=(Ge*=he)>>>0,he+=4294967296*(Ge-=he)}return 2.3283064365386963e-10*(he>>>0)}}();Ie.next=function(){var _e=2091639*Ie.s0+2.3283064365386963e-10*Ie.c;return Ie.s0=Ie.s1,Ie.s1=Ie.s2,Ie.s2=_e-(Ie.c=0|_e)},Ie.c=1,Ie.s0=we(" "),Ie.s1=we(" "),Ie.s2=we(" "),Ie.s0-=we(he),Ie.s0<0&&(Ie.s0+=1),Ie.s1-=we(he),Ie.s1<0&&(Ie.s1+=1),Ie.s2-=we(he),Ie.s2<0&&(Ie.s2+=1),we=null}function Fe(he,Ie){return Ie.c=he.c,Ie.s0=he.s0,Ie.s1=he.s1,Ie.s2=he.s2,Ie}function ct(he,Ie){var we=new Le(he),_e=Ie&&Ie.state,Ge=we.next;return Ge.int32=function(){return 4294967296*we.next()|0},Ge.double=function(){return Ge()+11102230246251565e-32*(2097152*Ge()|0)},Ge.quick=Ge,_e&&("object"==typeof _e&&Fe(_e,we),Ge.state=function(){return Fe(we,{})}),Ge}Oe&&Oe.exports?Oe.exports=ct:Y.amdD&&Y.amdO?void 0!==(P=function(){return ct}.call(ot,Y,ot,Oe))&&(Oe.exports=P):this.alea=ct}(0,Lt=Y.nmd(Lt))},8083:function(Lt,ot,Y){var P;!function(ae,Oe,ve){function Le(nt){var he=this,Ie="";he.next=function(){var _e=he.b,Ge=he.c,$e=he.d,ut=he.a;return _e=_e<<25^_e>>>7^Ge,Ge=Ge-$e|0,$e=$e<<24^$e>>>8^ut,ut=ut-_e|0,he.b=_e=_e<<20^_e>>>12^Ge,he.c=Ge=Ge-$e|0,he.d=$e<<16^Ge>>>16^ut,he.a=ut-_e|0},he.a=0,he.b=0,he.c=-1640531527,he.d=1367130551,nt===Math.floor(nt)?(he.a=nt/4294967296|0,he.b=0|nt):Ie+=nt;for(var we=0;we<Ie.length+20;we++)he.b^=0|Ie.charCodeAt(we),he.next()}function Fe(nt,he){return he.a=nt.a,he.b=nt.b,he.c=nt.c,he.d=nt.d,he}function ct(nt,he){var Ie=new Le(nt),we=he&&he.state,_e=function(){return(Ie.next()>>>0)/4294967296};return _e.double=function(){do{var ut=((Ie.next()>>>11)+(Ie.next()>>>0)/4294967296)/(1<<21)}while(0===ut);return ut},_e.int32=Ie.next,_e.quick=_e,we&&("object"==typeof we&&Fe(we,Ie),_e.state=function(){return Fe(Ie,{})}),_e}Oe&&Oe.exports?Oe.exports=ct:Y.amdD&&Y.amdO?void 0!==(P=function(){return ct}.call(ot,Y,ot,Oe))&&(Oe.exports=P):this.tychei=ct}(0,Lt=Y.nmd(Lt))},2992:function(Lt,ot,Y){var P;!function(ae,Oe,ve){function Le(nt){var he=this,Ie="";he.x=0,he.y=0,he.z=0,he.w=0,he.next=function(){var _e=he.x^he.x<<11;return he.x=he.y,he.y=he.z,he.z=he.w,he.w^=he.w>>>19^_e^_e>>>8},nt===(0|nt)?he.x=nt:Ie+=nt;for(var we=0;we<Ie.length+64;we++)he.x^=0|Ie.charCodeAt(we),he.next()}function Fe(nt,he){return he.x=nt.x,he.y=nt.y,he.z=nt.z,he.w=nt.w,he}function ct(nt,he){var Ie=new Le(nt),we=he&&he.state,_e=function(){return(Ie.next()>>>0)/4294967296};return _e.double=function(){do{var ut=((Ie.next()>>>11)+(Ie.next()>>>0)/4294967296)/(1<<21)}while(0===ut);return ut},_e.int32=Ie.next,_e.quick=_e,we&&("object"==typeof we&&Fe(we,Ie),_e.state=function(){return Fe(Ie,{})}),_e}Oe&&Oe.exports?Oe.exports=ct:Y.amdD&&Y.amdO?void 0!==(P=function(){return ct}.call(ot,Y,ot,Oe))&&(Oe.exports=P):this.xor128=ct}(0,Lt=Y.nmd(Lt))},1929:function(Lt,ot,Y){var P;!function(ae,Oe,ve){function Le(nt){var he=this;he.next=function(){var $e,ut,we=he.w,_e=he.X,Ge=he.i;return he.w=we=we+1640531527|0,ut=_e[Ge+34&127],$e=_e[Ge=Ge+1&127],ut^=ut<<13,$e^=$e<<17,ut=_e[Ge]=(ut^=ut>>>15)^($e^=$e>>>12),he.i=Ge,ut+(we^we>>>16)|0},function Ie(we,_e){var Ge,$e,ut,vt,bt,Jt=[],Cn=128;for(_e===(0|_e)?($e=_e,_e=null):(_e+="\0",$e=0,Cn=Math.max(Cn,_e.length)),ut=0,vt=-32;vt<Cn;++vt)_e&&($e^=_e.charCodeAt((vt+32)%_e.length)),0===vt&&(bt=$e),$e^=$e<<10,$e^=$e>>>15,$e^=$e<<4,$e^=$e>>>13,vt>=0&&(ut=0==(Ge=Jt[127&vt]^=$e+(bt=bt+1640531527|0))?ut+1:0);for(ut>=128&&(Jt[127&(_e&&_e.length||0)]=-1),ut=127,vt=512;vt>0;--vt)$e=Jt[ut+34&127],Ge=Jt[ut=ut+1&127],$e^=$e<<13,Ge^=Ge<<17,Jt[ut]=($e^=$e>>>15)^(Ge^=Ge>>>12);we.w=bt,we.X=Jt,we.i=ut}(he,nt)}function Fe(nt,he){return he.i=nt.i,he.w=nt.w,he.X=nt.X.slice(),he}function ct(nt,he){null==nt&&(nt=+new Date);var Ie=new Le(nt),we=he&&he.state,_e=function(){return(Ie.next()>>>0)/4294967296};return _e.double=function(){do{var ut=((Ie.next()>>>11)+(Ie.next()>>>0)/4294967296)/(1<<21)}while(0===ut);return ut},_e.int32=Ie.next,_e.quick=_e,we&&(we.X&&Fe(we,Ie),_e.state=function(){return Fe(Ie,{})}),_e}Oe&&Oe.exports?Oe.exports=ct:Y.amdD&&Y.amdO?void 0!==(P=function(){return ct}.call(ot,Y,ot,Oe))&&(Oe.exports=P):this.xor4096=ct}(0,Lt=Y.nmd(Lt))},5583:function(Lt,ot,Y){var P;!function(ae,Oe,ve){function Le(nt){var he=this;he.next=function(){var Ge,$e,we=he.x,_e=he.i;return Ge=we[_e],$e=(Ge^=Ge>>>7)^Ge<<24,$e^=(Ge=we[_e+1&7])^Ge>>>10,$e^=(Ge=we[_e+3&7])^Ge>>>3,$e^=(Ge=we[_e+4&7])^Ge<<7,Ge=we[_e+7&7],we[_e]=$e^=(Ge^=Ge<<13)^Ge<<9,he.i=_e+1&7,$e},function Ie(we,_e){var Ge,ut=[];if(_e===(0|_e))ut[0]=_e;else for(_e=""+_e,Ge=0;Ge<_e.length;++Ge)ut[7&Ge]=ut[7&Ge]<<15^_e.charCodeAt(Ge)+ut[Ge+1&7]<<13;for(;ut.length<8;)ut.push(0);for(Ge=0;Ge<8&&0===ut[Ge];++Ge);for(8==Ge&&(ut[7]=-1),we.x=ut,we.i=0,Ge=256;Ge>0;--Ge)we.next()}(he,nt)}function Fe(nt,he){return he.x=nt.x.slice(),he.i=nt.i,he}function ct(nt,he){null==nt&&(nt=+new Date);var Ie=new Le(nt),we=he&&he.state,_e=function(){return(Ie.next()>>>0)/4294967296};return _e.double=function(){do{var ut=((Ie.next()>>>11)+(Ie.next()>>>0)/4294967296)/(1<<21)}while(0===ut);return ut},_e.int32=Ie.next,_e.quick=_e,we&&(we.x&&Fe(we,Ie),_e.state=function(){return Fe(Ie,{})}),_e}Oe&&Oe.exports?Oe.exports=ct:Y.amdD&&Y.amdO?void 0!==(P=function(){return ct}.call(ot,Y,ot,Oe))&&(Oe.exports=P):this.xorshift7=ct}(0,Lt=Y.nmd(Lt))},7657:function(Lt,ot,Y){var P;!function(ae,Oe,ve){function Le(nt){var he=this,Ie="";he.next=function(){var _e=he.x^he.x>>>2;return he.x=he.y,he.y=he.z,he.z=he.w,he.w=he.v,(he.d=he.d+362437|0)+(he.v=he.v^he.v<<4^_e^_e<<1)|0},he.x=0,he.y=0,he.z=0,he.w=0,he.v=0,nt===(0|nt)?he.x=nt:Ie+=nt;for(var we=0;we<Ie.length+64;we++)he.x^=0|Ie.charCodeAt(we),we==Ie.length&&(he.d=he.x<<10^he.x>>>4),he.next()}function Fe(nt,he){return he.x=nt.x,he.y=nt.y,he.z=nt.z,he.w=nt.w,he.v=nt.v,he.d=nt.d,he}function ct(nt,he){var Ie=new Le(nt),we=he&&he.state,_e=function(){return(Ie.next()>>>0)/4294967296};return _e.double=function(){do{var ut=((Ie.next()>>>11)+(Ie.next()>>>0)/4294967296)/(1<<21)}while(0===ut);return ut},_e.int32=Ie.next,_e.quick=_e,we&&("object"==typeof we&&Fe(we,Ie),_e.state=function(){return Fe(Ie,{})}),_e}Oe&&Oe.exports?Oe.exports=ct:Y.amdD&&Y.amdO?void 0!==(P=function(){return ct}.call(ot,Y,ot,Oe))&&(Oe.exports=P):this.xorwow=ct}(0,Lt=Y.nmd(Lt))},3818:function(Lt,ot,Y){var P;!function(ae,Oe,ve){var Ge,Le=256,he=ve.pow(Le,6),Ie=ve.pow(2,52),we=2*Ie;function $e(at,Ze,Xe){var Ue=[],ie=Jt(bt((Ze=1==Ze?{entropy:!0}:Ze||{}).entropy?[at,Dt(Oe)]:null==at?function Cn(){try{var at;return Ge&&(at=Ge.randomBytes)?at=at(Le):(at=new Uint8Array(Le),(ae.crypto||ae.msCrypto).getRandomValues(at)),Dt(at)}catch(Ue){var Ze=ae.navigator,Xe=Ze&&Ze.plugins;return[+new Date,ae,Xe,ae.screen,Dt(Oe)]}}():at,3),Ue),X=new ut(Ue),ze=function(){for(var K=X.g(6),_t=he,Ot=0;K<Ie;)K=(K+Ot)*Le,_t*=Le,Ot=X.g(1);for(;K>=we;)K/=2,_t/=2,Ot>>>=1;return(K+Ot)/_t};return ze.int32=function(){return 0|X.g(4)},ze.quick=function(){return X.g(4)/4294967296},ze.double=ze,Jt(Dt(X.S),Oe),(Ze.pass||Xe||function(K,_t,Ot,dt){return dt&&(dt.S&&vt(dt,X),K.state=function(){return vt(X,{})}),Ot?(ve.random=K,_t):K})(ze,ie,"global"in Ze?Ze.global:this==ve,Ze.state)}function ut(at){var Ze,Xe=at.length,Ue=this,ie=0,X=Ue.i=Ue.j=0,ze=Ue.S=[];for(Xe||(at=[Xe++]);ie<Le;)ze[ie]=ie++;for(ie=0;ie<Le;ie++)ze[ie]=ze[X=255&X+at[ie%Xe]+(Ze=ze[ie])],ze[X]=Ze;(Ue.g=function(K){for(var _t,Ot=0,dt=Ue.i,qe=Ue.j,xe=Ue.S;K--;)_t=xe[dt=255&dt+1],Ot=Ot*Le+xe[255&(xe[dt]=xe[qe=255&qe+_t])+(xe[qe]=_t)];return Ue.i=dt,Ue.j=qe,Ot})(Le)}function vt(at,Ze){return Ze.i=at.i,Ze.j=at.j,Ze.S=at.S.slice(),Ze}function bt(at,Ze){var ie,Xe=[],Ue=typeof at;if(Ze&&"object"==Ue)for(ie in at)try{Xe.push(bt(at[ie],Ze-1))}catch(X){}return Xe.length?Xe:"string"==Ue?at:at+"\0"}function Jt(at,Ze){for(var Ue,Xe=at+"",ie=0;ie<Xe.length;)Ze[255&ie]=255&(Ue^=19*Ze[255&ie])+Xe.charCodeAt(ie++);return Dt(Ze)}function Dt(at){return String.fromCharCode.apply(0,at)}if(Jt(ve.random(),Oe),Lt.exports){Lt.exports=$e;try{Ge=Y(5042)}catch(at){}}else void 0!==(P=function(){return $e}.call(ot,Y,ot,Lt))&&(Lt.exports=P)}("undefined"!=typeof self?self:this,[],Math)},5410:()=>{},8628:()=>{},5042:()=>{},9808:(Lt,ot,Y)=>{"use strict";Y.d(ot,{Do:()=>Dt,EM:()=>Ca,HT:()=>Le,JF:()=>pi,K0:()=>ct,Mx:()=>tr,NF:()=>To,S$:()=>bt,V_:()=>Ie,Ye:()=>at,b0:()=>Cn,bD:()=>Do,ez:()=>Vr,q:()=>Oe,w_:()=>Fe});var P=Y(1223);let ae=null;function Oe(){return ae}function Le(k){ae||(ae=k)}class Fe{}const ct=new P.OlP("DocumentToken");let nt=(()=>{class k{historyGo(M){throw new Error("Not implemented")}}return k.\u0275fac=function(M){return new(M||k)},k.\u0275prov=P.Yz7({token:k,factory:function(){return function he(){return(0,P.LFG)(we)}()},providedIn:"platform"}),k})();const Ie=new P.OlP("Location Initialized");let we=(()=>{class k extends nt{constructor(M){super(),this._doc=M,this._init()}_init(){this.location=window.location,this._history=window.history}getBaseHrefFromDOM(){return Oe().getBaseHref(this._doc)}onPopState(M){const H=Oe().getGlobalEventTarget(this._doc,"window");return H.addEventListener("popstate",M,!1),()=>H.removeEventListener("popstate",M)}onHashChange(M){const H=Oe().getGlobalEventTarget(this._doc,"window");return H.addEventListener("hashchange",M,!1),()=>H.removeEventListener("hashchange",M)}get href(){return this.location.href}get protocol(){return this.location.protocol}get hostname(){return this.location.hostname}get port(){return this.location.port}get pathname(){return this.location.pathname}get search(){return this.location.search}get hash(){return this.location.hash}set pathname(M){this.location.pathname=M}pushState(M,H,oe){_e()?this._history.pushState(M,H,oe):this.location.hash=oe}replaceState(M,H,oe){_e()?this._history.replaceState(M,H,oe):this.location.hash=oe}forward(){this._history.forward()}back(){this._history.back()}historyGo(M=0){this._history.go(M)}getState(){return this._history.state}}return k.\u0275fac=function(M){return new(M||k)(P.LFG(ct))},k.\u0275prov=P.Yz7({token:k,factory:function(){return function Ge(){return new we((0,P.LFG)(ct))}()},providedIn:"platform"}),k})();function _e(){return!!window.history.pushState}function $e(k,B){if(0==k.length)return B;if(0==B.length)return k;let M=0;return k.endsWith("/")&&M++,B.startsWith("/")&&M++,2==M?k+B.substring(1):1==M?k+B:k+"/"+B}function ut(k){const B=k.match(/#|\?|$/),M=B&&B.index||k.length;return k.slice(0,M-("/"===k[M-1]?1:0))+k.slice(M)}function vt(k){return k&&"?"!==k[0]?"?"+k:k}let bt=(()=>{class k{historyGo(M){throw new Error("Not implemented")}}return k.\u0275fac=function(M){return new(M||k)},k.\u0275prov=P.Yz7({token:k,factory:function(){return(0,P.f3M)(Cn)},providedIn:"root"}),k})();const Jt=new P.OlP("appBaseHref");let Cn=(()=>{class k extends bt{constructor(M,H){var oe,Pe,Ye;super(),this._platformLocation=M,this._removeListenerFns=[],this._baseHref=null!==(Ye=null!==(oe=null!=H?H:this._platformLocation.getBaseHrefFromDOM())&&void 0!==oe?oe:null===(Pe=(0,P.f3M)(ct).location)||void 0===Pe?void 0:Pe.origin)&&void 0!==Ye?Ye:""}ngOnDestroy(){for(;this._removeListenerFns.length;)this._removeListenerFns.pop()()}onPopState(M){this._removeListenerFns.push(this._platformLocation.onPopState(M),this._platformLocation.onHashChange(M))}getBaseHref(){return this._baseHref}prepareExternalUrl(M){return $e(this._baseHref,M)}path(M=!1){const H=this._platformLocation.pathname+vt(this._platformLocation.search),oe=this._platformLocation.hash;return oe&&M?`${H}${oe}`:H}pushState(M,H,oe,Pe){const Ye=this.prepareExternalUrl(oe+vt(Pe));this._platformLocation.pushState(M,H,Ye)}replaceState(M,H,oe,Pe){const Ye=this.prepareExternalUrl(oe+vt(Pe));this._platformLocation.replaceState(M,H,Ye)}forward(){this._platformLocation.forward()}back(){this._platformLocation.back()}getState(){return this._platformLocation.getState()}historyGo(M=0){var H,oe;null===(oe=(H=this._platformLocation).historyGo)||void 0===oe||oe.call(H,M)}}return k.\u0275fac=function(M){return new(M||k)(P.LFG(nt),P.LFG(Jt,8))},k.\u0275prov=P.Yz7({token:k,factory:k.\u0275fac,providedIn:"root"}),k})(),Dt=(()=>{class k extends bt{constructor(M,H){super(),this._platformLocation=M,this._baseHref="",this._removeListenerFns=[],null!=H&&(this._baseHref=H)}ngOnDestroy(){for(;this._removeListenerFns.length;)this._removeListenerFns.pop()()}onPopState(M){this._removeListenerFns.push(this._platformLocation.onPopState(M),this._platformLocation.onHashChange(M))}getBaseHref(){return this._baseHref}path(M=!1){let H=this._platformLocation.hash;return null==H&&(H="#"),H.length>0?H.substring(1):H}prepareExternalUrl(M){const H=$e(this._baseHref,M);return H.length>0?"#"+H:H}pushState(M,H,oe,Pe){let Ye=this.prepareExternalUrl(oe+vt(Pe));0==Ye.length&&(Ye=this._platformLocation.pathname),this._platformLocation.pushState(M,H,Ye)}replaceState(M,H,oe,Pe){let Ye=this.prepareExternalUrl(oe+vt(Pe));0==Ye.length&&(Ye=this._platformLocation.pathname),this._platformLocation.replaceState(M,H,Ye)}forward(){this._platformLocation.forward()}back(){this._platformLocation.back()}getState(){return this._platformLocation.getState()}historyGo(M=0){var H,oe;null===(oe=(H=this._platformLocation).historyGo)||void 0===oe||oe.call(H,M)}}return k.\u0275fac=function(M){return new(M||k)(P.LFG(nt),P.LFG(Jt,8))},k.\u0275prov=P.Yz7({token:k,factory:k.\u0275fac}),k})(),at=(()=>{class k{constructor(M){this._subject=new P.vpe,this._urlChangeListeners=[],this._urlChangeSubscription=null,this._locationStrategy=M;const H=this._locationStrategy.getBaseHref();this._baseHref=ut(Ue(H)),this._locationStrategy.onPopState(oe=>{this._subject.emit({url:this.path(!0),pop:!0,state:oe.state,type:oe.type})})}ngOnDestroy(){var M;null===(M=this._urlChangeSubscription)||void 0===M||M.unsubscribe(),this._urlChangeListeners=[]}path(M=!1){return this.normalize(this._locationStrategy.path(M))}getState(){return this._locationStrategy.getState()}isCurrentPathEqualTo(M,H=""){return this.path()==this.normalize(M+vt(H))}normalize(M){return k.stripTrailingSlash(function Xe(k,B){return k&&B.startsWith(k)?B.substring(k.length):B}(this._baseHref,Ue(M)))}prepareExternalUrl(M){return M&&"/"!==M[0]&&(M="/"+M),this._locationStrategy.prepareExternalUrl(M)}go(M,H="",oe=null){this._locationStrategy.pushState(oe,"",M,H),this._notifyUrlChangeListeners(this.prepareExternalUrl(M+vt(H)),oe)}replaceState(M,H="",oe=null){this._locationStrategy.replaceState(oe,"",M,H),this._notifyUrlChangeListeners(this.prepareExternalUrl(M+vt(H)),oe)}forward(){this._locationStrategy.forward()}back(){this._locationStrategy.back()}historyGo(M=0){var H,oe;null===(oe=(H=this._locationStrategy).historyGo)||void 0===oe||oe.call(H,M)}onUrlChange(M){return this._urlChangeListeners.push(M),this._urlChangeSubscription||(this._urlChangeSubscription=this.subscribe(H=>{this._notifyUrlChangeListeners(H.url,H.state)})),()=>{var H;const oe=this._urlChangeListeners.indexOf(M);this._urlChangeListeners.splice(oe,1),0===this._urlChangeListeners.length&&(null===(H=this._urlChangeSubscription)||void 0===H||H.unsubscribe(),this._urlChangeSubscription=null)}}_notifyUrlChangeListeners(M="",H){this._urlChangeListeners.forEach(oe=>oe(M,H))}subscribe(M,H,oe){return this._subject.subscribe({next:M,error:H,complete:oe})}}return k.normalizeQueryParams=vt,k.joinWithSlash=$e,k.stripTrailingSlash=ut,k.\u0275fac=function(M){return new(M||k)(P.LFG(bt))},k.\u0275prov=P.Yz7({token:k,factory:function(){return function Ze(){return new at((0,P.LFG)(bt))}()},providedIn:"root"}),k})();function Ue(k){return k.replace(/\/index.html$/,"")}function tr(k,B){B=encodeURIComponent(B);for(const M of k.split(";")){const H=M.indexOf("="),[oe,Pe]=-1==H?[M,""]:[M.slice(0,H),M.slice(H+1)];if(oe.trim()===B)return decodeURIComponent(Pe)}return null}let Vr=(()=>{class k{}return k.\u0275fac=function(M){return new(M||k)},k.\u0275mod=P.oAB({type:k}),k.\u0275inj=P.cJS({}),k})();const Do="browser";function To(k){return k===Do}let Ca=(()=>{class k{}return k.\u0275prov=(0,P.Yz7)({token:k,providedIn:"root",factory:()=>new ts((0,P.LFG)(ct),window)}),k})();class ts{constructor(B,M){this.document=B,this.window=M,this.offset=()=>[0,0]}setOffset(B){this.offset=Array.isArray(B)?()=>B:B}getScrollPosition(){return this.supportsScrolling()?[this.window.pageXOffset,this.window.pageYOffset]:[0,0]}scrollToPosition(B){this.supportsScrolling()&&this.window.scrollTo(B[0],B[1])}scrollToAnchor(B){if(!this.supportsScrolling())return;const M=function Ui(k,B){const M=k.getElementById(B)||k.getElementsByName(B)[0];if(M)return M;if("function"==typeof k.createTreeWalker&&k.body&&(k.body.createShadowRoot||k.body.attachShadow)){const H=k.createTreeWalker(k.body,NodeFilter.SHOW_ELEMENT);let oe=H.currentNode;for(;oe;){const Pe=oe.shadowRoot;if(Pe){const Ye=Pe.getElementById(B)||Pe.querySelector(`[name="${B}"]`);if(Ye)return Ye}oe=H.nextNode()}}return null}(this.document,B);M&&(this.scrollToElement(M),M.focus())}setHistoryScrollRestoration(B){if(this.supportScrollRestoration()){const M=this.window.history;M&&M.scrollRestoration&&(M.scrollRestoration=B)}}scrollToElement(B){const M=B.getBoundingClientRect(),H=M.left+this.window.pageXOffset,oe=M.top+this.window.pageYOffset,Pe=this.offset();this.window.scrollTo(H-Pe[0],oe-Pe[1])}supportScrollRestoration(){try{if(!this.supportsScrolling())return!1;const B=No(this.window.history)||No(Object.getPrototypeOf(this.window.history));return!(!B||!B.writable&&!B.set)}catch(B){return!1}}supportsScrolling(){try{return!!this.window&&!!this.window.scrollTo&&"pageXOffset"in this.window}catch(B){return!1}}}function No(k){return Object.getOwnPropertyDescriptor(k,"scrollRestoration")}class pi{}},1223:(Lt,ot,Y)=>{"use strict";Y.d(ot,{QbO:()=>QS,tb:()=>YS,AFp:()=>Wl,ip1:()=>op,CZH:()=>ip,hGG:()=>DE,z2F:()=>wy,sBO:()=>Cy,Sil:()=>eE,_Vd:()=>Su,EJc:()=>py,Xts:()=>Pd,SBq:()=>Dc,lqb:()=>ja,qLn:()=>Bd,vpe:()=>ai,XFs:()=>St,OlP:()=>Gn,zs3:()=>Nc,ZZ4:()=>At,aQg:()=>Iy,soG:()=>fy,YKP:()=>t_,h0i:()=>Yu,PXZ:()=>lE,R0b:()=>li,FiY:()=>gu,Lbi:()=>XS,g9A:()=>A_,Qsj:()=>Mw,FYo:()=>cf,JOm:()=>ni,tp0:()=>is,Rgc:()=>Uc,dDg:()=>tT,eoX:()=>$_,GfV:()=>Hv,s_b:()=>ch,ifc:()=>zn,MMx:()=>Ag,Lck:()=>vS,eFA:()=>jl,G48:()=>U_,f3M:()=>zh,X6Q:()=>hp,_c5:()=>IE,c2e:()=>jD,zSh:()=>gm,wAp:()=>on,vHH:()=>Xe,lri:()=>iE,rWj:()=>F_,D6c:()=>X_,cg1:()=>Jd,kL8:()=>Rb,dqk:()=>Zt,Z0I:()=>un,sIi:()=>Kd,CqO:()=>ZC,QGY:()=>ug,QP$:()=>Qt,F4k:()=>YC,RDi:()=>lw,AaK:()=>vt,TTD:()=>fi,_Bn:()=>e_,jDz:()=>r_,xp6:()=>Po,uIk:()=>sg,Suo:()=>Qg,Xpm:()=>Jr,lG2:()=>Q,Yz7:()=>Bt,cJS:()=>cn,oAB:()=>Gs,Yjl:()=>ge,Y36:()=>kc,_UZ:()=>lg,qZA:()=>kf,TgZ:()=>Nf,LFG:()=>br,$8M:()=>Un,$Z:()=>s0,NdJ:()=>Xd,CRH:()=>Jg,kcU:()=>_l,O4$:()=>Aa,Q6J:()=>ig,iGM:()=>Yg,LSH:()=>rf,_uU:()=>mb,Oqu:()=>Rf,Gf:()=>Zg});var P=Y(7579),ae=Y(727),Oe=Y(9751),ve=Y(8189),Le=Y(8421),Fe=Y(515),ct=Y(7669),nt=Y(2076),Ie=Y(2961),we=Y(4482);function Ge(i,a,...c){if(!0===a)return void i();if(!1===a)return;const f=new Ie.Hp({next:()=>{f.unsubscribe(),i()}});return a(...c).subscribe(f)}function $e(i){for(let a in i)if(i[a]===$e)return a;throw Error("Could not find renamed property on target object.")}function vt(i){if("string"==typeof i)return i;if(Array.isArray(i))return"["+i.map(vt).join(", ")+"]";if(null==i)return""+i;if(i.overriddenName)return`${i.overriddenName}`;if(i.name)return`${i.name}`;const a=i.toString();if(null==a)return""+a;const c=a.indexOf("\n");return-1===c?a:a.substring(0,c)}function bt(i,a){return null==i||""===i?null===a?"":a:null==a||""===a?i:i+" "+a}const Jt=$e({__forward_ref__:$e});function Cn(i){return i.__forward_ref__=Cn,i.toString=function(){return vt(this())},i}function Dt(i){return function at(i){return"function"==typeof i&&i.hasOwnProperty(Jt)&&i.__forward_ref__===Cn}(i)?i():i}class Xe extends Error{constructor(a,c){super(function Ue(i,a){return`NG0${Math.abs(i)}${a?": "+a.trim():""}`}(a,c)),this.code=a}}function ie(i){return"string"==typeof i?i:null==i?"":String(i)}function Ot(i,a){throw new Xe(-201,!1)}function qt(i,a){null==i&&function it(i,a,c,f){throw new Error(`ASSERTION ERROR: ${i}`+(null==f?"":` [Expected=> ${c} ${f} ${a} <=Actual]`))}(a,i,null,"!=")}function Bt(i){return{token:i.token,providedIn:i.providedIn||null,factory:i.factory,value:void 0}}function cn(i){return{providers:i.providers||[],imports:i.imports||[]}}function In(i){return kn(i,vr)||kn(i,Dr)}function un(i){return null!==In(i)}function kn(i,a){return i.hasOwnProperty(a)?i[a]:null}function us(i){return i&&(i.hasOwnProperty($r)||i.hasOwnProperty(Tt))?i[$r]:null}const vr=$e({\u0275prov:$e}),$r=$e({\u0275inj:$e}),Dr=$e({ngInjectableDef:$e}),Tt=$e({ngInjectorDef:$e});var St=(()=>((St=St||{})[St.Default=0]="Default",St[St.Host=1]="Host",St[St.Self=2]="Self",St[St.SkipSelf=4]="SkipSelf",St[St.Optional=8]="Optional",St))();let Rt;function Kn(i){const a=Rt;return Rt=i,a}function no(i,a,c){const f=In(i);return f&&"root"==f.providedIn?void 0===f.value?f.value=f.factory():f.value:c&St.Optional?null:void 0!==a?a:void Ot(vt(i))}function Cr(i){return{toString:i}.toString()}var qn=(()=>((qn=qn||{})[qn.OnPush=0]="OnPush",qn[qn.Default=1]="Default",qn))(),zn=(()=>{return(i=zn||(zn={}))[i.Emulated=0]="Emulated",i[i.None=2]="None",i[i.ShadowDom=3]="ShadowDom",zn;var i})();const Zt=(()=>"undefined"!=typeof globalThis&&globalThis||"undefined"!=typeof global&&global||"undefined"!=typeof window&&window||"undefined"!=typeof self&&"undefined"!=typeof WorkerGlobalScope&&self instanceof WorkerGlobalScope&&self)(),Wt={},Sn=[],Pr=$e({\u0275cmp:$e}),ya=$e({\u0275dir:$e}),_o=$e({\u0275pipe:$e}),er=$e({\u0275mod:$e}),ds=$e({\u0275fac:$e}),Sr=$e({__NG_ELEMENT_ID__:$e});let Qr=0;function Jr(i){return Cr(()=>{const c=!0===i.standalone,f={},m={type:i.type,providersResolver:null,decls:i.decls,vars:i.vars,factory:null,template:i.template||null,consts:i.consts||null,ngContentSelectors:i.ngContentSelectors,hostBindings:i.hostBindings||null,hostVars:i.hostVars||0,hostAttrs:i.hostAttrs||null,contentQueries:i.contentQueries||null,declaredInputs:f,inputs:null,outputs:null,exportAs:i.exportAs||null,onPush:i.changeDetection===qn.OnPush,directiveDefs:null,pipeDefs:null,standalone:c,dependencies:c&&i.dependencies||null,getStandaloneInjector:null,selectors:i.selectors||Sn,viewQuery:i.viewQuery||null,features:i.features||null,data:i.data||{},encapsulation:i.encapsulation||zn.Emulated,id:"c"+Qr++,styles:i.styles||Sn,_:null,setInput:null,schemas:i.schemas||null,tView:null},v=i.dependencies,w=i.features;return m.inputs=va(i.inputs,f),m.outputs=va(i.outputs),w&&w.forEach(D=>D(m)),m.directiveDefs=v?()=>("function"==typeof v?v():v).map(Uo).filter(Ql):null,m.pipeDefs=v?()=>("function"==typeof v?v():v).map(Je).filter(Ql):null,m})}function Uo(i){return ne(i)||Re(i)}function Ql(i){return null!==i}function Gs(i){return Cr(()=>({type:i.type,bootstrap:i.bootstrap||Sn,declarations:i.declarations||Sn,imports:i.imports||Sn,exports:i.exports||Sn,transitiveCompileScopes:null,schemas:i.schemas||null,id:i.id||null}))}function va(i,a){if(null==i)return Wt;const c={};for(const f in i)if(i.hasOwnProperty(f)){let m=i[f],v=m;Array.isArray(m)&&(v=m[1],m=m[0]),c[m]=f,a&&(a[m]=v)}return c}const Q=Jr;function ge(i){return{type:i.type,name:i.name,factory:null,pure:!1!==i.pure,standalone:!0===i.standalone,onDestroy:i.type.prototype.ngOnDestroy||null}}function ne(i){return i[Pr]||null}function Re(i){return i[ya]||null}function Je(i){return i[_o]||null}function Qt(i){const a=ne(i)||Re(i)||Je(i);return null!==a&&a.standalone}function nn(i,a){const c=i[er]||null;if(!c&&!0===a)throw new Error(`Type ${vt(i)} does not have '\u0275mod' property.`);return c}function jr(i){return Array.isArray(i)&&"object"==typeof i[1]}function es(i){return Array.isArray(i)&&!0===i[1]}function hi(i){return 0!=(8&i.flags)}function Gr(i){return 2==(2&i.flags)}function Io(i){return 1==(1&i.flags)}function ps(i){return null!==i.template}function il(i){return 0!=(256&i[2])}function Vr(i,a){return i.hasOwnProperty(ds)?i[ds]:null}class Do{constructor(a,c,f){this.previousValue=a,this.currentValue=c,this.firstChange=f}isFirstChange(){return this.firstChange}}function fi(){return Li}function Li(i){return i.type.prototype.ngOnChanges&&(i.setInput=To),ic}function ic(){const i=cl(this),a=null==i?void 0:i.current;if(a){const c=i.previous;if(c===Wt)i.previous=a;else for(let f in a)c[f]=a[f];i.current=null,this.ngOnChanges(a)}}function To(i,a,c,f){const m=cl(i)||function Bi(i,a){return i[ll]=a}(i,{previous:Wt,current:null}),v=m.current||(m.current={}),w=m.previous,D=this.declaredInputs[c],R=w[D];v[D]=new Do(R&&R.currentValue,a,w===Wt),i[f]=a}fi.ngInherit=!0;const ll="__ngSimpleChanges__";function cl(i){return i[ll]||null}function jn(i){for(;Array.isArray(i);)i=i[0];return i}function Ur(i,a){return jn(a[i.index])}function zi(i,a){return i.data[a]}function ns(i,a){const c=a[i];return jr(c)?c:c[0]}function Ea(i){return 64==(64&i[2])}function ko(i,a){return null==a?null:i[a]}function Ia(i){i[18]=0}function Da(i,a){i[5]+=a;let c=i,f=i[3];for(;null!==f&&(1===a&&1===c[5]||-1===a&&0===c[5]);)f[5]+=a,c=f,f=f[3]}const hn={lFrame:bl(null),bindingsEnabled:!0};function fl(){return hn.bindingsEnabled}function st(){return hn.lFrame.lView}function _n(){return hn.lFrame.tView}function ur(){let i=Wi();for(;null!==i&&64===i.type;)i=i.parent;return i}function Wi(){return hn.lFrame.currentTNode}function Xs(i,a){const c=hn.lFrame;c.currentTNode=i,c.isParent=a}function Ao(){return hn.lFrame.isParent}function so(){return hn.lFrame.bindingIndex++}function Ta(i,a){const c=hn.lFrame;c.bindingIndex=c.bindingRootIndex=i,gi(a)}function gi(i){hn.lFrame.currentDirectiveIndex=i}function lc(){return hn.lFrame.currentQueryIndex}function Gi(i){hn.lFrame.currentQueryIndex=i}function vd(i){const a=i[1];return 2===a.type?a.declTNode:1===a.type?i[6]:null}function gl(i,a,c){if(c&St.SkipSelf){let m=a,v=i;for(;!(m=m.parent,null!==m||c&St.Host||(m=vd(v),null===m||(v=v[15],10&m.type))););if(null===m)return!1;a=m,i=v}const f=hn.lFrame=vl();return f.currentTNode=a,f.lView=i,!0}function yl(i){const a=vl(),c=i[1];hn.lFrame=a,a.currentTNode=c.firstChild,a.lView=i,a.tView=c,a.contextLView=i,a.bindingIndex=c.bindingStartIndex,a.inI18n=!1}function vl(){const i=hn.lFrame,a=null===i?null:i.child;return null===a?bl(i):a}function bl(i){const a={currentTNode:null,isParent:!0,lView:null,tView:null,selectedIndex:-1,contextLView:null,elementDepthCount:0,currentNamespace:null,currentDirectiveIndex:-1,bindingRootIndex:-1,bindingIndex:-1,currentQueryIndex:0,parent:i,child:null,inI18n:!1};return null!==i&&(i.child=a),a}function cc(){const i=hn.lFrame;return hn.lFrame=i.parent,i.currentTNode=null,i.lView=null,i}const uc=cc;function Na(){const i=cc();i.isParent=!0,i.tView=null,i.selectedIndex=-1,i.contextLView=null,i.elementDepthCount=0,i.currentDirectiveIndex=-1,i.currentNamespace=null,i.bindingRootIndex=-1,i.bindingIndex=-1,i.currentQueryIndex=0}function kr(){return hn.lFrame.selectedIndex}function $s(i){hn.lFrame.selectedIndex=i}function Fn(){const i=hn.lFrame;return zi(i.tView,i.selectedIndex)}function Aa(){hn.lFrame.currentNamespace="svg"}function _l(){!function hc(){hn.lFrame.currentNamespace=null}()}function Ki(i,a){for(let c=a.directiveStart,f=a.directiveEnd;c<f;c++){const v=i.data[c].type.prototype,{ngAfterContentInit:w,ngAfterContentChecked:D,ngAfterViewInit:R,ngAfterViewChecked:L,ngOnDestroy:W}=v;w&&(i.contentHooks||(i.contentHooks=[])).push(-c,w),D&&((i.contentHooks||(i.contentHooks=[])).push(c,D),(i.contentCheckHooks||(i.contentCheckHooks=[])).push(c,D)),R&&(i.viewHooks||(i.viewHooks=[])).push(-c,R),L&&((i.viewHooks||(i.viewHooks=[])).push(c,L),(i.viewCheckHooks||(i.viewCheckHooks=[])).push(c,L)),null!=W&&(i.destroyHooks||(i.destroyHooks=[])).push(c,W)}}function qo(i,a,c){yi(i,a,3,c)}function Xo(i,a,c,f){(3&i[2])===c&&yi(i,a,c,f)}function Ma(i,a){let c=i[2];(3&c)===a&&(c&=2047,c+=1,i[2]=c)}function yi(i,a,c,f){const v=null!=f?f:-1,w=a.length-1;let D=0;for(let R=void 0!==f?65535&i[18]:0;R<w;R++)if("number"==typeof a[R+1]){if(D=a[R],null!=f&&D>=f)break}else a[R]<0&&(i[18]+=65536),(D<v||-1==v)&&(k(i,c,a,R),i[18]=(4294901760&i[18])+R+2),R++}function k(i,a,c,f){const m=c[f]<0,v=c[f+1],D=i[m?-c[f]:c[f]];if(m){if(i[2]>>11<i[18]>>16&&(3&i[2])===a){i[2]+=2048;try{v.call(D)}finally{}}}else try{v.call(D)}finally{}}const B=-1;class M{constructor(a,c,f){this.factory=a,this.resolving=!1,this.canSeeViewProviders=c,this.injectImpl=f}}function yn(i,a,c){let f=0;for(;f<c.length;){const m=c[f];if("number"==typeof m){if(0!==m)break;f++;const v=c[f++],w=c[f++],D=c[f++];i.setAttribute(a,w,D,v)}else{const v=m,w=c[++f];$n(v)?i.setProperty(a,v,w):i.setAttribute(a,v,w),f++}}return f}function sr(i){return 3===i||4===i||6===i}function $n(i){return 64===i.charCodeAt(0)}function or(i,a){if(null!==a&&0!==a.length)if(null===i||0===i.length)i=a.slice();else{let c=-1;for(let f=0;f<a.length;f++){const m=a[f];"number"==typeof m?c=m:0===c||Ps(i,c,m,null,-1===c||2===c?a[++f]:null)}}return i}function Ps(i,a,c,f,m){let v=0,w=i.length;if(-1===a)w=-1;else for(;v<i.length;){const D=i[v++];if("number"==typeof D){if(D===a){w=-1;break}if(D>a){w=v-1;break}}}for(;v<i.length;){const D=i[v];if("number"==typeof D)break;if(D===c){if(null===f)return void(null!==m&&(i[v+1]=m));if(f===i[v+1])return void(i[v+2]=m)}v++,null!==f&&v++,null!==m&&v++}-1!==w&&(i.splice(w,0,a),v=w+1),i.splice(v++,0,c),null!==f&&i.splice(v++,0,f),null!==m&&i.splice(v++,0,m)}function gs(i){return i!==B}function ss(i){return 32767&i}function Mo(i,a){let c=function Zs(i){return i>>16}(i),f=a;for(;c>0;)f=f[15],c--;return f}let Yo=!0;function Zo(i){const a=Yo;return Yo=i,a}let du=0;const Qs={};function Oa(i,a){const c=qi(i,a);if(-1!==c)return c;const f=a[1];f.firstCreatePass&&(i.injectorIndex=a.length,vi(f.data,i),vi(a,null),vi(f.blueprint,null));const m=xl(i,a),v=i.injectorIndex;if(gs(m)){const w=ss(m),D=Mo(m,a),R=D[1].data;for(let L=0;L<8;L++)a[v+L]=D[w+L]|R[w+L]}return a[v+8]=m,v}function vi(i,a){i.push(0,0,0,0,0,0,0,0,a)}function qi(i,a){return-1===i.injectorIndex||i.parent&&i.parent.injectorIndex===i.injectorIndex||null===a[i.injectorIndex+8]?-1:i.injectorIndex}function xl(i,a){if(i.parent&&-1!==i.parent.injectorIndex)return i.parent.injectorIndex;let c=0,f=null,m=a;for(;null!==m;){if(f=Ar(m),null===f)return B;if(c++,m=m[15],-1!==f.injectorIndex)return f.injectorIndex|c<<16}return B}function mc(i,a,c){!function Js(i,a,c){let f;"string"==typeof c?f=c.charCodeAt(0)||0:c.hasOwnProperty(Sr)&&(f=c[Sr]),null==f&&(f=c[Sr]=du++);const m=255&f;a.data[i+(m>>5)]|=1<<m}(i,a,c)}function hu(i,a,c){if(c&St.Optional||void 0!==i)return i;Ot()}function Pp(i,a,c,f){if(c&St.Optional&&void 0===f&&(f=null),0==(c&(St.Self|St.Host))){const m=i[9],v=Kn(void 0);try{return m?m.get(a,f,c&St.Optional):no(a,f,c&St.Optional)}finally{Kn(v)}}return hu(f,0,c)}function fu(i,a,c,f=St.Default,m){if(null!==i){if(1024&a[2]){const w=function pu(i,a,c,f,m){let v=i,w=a;for(;null!==v&&null!==w&&1024&w[2]&&!(256&w[2]);){const D=Ph(v,w,c,f|St.Self,Qs);if(D!==Qs)return D;let R=v.parent;if(!R){const L=w[21];if(L){const W=L.get(c,Qs,f);if(W!==Qs)return W}R=Ar(w),w=w[15]}v=R}return m}(i,a,c,f,Qs);if(w!==Qs)return w}const v=Ph(i,a,c,f,Qs);if(v!==Qs)return v}return Pp(a,c,f,m)}function Ph(i,a,c,f,m){const v=function Bh(i){if("string"==typeof i)return i.charCodeAt(0)||0;const a=i.hasOwnProperty(Sr)?i[Sr]:void 0;return"number"==typeof a?a>=0?255&a:Vh:a}(c);if("function"==typeof v){if(!gl(a,i,f))return f&St.Host?hu(m,0,f):Pp(a,c,f,m);try{const w=v(f);if(null!=w||f&St.Optional)return w;Ot()}finally{uc()}}else if("number"==typeof v){let w=null,D=qi(i,a),R=B,L=f&St.Host?a[16][6]:null;for((-1===D||f&St.SkipSelf)&&(R=-1===D?xl(i,a):a[D+8],R!==B&&Yi(f,!1)?(w=a[1],D=ss(R),a=Mo(R,a)):D=-1);-1!==D;){const W=a[1];if(gc(v,D,W.data)){const J=Lh(D,a,c,w,f,L);if(J!==Qs)return J}R=a[D+8],R!==B&&Yi(f,a[1].data[D+8]===L)&&gc(v,D,a)?(w=W,D=ss(R),a=Mo(R,a)):D=-1}}return m}function Lh(i,a,c,f,m,v){const w=a[1],D=w.data[i+8],W=Xi(D,w,c,null==f?Gr(D)&&Yo:f!=w&&0!=(3&D.type),m&St.Host&&v===D);return null!==W?wl(a,w,W,D):Qs}function Xi(i,a,c,f,m){const v=i.providerIndexes,w=a.data,D=1048575&v,R=i.directiveStart,W=v>>20,fe=m?D+W:i.directiveEnd;for(let Ne=f?D:D+W;Ne<fe;Ne++){const Qe=w[Ne];if(Ne<R&&c===Qe||Ne>=R&&Qe.type===c)return Ne}if(m){const Ne=w[R];if(Ne&&ps(Ne)&&Ne.type===c)return R}return null}function wl(i,a,c,f){let m=i[c];const v=a.data;if(function H(i){return i instanceof M}(m)){const w=m;w.resolving&&function ze(i,a){const c=a?`. Dependency path: ${a.join(" > ")} > ${i}`:"";throw new Xe(-200,`Circular dependency in DI detected for ${i}${c}`)}(function X(i){return"function"==typeof i?i.name||i.toString():"object"==typeof i&&null!=i&&"function"==typeof i.type?i.type.name||i.type.toString():ie(i)}(v[c]));const D=Zo(w.canSeeViewProviders);w.resolving=!0;const R=w.injectImpl?Kn(w.injectImpl):null;gl(i,f,St.Default);try{m=i[c]=w.factory(void 0,v,i,f),a.firstCreatePass&&c>=f.directiveStart&&function fc(i,a,c){const{ngOnChanges:f,ngOnInit:m,ngDoCheck:v}=a.type.prototype;if(f){const w=Li(a);(c.preOrderHooks||(c.preOrderHooks=[])).push(i,w),(c.preOrderCheckHooks||(c.preOrderCheckHooks=[])).push(i,w)}m&&(c.preOrderHooks||(c.preOrderHooks=[])).push(0-i,m),v&&((c.preOrderHooks||(c.preOrderHooks=[])).push(i,v),(c.preOrderCheckHooks||(c.preOrderCheckHooks=[])).push(i,v))}(c,v[c],a)}finally{null!==R&&Kn(R),Zo(D),w.resolving=!1,uc()}}return m}function gc(i,a,c){return!!(c[a+(i>>5)]&1<<i)}function Yi(i,a){return!(i&St.Self||i&St.Host&&a)}class bi{constructor(a,c){this._tNode=a,this._lView=c}get(a,c,f){return fu(this._tNode,this._lView,a,f,c)}}function Vh(){return new bi(ur(),st())}function Ar(i){const a=i[1],c=a.type;return 2===c?a.declTNode:1===c?i[6]:null}function Un(i){return function bd(i,a){if("class"===a)return i.classes;if("style"===a)return i.styles;const c=i.attrs;if(c){const f=c.length;let m=0;for(;m<f;){const v=c[m];if(sr(v))break;if(0===v)m+=2;else if("number"==typeof v)for(m++;m<f&&"string"==typeof c[m];)m++;else{if(v===a)return c[m+1];m+=2}}}return null}(ur(),i)}const Xn="__parameters__";function $a(i,a,c){return Cr(()=>{const f=function Cl(i){return function(...c){if(i){const f=i(...c);for(const m in f)this[m]=f[m]}}}(a);function m(...v){if(this instanceof m)return f.apply(this,v),this;const w=new m(...v);return D.annotation=w,D;function D(R,L,W){const J=R.hasOwnProperty(Xn)?R[Xn]:Object.defineProperty(R,Xn,{value:[]})[Xn];for(;J.length<=W;)J.push(null);return(J[W]=J[W]||[]).push(w),R}}return c&&(m.prototype=Object.create(c.prototype)),m.prototype.ngMetadataName=i,m.annotationCls=m,m})}class Gn{constructor(a,c){this._desc=a,this.ngMetadataName="InjectionToken",this.\u0275prov=void 0,"number"==typeof c?this.__NG_ELEMENT_ID__=c:void 0!==c&&(this.\u0275prov=Bt({token:this,providedIn:c.providedIn||"root",factory:c.factory}))}get multi(){return this}toString(){return`InjectionToken ${this._desc}`}}function os(i,a){void 0===a&&(a=i);for(let c=0;c<i.length;c++){let f=i[c];Array.isArray(f)?(a===i&&(a=i.slice(0,c)),os(f,a)):a!==i&&a.push(f)}return a}function Qo(i,a){i.forEach(c=>Array.isArray(c)?Qo(c,a):a(c))}function vc(i,a,c){a>=i.length?i.push(c):i.splice(a,0,c)}function wd(i,a){return a>=i.length-1?i.pop():i.splice(a,1)[0]}const lt={},$t="__NG_DI_FLAG__",Ct="ngTempTokenPath",Mn=/\n/gm,Bs="__source";let vs;function Vs(i){const a=vs;return vs=i,a}function Ci(i,a=St.Default){if(void 0===vs)throw new Xe(-203,!1);return null===vs?no(i,void 0,a):vs.get(i,a&St.Optional?null:void 0,a)}function br(i,a=St.Default){return(function Ft(){return Rt}()||Ci)(Dt(i),a)}function zh(i,a=St.Default){return"number"!=typeof a&&(a=0|(a.optional&&8)|(a.host&&1)|(a.self&&2)|(a.skipSelf&&4)),br(i,a)}function Hh(i){const a=[];for(let c=0;c<i.length;c++){const f=Dt(i[c]);if(Array.isArray(f)){if(0===f.length)throw new Xe(900,!1);let m,v=St.Default;for(let w=0;w<f.length;w++){const D=f[w],R=Px(D);"number"==typeof R?-1===R?m=D.token:v|=R:m=D}a.push(br(m,v))}else a.push(br(f))}return a}function pe(i,a){return i[$t]=a,i.prototype[$t]=a,i}function Px(i){return i[$t]}const gu=pe($a("Optional"),8),is=pe($a("SkipSelf"),4);var ni=(()=>((ni=ni||{})[ni.Important=1]="Important",ni[ni.DashCase=2]="DashCase",ni))();const Dd=new Map;let zx=0;const Td="__ngContext__";function bs(i,a){jr(a)?(i[Td]=a[20],function uv(i){Dd.set(i[20],i)}(a)):i[Td]=a}function Nd(i,a){return undefined(i,a)}function xc(i){const a=i[3];return es(a)?a[3]:a}function Tl(i){return pv(i[13])}function Kh(i){return pv(i[4])}function pv(i){for(;null!==i&&!es(i);)i=i[4];return i}function _u(i,a,c,f,m){if(null!=f){let v,w=!1;es(f)?v=f:jr(f)&&(w=!0,f=f[0]);const D=jn(f);0===i&&null!==c?null==m?em(a,c,D):ea(a,c,D,m||null,!0):1===i&&null!==c?ea(a,c,D,m||null,!0):2===i?function Cv(i,a,c){const f=Yh(i,a);f&&function nw(i,a,c,f){i.removeChild(a,c,f)}(i,f,a,c)}(a,D,w):3===i&&a.destroyNode(D),null!=v&&function ow(i,a,c,f,m){const v=c[7];v!==jn(c)&&_u(a,i,f,v,m);for(let D=10;D<c.length;D++){const R=c[D];gn(R[1],R,i,a,f,v)}}(a,i,v,c,m)}}function Zp(i,a,c){return i.createElement(a,c)}function Qp(i,a){const c=i[9],f=c.indexOf(a),m=a[3];512&a[2]&&(a[2]&=-513,Da(m,-1)),c.splice(f,1)}function Jp(i,a){if(i.length<=10)return;const c=10+a,f=i[c];if(f){const m=f[17];null!==m&&m!==i&&Qp(m,f),a>0&&(i[c-1][4]=f[4]);const v=wd(i,10+a);!function Zx(i,a){gn(i,a,a[11],2,null,null),a[0]=null,a[6]=null}(f[1],f);const w=v[19];null!==w&&w.detachView(v[1]),f[3]=null,f[4]=null,f[2]&=-65}return f}function wc(i,a){if(!(128&a[2])){const c=a[11];c.destroyNode&&gn(i,a,c,3,null,null),function UI(i){let a=i[13];if(!a)return qh(i[1],i);for(;a;){let c=null;if(jr(a))c=a[13];else{const f=a[10];f&&(c=f)}if(!c){for(;a&&!a[4]&&a!==i;)jr(a)&&qh(a[1],a),a=a[3];null===a&&(a=i),jr(a)&&qh(a[1],a),c=a&&a[4]}a=c}}(a)}}function qh(i,a){if(!(128&a[2])){a[2]&=-65,a[2]|=128,function tw(i,a){let c;if(null!=i&&null!=(c=i.destroyHooks))for(let f=0;f<c.length;f+=2){const m=a[c[f]];if(!(m instanceof M)){const v=c[f+1];if(Array.isArray(v))for(let w=0;w<v.length;w+=2){const D=m[v[w]],R=v[w+1];try{R.call(D)}finally{}}else try{v.call(m)}finally{}}}}(i,a),function ew(i,a){const c=i.cleanup,f=a[7];let m=-1;if(null!==c)for(let v=0;v<c.length-1;v+=2)if("string"==typeof c[v]){const w=c[v+1],D="function"==typeof w?w(a):jn(a[w]),R=f[m=c[v+2]],L=c[v+3];"boolean"==typeof L?D.removeEventListener(c[v],R,L):L>=0?f[m=L]():f[m=-L].unsubscribe(),v+=2}else{const w=f[m=c[v+1]];c[v].call(w)}if(null!==f){for(let v=m+1;v<f.length;v++)(0,f[v])();a[7]=null}}(i,a),1===a[1].type&&a[11].destroy();const c=a[17];if(null!==c&&es(a[3])){c!==a[3]&&Qp(c,a);const f=a[19];null!==f&&f.detachView(i)}!function Hx(i){Dd.delete(i[20])}(a)}}function Cc(i,a,c){return function Ts(i,a,c){let f=a;for(;null!==f&&40&f.type;)f=(a=f).parent;if(null===f)return c[0];if(2&f.flags){const m=i.data[f.directiveStart].encapsulation;if(m===zn.None||m===zn.Emulated)return null}return Ur(f,c)}(i,a.parent,c)}function ea(i,a,c,f,m){i.insertBefore(a,c,f,m)}function em(i,a,c){i.appendChild(a,c)}function Xh(i,a,c,f,m){null!==f?ea(i,a,c,f,m):em(i,a,c)}function Yh(i,a){return i.parentNode(a)}let Nt,_v=function Zh(i,a,c){return 40&i.type?Ur(i,c):null};function Qh(i,a,c,f){const m=Cc(i,f,a),v=a[11],D=function bv(i,a,c){return _v(i,a,c)}(f.parent||a[6],f,a);if(null!=m)if(Array.isArray(c))for(let R=0;R<c.length;R++)Xh(v,m,c[R],D,!1);else Xh(v,m,c,D,!1)}function Ha(i,a){if(null!==a){const c=a.type;if(3&c)return Ur(a,i);if(4&c)return wv(-1,i[a.index]);if(8&c){const f=a.child;if(null!==f)return Ha(i,f);{const m=i[a.index];return es(m)?wv(-1,m):jn(m)}}if(32&c)return Nd(a,i)()||jn(i[a.index]);{const f=rw(i,a);return null!==f?Array.isArray(f)?f[0]:Ha(xc(i[16]),f):Ha(i,a.next)}}return null}function rw(i,a){return null!==a?i[16][6].projection[a.projection]:null}function wv(i,a){const c=10+i+1;if(c<a.length){const f=a[c],m=f[1].firstChild;if(null!==m)return Ha(f,m)}return a[7]}function nm(i,a,c,f,m,v,w){for(;null!=c;){const D=f[c.index],R=c.type;if(w&&0===a&&(D&&bs(jn(D),f),c.flags|=4),64!=(64&c.flags))if(8&R)nm(i,a,c.child,f,m,v,!1),_u(a,i,m,D,v);else if(32&R){const L=Nd(c,f);let W;for(;W=L();)_u(a,i,m,W,v);_u(a,i,m,D,v)}else 16&R?fr(i,a,f,c,m,v):_u(a,i,m,D,v);c=w?c.projectionNext:c.next}}function gn(i,a,c,f,m,v){nm(c,f,i.firstChild,a,m,v,!1)}function fr(i,a,c,f,m,v){const w=c[16],R=w[6].projection[f.projection];if(Array.isArray(R))for(let L=0;L<R.length;L++)_u(a,i,m,R[L],v);else nm(i,a,R,w[3],m,v,!0)}function rm(i,a,c){i.setAttribute(a,"style",c)}function Sv(i,a,c){""===c?i.removeAttribute(a,"class"):i.setAttribute(a,"class",c)}function lw(i){Nt=i}class uw{constructor(a){this.changingThisBreaksApplicationSecurity=a}toString(){return`SafeValue must use [property]=binding: ${this.changingThisBreaksApplicationSecurity} (see https://g.co/ng/security#xss)`}}const Md=/^(?:(?:https?|mailto|data|ftp|tel|file|sms):|[^&:/?#]*(?:[/?#]|$))/gi;var qr=(()=>((qr=qr||{})[qr.NONE=0]="NONE",qr[qr.HTML=1]="HTML",qr[qr.STYLE=2]="STYLE",qr[qr.SCRIPT=3]="SCRIPT",qr[qr.URL=4]="URL",qr[qr.RESOURCE_URL=5]="RESOURCE_URL",qr))();function rf(i){const a=function $d(){const i=st();return i&&i[12]}();return a?a.sanitize(qr.URL,i)||"":function Ad(i,a){const c=function sm(i){return i instanceof uw&&i.getTypeName()||null}(i);if(null!=c&&c!==a){if("ResourceURL"===c&&"URL"===a)return!0;throw new Error(`Required a safe ${a}, got a ${c} (see https://g.co/ng/security#xss)`)}return c===a}(i,"URL")?function xn(i){return i instanceof uw?i.changingThisBreaksApplicationSecurity:i}(i):function om(i){return(i=String(i)).match(Md)?i:"unsafe:"+i}(ie(i))}const Pd=new Gn("ENVIRONMENT_INITIALIZER"),um=new Gn("INJECTOR",-1),af=new Gn("INJECTOR_DEF_TYPES");class Mv{get(a,c=lt){if(c===lt){const f=new Error(`NullInjectorError: No provider for ${vt(a)}!`);throw f.name="NullInjectorError",f}return c}}function dm(...i){return{\u0275providers:hm(0,i)}}function hm(i,...a){const c=[],f=new Set;let m;return Qo(a,v=>{const w=v;fm(w,c,[],f)&&(m||(m=[]),m.push(w))}),void 0!==m&&Ov(m,c),c}function Ov(i,a){for(let c=0;c<i.length;c++){const{providers:m}=i[c];Qo(m,v=>{a.push(v)})}}function fm(i,a,c,f){if(!(i=Dt(i)))return!1;let m=null,v=us(i);const w=!v&&ne(i);if(v||w){if(w&&!w.standalone)return!1;m=i}else{const R=i.ngModule;if(v=us(R),!v)return!1;m=R}const D=f.has(m);if(w){if(D)return!1;if(f.add(m),w.dependencies){const R="function"==typeof w.dependencies?w.dependencies():w.dependencies;for(const L of R)fm(L,a,c,f)}}else{if(!v)return!1;{if(null!=v.imports&&!D){let L;f.add(m);try{Qo(v.imports,W=>{fm(W,a,c,f)&&(L||(L=[]),L.push(W))})}finally{}void 0!==L&&Ov(L,a)}if(!D){const L=Vr(m)||(()=>new m);a.push({provide:m,useFactory:L,deps:Sn},{provide:af,useValue:m,multi:!0},{provide:Pd,useValue:()=>br(m),multi:!0})}const R=v.providers;null==R||D||Qo(R,W=>{a.push(W)})}}return m!==i&&void 0!==i.providers}const Dw=$e({provide:String,useValue:$e});function pm(i){return null!==i&&"object"==typeof i&&Dw in i}function Rl(i){return"function"==typeof i}const gm=new Gn("Set Injector scope."),lf={},Tw={};let ym;function vm(){return void 0===ym&&(ym=new Mv),ym}class ja{}class bm extends ja{constructor(a,c,f,m){super(),this.parent=c,this.source=f,this.scopes=m,this.records=new Map,this._ngOnDestroyHooks=new Set,this._onDestroyHooks=[],this._destroyed=!1,Ld(a,w=>this.processProvider(w)),this.records.set(um,Cu(void 0,this)),m.has("environment")&&this.records.set(ja,Cu(void 0,this));const v=this.records.get(gm);null!=v&&"string"==typeof v.value&&this.scopes.add(v.value),this.injectorDefTypes=new Set(this.get(af.multi,Sn,St.Self))}get destroyed(){return this._destroyed}destroy(){this.assertNotDestroyed(),this._destroyed=!0;try{for(const a of this._ngOnDestroyHooks)a.ngOnDestroy();for(const a of this._onDestroyHooks)a()}finally{this.records.clear(),this._ngOnDestroyHooks.clear(),this.injectorDefTypes.clear(),this._onDestroyHooks.length=0}}onDestroy(a){this._onDestroyHooks.push(a)}runInContext(a){this.assertNotDestroyed();const c=Vs(this),f=Kn(void 0);try{return a()}finally{Vs(c),Kn(f)}}get(a,c=lt,f=St.Default){this.assertNotDestroyed();const m=Vs(this),v=Kn(void 0);try{if(!(f&St.SkipSelf)){let D=this.records.get(a);if(void 0===D){const R=function Cm(i){return"function"==typeof i||"object"==typeof i&&i instanceof Gn}(a)&&In(a);D=R&&this.injectableDefInScope(R)?Cu(_m(a),lf):null,this.records.set(a,D)}if(null!=D)return this.hydrate(a,D)}return(f&St.Self?vm():this.parent).get(a,c=f&St.Optional&&c===lt?null:c)}catch(w){if("NullInjectorError"===w.name){if((w[Ct]=w[Ct]||[]).unshift(vt(a)),m)throw w;return function Lx(i,a,c,f){const m=i[Ct];throw a[Bs]&&m.unshift(a[Bs]),i.message=function Up(i,a,c,f=null){i=i&&"\n"===i.charAt(0)&&"\u0275"==i.charAt(1)?i.slice(2):i;let m=vt(a);if(Array.isArray(a))m=a.map(vt).join(" -> ");else if("object"==typeof a){let v=[];for(let w in a)if(a.hasOwnProperty(w)){let D=a[w];v.push(w+":"+("string"==typeof D?JSON.stringify(D):vt(D)))}m=`{${v.join(", ")}}`}return`${c}${f?"("+f+")":""}[${m}]: ${i.replace(Mn,"\n  ")}`}("\n"+i.message,m,c,f),i.ngTokenPath=m,i[Ct]=null,i}(w,a,"R3InjectorError",this.source)}throw w}finally{Kn(v),Vs(m)}}resolveInjectorInitializers(){const a=Vs(this),c=Kn(void 0);try{const f=this.get(Pd.multi,Sn,St.Self);for(const m of f)m()}finally{Vs(a),Kn(c)}}toString(){const a=[],c=this.records;for(const f of c.keys())a.push(vt(f));return`R3Injector[${a.join(", ")}]`}assertNotDestroyed(){if(this._destroyed)throw new Xe(205,!1)}processProvider(a){let c=Rl(a=Dt(a))?a:Dt(a&&a.provide);const f=function xm(i){return pm(i)?Cu(void 0,i.useValue):Cu(Nw(i),lf)}(a);if(Rl(a)||!0!==a.multi)this.records.get(c);else{let m=this.records.get(c);m||(m=Cu(void 0,lf,!0),m.factory=()=>Hh(m.multi),this.records.set(c,m)),c=a,m.multi.push(a)}this.records.set(c,f)}hydrate(a,c){return c.value===lf&&(c.value=Tw,c.value=c.factory()),"object"==typeof c.value&&c.value&&function kw(i){return null!==i&&"object"==typeof i&&"function"==typeof i.ngOnDestroy}(c.value)&&this._ngOnDestroyHooks.add(c.value),c.value}injectableDefInScope(a){if(!a.providedIn)return!1;const c=Dt(a.providedIn);return"string"==typeof c?"any"===c||this.scopes.has(c):this.injectorDefTypes.has(c)}}function _m(i){const a=In(i),c=null!==a?a.factory:Vr(i);if(null!==c)return c;if(i instanceof Gn)throw new Xe(204,!1);if(i instanceof Function)return function XI(i){const a=i.length;if(a>0)throw function Jo(i,a){const c=[];for(let f=0;f<i;f++)c.push(a);return c}(a,"?"),new Xe(204,!1);const c=function Fr(i){const a=i&&(i[vr]||i[Dr]);if(a){const c=function wr(i){if(i.hasOwnProperty("name"))return i.name;const a=(""+i).match(/^function\s*([^\s(]+)/);return null===a?"":a[1]}(i);return console.warn(`DEPRECATED: DI is instantiating a token "${c}" that inherits its @Injectable decorator but does not provide one itself.\nThis will become an error in a future version of Angular. Please add @Injectable() to the "${c}" class.`),a}return null}(i);return null!==c?()=>c.factory(i):()=>new i}(i);throw new Xe(204,!1)}function Nw(i,a,c){let f;if(Rl(i)){const m=Dt(i);return Vr(m)||_m(m)}if(pm(i))f=()=>Dt(i.useValue);else if(function Al(i){return!(!i||!i.useFactory)}(i))f=()=>i.useFactory(...Hh(i.deps||[]));else if(function mm(i){return!(!i||!i.useExisting)}(i))f=()=>br(Dt(i.useExisting));else{const m=Dt(i&&(i.useClass||i.provide));if(!function wm(i){return!!i.deps}(i))return Vr(m)||_m(m);f=()=>new m(...Hh(i.deps))}return f}function Cu(i,a,c=!1){return{factory:i,value:a,multi:c?[]:void 0}}function Aw(i){return!!i.\u0275providers}function Ld(i,a){for(const c of i)Array.isArray(c)?Ld(c,a):Aw(c)?Ld(c.\u0275providers,a):a(c)}class Sm{}class Bv{resolveComponentFactory(a){throw function Pv(i){const a=Error(`No component factory found for ${vt(i)}. Did you add it to @NgModule.entryComponents?`);return a.ngComponent=i,a}(a)}}let Su=(()=>{class i{}return i.NULL=new Bv,i})();function Vv(){return Ic(ur(),st())}function Ic(i,a){return new Dc(Ur(i,a))}let Dc=(()=>{class i{constructor(c){this.nativeElement=c}}return i.__NG_ELEMENT_ID__=Vv,i})();function Em(i){return i instanceof Dc?i.nativeElement:i}class cf{}let Mw=(()=>{class i{}return i.__NG_ELEMENT_ID__=()=>function zv(){const i=st(),c=ns(ur().index,i);return(jr(c)?c:i)[11]}(),i})(),Ow=(()=>{class i{}return i.\u0275prov=Bt({token:i,providedIn:"root",factory:()=>null}),i})();class Hv{constructor(a){this.full=a,this.major=a.split(".")[0],this.minor=a.split(".")[1],this.patch=a.split(".").slice(2).join(".")}}const Fw=new Hv("14.3.0"),Im={};function Tm(i){return i.ngOriginalError}class Bd{constructor(){this._console=console}handleError(a){const c=this._findOriginalError(a);this._console.error("ERROR",a),c&&this._console.error("ORIGINAL ERROR",c)}_findOriginalError(a){let c=a&&Tm(a);for(;c&&Tm(c);)c=Tm(c);return c||null}}function Ga(i){return i instanceof Function?i():i}function jv(i,a,c){let f=i.length;for(;;){const m=i.indexOf(a,c);if(-1===m)return m;if(0===m||i.charCodeAt(m-1)<=32){const v=a.length;if(m+v===f||i.charCodeAt(m+v)<=32)return m}c=m+1}}const $o="ng-template";function Ka(i,a,c){let f=0;for(;f<i.length;){let m=i[f++];if(c&&"class"===m){if(m=i[f],-1!==jv(m.toLowerCase(),a,0))return!0}else if(1===m){for(;f<i.length&&"string"==typeof(m=i[f++]);)if(m.toLowerCase()===a)return!0;return!1}}return!1}function Xr(i){return 4===i.type&&i.value!==$o}function Ml(i,a,c){return a===(4!==i.type||c?i.value:$o)}function Gw(i,a,c){let f=4;const m=i.attrs||[],v=function Du(i){for(let a=0;a<i.length;a++)if(sr(i[a]))return a;return i.length}(m);let w=!1;for(let D=0;D<a.length;D++){const R=a[D];if("number"!=typeof R){if(!w)if(4&f){if(f=2|1&f,""!==R&&!Ml(i,R,c)||""===R&&1===a.length){if(Ei(f))return!1;w=!0}}else{const L=8&f?R:a[++D];if(8&f&&null!==i.attrs){if(!Ka(i.attrs,L,c)){if(Ei(f))return!1;w=!0}continue}const J=Nm(8&f?"class":R,m,Xr(i),c);if(-1===J){if(Ei(f))return!1;w=!0;continue}if(""!==L){let fe;fe=J>v?"":m[J+1].toLowerCase();const Ne=8&f?fe:null;if(Ne&&-1!==jv(Ne,L,0)||2&f&&L!==fe){if(Ei(f))return!1;w=!0}}}}else{if(!w&&!Ei(f)&&!Ei(R))return!1;if(w&&Ei(R))continue;w=!1,f=R|1&f}}return Ei(f)||w}function Ei(i){return 0==(1&i)}function Nm(i,a,c,f){if(null===a)return-1;let m=0;if(f||!c){let v=!1;for(;m<a.length;){const w=a[m];if(w===i)return m;if(3===w||6===w)v=!0;else{if(1===w||2===w){let D=a[++m];for(;"string"==typeof D;)D=a[++m];continue}if(4===w)break;if(0===w){m+=4;continue}}m+=v?1:2}return-1}return function Kw(i,a){let c=i.indexOf(4);if(c>-1)for(c++;c<i.length;){const f=i[c];if("number"==typeof f)return-1;if(f===a)return c;c++}return-1}(a,i)}function Iu(i,a,c=!1){for(let f=0;f<a.length;f++)if(Gw(i,a[f],c))return!0;return!1}function Tu(i,a){return i?":not("+a.trim()+")":a}function Vd(i){let a=i[0],c=1,f=2,m="",v=!1;for(;c<i.length;){let w=i[c];if("string"==typeof w)if(2&f){const D=i[++c];m+="["+w+(D.length>0?'="'+D+'"':"")+"]"}else 8&f?m+="."+w:4&f&&(m+=" "+w);else""!==m&&!Ei(w)&&(a+=Tu(v,m),m=""),f=w,v=v||!Ei(f);c++}return""!==m&&(a+=Tu(v,m)),a}const sn={};function Po(i){Gv(_n(),st(),kr()+i,!1)}function Gv(i,a,c,f){if(!f)if(3==(3&a[2])){const v=i.preOrderCheckHooks;null!==v&&qo(a,v,c)}else{const v=i.preOrderHooks;null!==v&&Xo(a,v,0,c)}$s(c)}function Yv(i,a=null,c=null,f){const m=Ol(i,a,c,f);return m.resolveInjectorInitializers(),m}function Ol(i,a=null,c=null,f,m=new Set){const v=[c||Sn,dm(i)];return f=f||("object"==typeof i?void 0:vt(i)),new bm(v,a||vm(),f||null,m)}let Nc=(()=>{class i{static create(c,f){var m;if(Array.isArray(c))return Yv({name:""},f,c,"");{const v=null!==(m=c.name)&&void 0!==m?m:"";return Yv({name:v},c.parent,c.providers,v)}}}return i.THROW_IF_NOT_FOUND=lt,i.NULL=new Mv,i.\u0275prov=Bt({token:i,providedIn:"any",factory:()=>br(um)}),i.__NG_ELEMENT_ID__=-1,i})();function kc(i,a=St.Default){const c=st();return null===c?br(i,a):fu(ur(),c,Dt(i),a)}function s0(){throw new Error("invalid")}function as(i,a){const c=i.contentQueries;if(null!==c)for(let f=0;f<c.length;f+=2){const m=c[f],v=c[f+1];if(-1!==v){const w=i.data[v];Gi(m),w.contentQueries(2,a[v],v)}}}function pr(i,a,c,f,m,v,w,D,R,L,W){const J=a.blueprint.slice();return J[0]=m,J[2]=76|f,(null!==W||i&&1024&i[2])&&(J[2]|=1024),Ia(J),J[3]=J[15]=i,J[8]=c,J[10]=w||i&&i[10],J[11]=D||i&&i[11],J[12]=R||i&&i[12]||null,J[9]=L||i&&i[9]||null,J[6]=v,J[20]=function Kp(){return zx++}(),J[21]=W,J[16]=2==a.type?i[16]:J,J}function na(i,a,c,f,m){let v=i.data[a];if(null===v)v=function _r(i,a,c,f,m){const v=Wi(),w=Ao(),R=i.data[a]=function _C(i,a,c,f,m,v){return{type:c,index:f,insertBeforeIndex:null,injectorIndex:a?a.injectorIndex:-1,directiveStart:-1,directiveEnd:-1,directiveStylingLast:-1,propertyBindings:null,flags:0,providerIndexes:0,value:m,attrs:v,mergedAttrs:null,localNames:null,initialInputs:void 0,inputs:null,outputs:null,tViews:null,next:null,projectionNext:null,child:null,parent:a,projection:null,styles:null,stylesWithoutHost:null,residualStyles:void 0,classes:null,classesWithoutHost:null,residualClasses:void 0,classBindings:0,styleBindings:0}}(0,w?v:v&&v.parent,c,a,f,m);return null===i.firstChild&&(i.firstChild=R),null!==v&&(w?null==v.child&&null!==R.parent&&(v.child=R):null===v.next&&(v.next=R)),R}(i,a,c,f,m),function au(){return hn.lFrame.inI18n}()&&(v.flags|=64);else if(64&v.type){v.type=c,v.value=f,v.attrs=m;const w=function ji(){const i=hn.lFrame,a=i.currentTNode;return i.isParent?a:a.parent}();v.injectorIndex=null===w?-1:w.injectorIndex}return Xs(v,!0),v}function ku(i,a,c,f){if(0===c)return-1;const m=a.length;for(let v=0;v<c;v++)a.push(f),i.blueprint.push(f),i.data.push(null);return m}function Pl(i,a,c){yl(a);try{const f=i.viewQuery;null!==f&&si(1,f,c);const m=i.template;null!==m&&yf(i,a,m,1,c),i.firstCreatePass&&(i.firstCreatePass=!1),i.staticContentQueries&&as(i,a),i.staticViewQueries&&si(2,i.viewQuery,c);const v=i.components;null!==v&&function _s(i,a){for(let c=0;c<a.length;c++)AC(i,a[c])}(a,v)}catch(f){throw i.firstCreatePass&&(i.incompleteFirstPass=!0,i.firstCreatePass=!1),f}finally{a[2]&=-5,Na()}}function gf(i,a,c,f){const m=a[2];if(128!=(128&m)){yl(a);try{Ia(a),function ml(i){return hn.lFrame.bindingIndex=i}(i.bindingStartIndex),null!==c&&yf(i,a,c,2,f);const w=3==(3&m);if(w){const L=i.preOrderCheckHooks;null!==L&&qo(a,L,null)}else{const L=i.preOrderHooks;null!==L&&Xo(a,L,0,null),Ma(a,0)}if(function Ym(i){for(let a=Tl(i);null!==a;a=Kh(a)){if(!a[2])continue;const c=a[9];for(let f=0;f<c.length;f++){const m=c[f],v=m[3];0==(512&m[2])&&Da(v,1),m[2]|=512}}}(a),function NC(i){for(let a=Tl(i);null!==a;a=Kh(a))for(let c=10;c<a.length;c++){const f=a[c],m=f[1];Ea(f)&&gf(m,f,m.template,f[8])}}(a),null!==i.contentQueries&&as(i,a),w){const L=i.contentCheckHooks;null!==L&&qo(a,L)}else{const L=i.contentHooks;null!==L&&Xo(a,L,1),Ma(a,1)}!function f0(i,a){const c=i.hostBindingOpCodes;if(null!==c)try{for(let f=0;f<c.length;f++){const m=c[f];if(m<0)$s(~m);else{const v=m,w=c[++f],D=c[++f];Ta(w,v),D(2,a[v])}}}finally{$s(-1)}}(i,a);const D=i.components;null!==D&&function Yr(i,a){for(let c=0;c<a.length;c++)kC(i,a[c])}(a,D);const R=i.viewQuery;if(null!==R&&si(2,R,f),w){const L=i.viewCheckHooks;null!==L&&qo(a,L)}else{const L=i.viewHooks;null!==L&&Xo(a,L,2),Ma(a,2)}!0===i.firstUpdatePass&&(i.firstUpdatePass=!1),a[2]&=-41,512&a[2]&&(a[2]&=-513,Da(a[3],-1))}finally{Na()}}}function yf(i,a,c,f,m){const v=kr(),w=2&f;try{$s(-1),w&&a.length>22&&Gv(i,a,22,!1),c(f,m)}finally{$s(v)}}function qm(i){const a=i.tView;return null===a||a.incompleteFirstPass?i.tView=Au(1,null,i.template,i.decls,i.vars,i.directiveDefs,i.pipeDefs,i.viewQuery,i.schemas,i.consts):a}function Au(i,a,c,f,m,v,w,D,R,L){const W=22+f,J=W+m,fe=function vC(i,a){const c=[];for(let f=0;f<a;f++)c.push(f<i?null:sn);return c}(W,J),Ne="function"==typeof L?L():L;return fe[1]={type:i,blueprint:fe,template:c,queries:null,viewQuery:D,declTNode:a,data:fe.slice().fill(null,W),bindingStartIndex:W,expandoStartIndex:J,hostBindingOpCodes:null,firstCreatePass:!0,firstUpdatePass:!0,staticViewQueries:!1,staticContentQueries:!1,preOrderHooks:null,preOrderCheckHooks:null,contentHooks:null,contentCheckHooks:null,viewHooks:null,viewCheckHooks:null,destroyHooks:null,cleanup:null,contentQueries:null,components:null,directiveRegistry:"function"==typeof v?v():v,pipeRegistry:"function"==typeof w?w():w,firstChild:null,schemas:R,consts:Ne,incompleteFirstPass:!1}}function Ll(i,a,c,f){const m=Jm(a);null===c?m.push(f):(m.push(c),i.firstCreatePass&&S0(i).push(f,m.length-1))}function ra(i,a,c){for(let f in i)if(i.hasOwnProperty(f)){const m=i[f];(c=null===c?{}:c).hasOwnProperty(f)?c[f].push(a,m):c[f]=[a,m]}return c}function m0(i,a){const f=a.directiveEnd,m=i.data,v=a.attrs,w=[];let D=null,R=null;for(let L=a.directiveStart;L<f;L++){const W=m[L],J=W.inputs,fe=null===v||Xr(a)?null:C0(J,v);w.push(fe),D=ra(J,L,D),R=ra(W.outputs,L,R)}null!==D&&(D.hasOwnProperty("class")&&(a.flags|=16),D.hasOwnProperty("style")&&(a.flags|=32)),a.initialInputs=w,a.inputs=D,a.outputs=R}function Ru(i,a){const c=ns(a,i);16&c[2]||(c[2]|=32)}function g0(i,a,c,f,m,v){const w=v.hostBindings;if(w){let D=i.hostBindingOpCodes;null===D&&(D=i.hostBindingOpCodes=[]);const R=~a.index;(function y0(i){let a=i.length;for(;a>0;){const c=i[--a];if("number"==typeof c&&c<0)return c}return 0})(D)!=R&&D.push(R),D.push(f,m,w)}}function v0(i,a){null!==i.hostBindings&&i.hostBindings(1,a)}function _0(i,a){a.flags|=2,(i.components||(i.components=[])).push(a.index)}function IC(i,a,c){if(c){if(a.exportAs)for(let f=0;f<a.exportAs.length;f++)c[a.exportAs[f]]=i;ps(a)&&(c[""]=i)}}function x0(i,a,c){i.flags|=1,i.directiveStart=a,i.directiveEnd=a+c,i.providerIndexes=a}function w0(i,a,c,f,m){i.data[f]=m;const v=m.factory||(m.factory=Vr(m.type)),w=new M(v,ps(m),kc);i.blueprint[f]=w,c[f]=w,g0(i,a,0,f,ku(i,c,m.hostVars,sn),m)}function DC(i,a,c){const f=Ur(a,i),m=qm(c),v=i[10],w=Bl(i,pr(i,m,null,c.onPush?32:16,f,a,v,v.createRenderer(f,c),null,null,null));i[a.index]=w}function sa(i,a,c,f,m,v){const w=Ur(i,a);!function Xm(i,a,c,f,m,v,w){if(null==v)i.removeAttribute(a,m,c);else{const D=null==w?ie(v):w(v,f||"",m);i.setAttribute(a,m,D,c)}}(a[11],w,v,i.value,c,f,m)}function TC(i,a,c,f,m,v){const w=v[a];if(null!==w){const D=f.setInput;for(let R=0;R<w.length;){const L=w[R++],W=w[R++],J=w[R++];null!==D?f.setInput(c,J,L,W):c[W]=J}}}function C0(i,a){let c=null,f=0;for(;f<a.length;){const m=a[f];if(0!==m)if(5!==m){if("number"==typeof m)break;i.hasOwnProperty(m)&&(null===c&&(c=[]),c.push(m,i[m],a[f+1])),f+=2}else f+=2;else f+=4}return c}function kC(i,a){const c=ns(a,i);if(Ea(c)){const f=c[1];48&c[2]?gf(f,c,f.template,c[8]):c[5]>0&&Zm(c)}}function Zm(i){for(let f=Tl(i);null!==f;f=Kh(f))for(let m=10;m<f.length;m++){const v=f[m];if(Ea(v))if(512&v[2]){const w=v[1];gf(w,v,w.template,v[8])}else v[5]>0&&Zm(v)}const c=i[1].components;if(null!==c)for(let f=0;f<c.length;f++){const m=ns(c[f],i);Ea(m)&&m[5]>0&&Zm(m)}}function AC(i,a){const c=ns(a,i),f=c[1];(function RC(i,a){for(let c=a.length;c<i.blueprint.length;c++)a.push(i.blueprint[c])})(f,c),Pl(f,c,c[8])}function Bl(i,a){return i[13]?i[14][4]=a:i[13]=a,i[14]=a,a}function Qm(i){for(;i;){i[2]|=32;const a=xc(i);if(il(i)&&!a)return i;i=a}return null}function Wd(i,a,c,f=!0){const m=a[10];m.begin&&m.begin();try{gf(i,a,i.template,c)}catch(w){throw f&&I0(a,w),w}finally{m.end&&m.end()}}function si(i,a,c){Gi(0),a(i,c)}function Jm(i){return i[7]||(i[7]=[])}function S0(i){return i.cleanup||(i.cleanup=[])}function I0(i,a){const c=i[9],f=c?c.get(Bd,null):null;f&&f.handleError(a)}function eg(i,a,c,f,m){for(let v=0;v<c.length;){const w=c[v++],D=c[v++],R=a[w],L=i.data[w];null!==L.setInput?L.setInput(R,m,f,D):R[D]=m}}function Xa(i,a,c){const f=function Wo(i,a){return jn(a[i])}(a,i);!function Nl(i,a,c){i.setValue(a,c)}(i[11],f,c)}function jd(i,a,c){let f=c?i.styles:null,m=c?i.classes:null,v=0;if(null!==a)for(let w=0;w<a.length;w++){const D=a[w];"number"==typeof D?v=D:1==v?m=bt(m,D):2==v&&(f=bt(f,D+": "+a[++w]+";"))}c?i.styles=f:i.stylesWithoutHost=f,c?i.classes=m:i.classesWithoutHost=m}function wf(i,a,c,f,m=!1){for(;null!==c;){const v=a[c.index];if(null!==v&&f.push(jn(v)),es(v))for(let D=10;D<v.length;D++){const R=v[D],L=R[1].firstChild;null!==L&&wf(R[1],R,L,f)}const w=c.type;if(8&w)wf(i,a,c.child,f);else if(32&w){const D=Nd(c,a);let R;for(;R=D();)f.push(R)}else if(16&w){const D=rw(a,c);if(Array.isArray(D))f.push(...D);else{const R=xc(a[16]);wf(R[1],R,D,f,!0)}}c=m?c.projectionNext:c.next}return f}class Vl{constructor(a,c){this._lView=a,this._cdRefInjectingView=c,this._appRef=null,this._attachedToViewContainer=!1}get rootNodes(){const a=this._lView,c=a[1];return wf(c,a,c.firstChild,[])}get context(){return this._lView[8]}set context(a){this._lView[8]=a}get destroyed(){return 128==(128&this._lView[2])}destroy(){if(this._appRef)this._appRef.detachView(this);else if(this._attachedToViewContainer){const a=this._lView[3];if(es(a)){const c=a[8],f=c?c.indexOf(this):-1;f>-1&&(Jp(a,f),wd(c,f))}this._attachedToViewContainer=!1}wc(this._lView[1],this._lView)}onDestroy(a){Ll(this._lView[1],this._lView,null,a)}markForCheck(){Qm(this._cdRefInjectingView||this._lView)}detach(){this._lView[2]&=-65}reattach(){this._lView[2]|=64}detectChanges(){Wd(this._lView[1],this._lView,this.context)}checkNoChanges(){}attachToViewContainerRef(){if(this._appRef)throw new Xe(902,!1);this._attachedToViewContainer=!0}detachFromAppRef(){this._appRef=null,function Jx(i,a){gn(i,a,a[11],2,null,null)}(this._lView[1],this._lView)}attachToAppRef(a){if(this._attachedToViewContainer)throw new Xe(902,!1);this._appRef=a}}class MC extends Vl{constructor(a){super(a),this._view=a}detectChanges(){const a=this._view;Wd(a[1],a,a[8],!1)}checkNoChanges(){}get context(){return null}}class Cf extends Su{constructor(a){super(),this.ngModule=a}resolveComponentFactory(a){const c=ne(a);return new Gd(c,this.ngModule)}}function D0(i){const a=[];for(let c in i)i.hasOwnProperty(c)&&a.push({propName:i[c],templateName:c});return a}class OC{constructor(a,c){this.injector=a,this.parentInjector=c}get(a,c,f){const m=this.injector.get(a,Im,f);return m!==Im||c===Im?m:this.parentInjector.get(a,c,f)}}class Gd extends Sm{constructor(a,c){super(),this.componentDef=a,this.ngModule=c,this.componentType=a.type,this.selector=function Ns(i){return i.map(Vd).join(",")}(a.selectors),this.ngContentSelectors=a.ngContentSelectors?a.ngContentSelectors:[],this.isBoundToModule=!!c}get inputs(){return D0(this.componentDef.inputs)}get outputs(){return D0(this.componentDef.outputs)}create(a,c,f,m){let v=(m=m||this.ngModule)instanceof ja?m:null==m?void 0:m.injector;v&&null!==this.componentDef.getStandaloneInjector&&(v=this.componentDef.getStandaloneInjector(v)||v);const w=v?new OC(a,v):a,D=w.get(cf,null);if(null===D)throw new Xe(407,!1);const R=w.get(Ow,null),L=D.createRenderer(null,this.componentDef),W=this.componentDef.selectors[0][0]||"div",J=f?function bC(i,a,c){return i.selectRootElement(a,c===zn.ShadowDom)}(L,f,this.componentDef.encapsulation):Zp(L,W,function T0(i){const a=i.toLowerCase();return"svg"===a?"svg":"math"===a?"math":null}(W)),fe=this.componentDef.onPush?288:272,Ne=Au(0,null,null,1,0,null,null,null,null,null),Qe=pr(null,Ne,null,fe,null,null,D,L,R,w,null);let mt,Et;yl(Qe);try{const Ut=function FC(i,a,c,f,m,v){const w=c[1];c[22]=i;const R=na(w,22,2,"#host",null),L=R.mergedAttrs=a.hostAttrs;null!==L&&(jd(R,L,!0),null!==i&&(yn(m,i,L),null!==R.classes&&Sv(m,i,R.classes),null!==R.styles&&rm(m,i,R.styles)));const W=f.createRenderer(i,a),J=pr(c,qm(a),null,a.onPush?32:16,c[22],R,f,W,v||null,null,null);return w.firstCreatePass&&(mc(Oa(R,c),w,a.type),_0(w,R),x0(R,c.length,1)),Bl(c,J),c[22]=J}(J,this.componentDef,Qe,D,L);if(J)if(f)yn(L,J,["ng-version",Fw.full]);else{const{attrs:en,classes:ft}=function Tc(i){const a=[],c=[];let f=1,m=2;for(;f<i.length;){let v=i[f];if("string"==typeof v)2===m?""!==v&&a.push(v,i[++f]):8===m&&c.push(v);else{if(!Ei(m))break;m=v}f++}return{attrs:a,classes:c}}(this.componentDef.selectors[0]);en&&yn(L,J,en),ft&&ft.length>0&&Sv(L,J,ft.join(" "))}if(Et=zi(Ne,22),void 0!==c){const en=Et.projection=[];for(let ft=0;ft<this.ngContentSelectors.length;ft++){const pn=c[ft];en.push(null!=pn?Array.from(pn):null)}}mt=function N0(i,a,c,f){const m=c[1],v=function SC(i,a,c){const f=ur();i.firstCreatePass&&(c.providersResolver&&c.providersResolver(c),w0(i,f,a,ku(i,a,1,null),c),m0(i,f));const m=wl(a,i,f.directiveStart,f);bs(m,a);const v=Ur(f,a);return v&&bs(v,a),m}(m,c,a);if(i[8]=c[8]=v,null!==f)for(const D of f)D(v,a);if(a.contentQueries){const D=ur();a.contentQueries(1,v,D.directiveStart)}const w=ur();return!m.firstCreatePass||null===a.hostBindings&&null===a.hostAttrs||($s(w.index),g0(c[1],w,0,w.directiveStart,w.directiveEnd,a),v0(a,v)),v}(Ut,this.componentDef,Qe,[$C]),Pl(Ne,Qe,null)}finally{Na()}return new tg(this.componentType,mt,Ic(Et,Qe),Qe,Et)}}class tg extends class $v{}{constructor(a,c,f,m,v){super(),this.location=f,this._rootLView=m,this._tNode=v,this.instance=c,this.hostView=this.changeDetectorRef=new MC(m),this.componentType=a}setInput(a,c){const f=this._tNode.inputs;let m;if(null!==f&&(m=f[a])){const v=this._rootLView;eg(v[1],v,m,a,c),Ru(v,this._tNode.index)}}get injector(){return new bi(this._tNode,this._rootLView)}destroy(){this.hostView.destroy()}onDestroy(a){this.hostView.onDestroy(a)}}function $C(){const i=ur();Ki(st()[1],i)}let Df=null;function Fc(){if(!Df){const i=Zt.Symbol;if(i&&i.iterator)Df=i.iterator;else{const a=Object.getOwnPropertyNames(Map.prototype);for(let c=0;c<a.length;++c){const f=a[c];"entries"!==f&&"size"!==f&&Map.prototype[f]===Map.prototype.entries&&(Df=f)}}}return Df}function Kd(i){return!!rg(i)&&(Array.isArray(i)||!(i instanceof Map)&&Fc()in i)}function rg(i){return null!==i&&("function"==typeof i||"object"==typeof i)}function Hs(i,a,c){return!Object.is(i[a],c)&&(i[a]=c,!0)}function sg(i,a,c,f){const m=st();return Hs(m,so(),a)&&(_n(),sa(Fn(),m,i,a,c,f)),sg}function ig(i,a,c){const f=st();return Hs(f,so(),a)&&function Lo(i,a,c,f,m,v,w,D){const R=Ur(a,c);let W,L=a.inputs;!D&&null!=L&&(W=L[f])?(eg(i,c,W,f,m),Gr(a)&&Ru(c,a.index)):3&a.type&&(f=function xC(i){return"class"===i?"className":"for"===i?"htmlFor":"formaction"===i?"formAction":"innerHtml"===i?"innerHTML":"readonly"===i?"readOnly":"tabindex"===i?"tabIndex":i}(f),m=null!=w?w(m,a.value||"",f):m,v.setProperty(R,f,m))}(_n(),Fn(),f,i,a,f[11],c,!1),ig}function ag(i,a,c,f,m){const w=m?"class":"style";eg(i,c,a.inputs[w],w,f)}function Nf(i,a,c,f){const m=st(),v=_n(),w=22+i,D=m[11],R=m[w]=Zp(D,a,function Ra(){return hn.lFrame.currentNamespace}()),L=v.firstCreatePass?function KC(i,a,c,f,m,v,w){const D=a.consts,L=na(a,i,2,m,ko(D,v));return function vf(i,a,c,f){let m=!1;if(fl()){const v=function b0(i,a,c){const f=i.directiveRegistry;let m=null;if(f)for(let v=0;v<f.length;v++){const w=f[v];Iu(c,w.selectors,!1)&&(m||(m=[]),mc(Oa(c,a),i,w.type),ps(w)?(_0(i,c),m.unshift(w)):m.push(w))}return m}(i,a,c),w=null===f?null:{"":-1};if(null!==v){m=!0,x0(c,i.data.length,v.length);for(let W=0;W<v.length;W++){const J=v[W];J.providersResolver&&J.providersResolver(J)}let D=!1,R=!1,L=ku(i,a,v.length,null);for(let W=0;W<v.length;W++){const J=v[W];c.mergedAttrs=or(c.mergedAttrs,J.hostAttrs),w0(i,c,a,L,J),IC(L,J,w),null!==J.contentQueries&&(c.flags|=8),(null!==J.hostBindings||null!==J.hostAttrs||0!==J.hostVars)&&(c.flags|=128);const fe=J.type.prototype;!D&&(fe.ngOnChanges||fe.ngOnInit||fe.ngDoCheck)&&((i.preOrderHooks||(i.preOrderHooks=[])).push(c.index),D=!0),!R&&(fe.ngOnChanges||fe.ngDoCheck)&&((i.preOrderCheckHooks||(i.preOrderCheckHooks=[])).push(c.index),R=!0),L++}m0(i,c)}w&&function _f(i,a,c){if(a){const f=i.localNames=[];for(let m=0;m<a.length;m+=2){const v=c[a[m+1]];if(null==v)throw new Xe(-301,!1);f.push(a[m],v)}}}(c,f,w)}return c.mergedAttrs=or(c.mergedAttrs,c.attrs),m}(a,c,L,ko(D,w)),null!==L.attrs&&jd(L,L.attrs,!1),null!==L.mergedAttrs&&jd(L,L.mergedAttrs,!0),null!==a.queries&&a.queries.elementStart(a,L),L}(w,v,m,0,a,c,f):v.data[w];Xs(L,!0);const W=L.mergedAttrs;null!==W&&yn(D,R,W);const J=L.classes;null!==J&&Sv(D,R,J);const fe=L.styles;return null!==fe&&rm(D,R,fe),64!=(64&L.flags)&&Qh(v,m,R,L),0===function hl(){return hn.lFrame.elementDepthCount}()&&bs(R,m),function ac(){hn.lFrame.elementDepthCount++}(),Io(L)&&(function Zn(i,a,c){!fl()||(function EC(i,a,c,f){const m=c.directiveStart,v=c.directiveEnd;i.firstCreatePass||Oa(c,a),bs(f,a);const w=c.initialInputs;for(let D=m;D<v;D++){const R=i.data[D],L=ps(R);L&&DC(a,c,R);const W=wl(a,i,D,c);bs(W,a),null!==w&&TC(0,D-m,W,R,0,w),L&&(ns(c.index,a)[8]=W)}}(i,a,c,Ur(c,a)),128==(128&c.flags)&&function bf(i,a,c){const f=c.directiveStart,m=c.directiveEnd,v=c.index,w=function mi(){return hn.lFrame.currentDirectiveIndex}();try{$s(v);for(let D=f;D<m;D++){const R=i.data[D],L=a[D];gi(D),(null!==R.hostBindings||0!==R.hostVars||null!==R.hostAttrs)&&v0(R,L)}}finally{$s(-1),gi(w)}}(i,a,c))}(v,m,L),function p0(i,a,c){if(hi(a)){const m=a.directiveEnd;for(let v=a.directiveStart;v<m;v++){const w=i.data[v];w.contentQueries&&w.contentQueries(1,c[v],v)}}}(v,L,m)),null!==f&&function Km(i,a,c=Ur){const f=a.localNames;if(null!==f){let m=a.index+1;for(let v=0;v<f.length;v+=2){const w=f[v+1],D=-1===w?c(a,i):i[w];i[m++]=D}}}(m,L),Nf}function kf(){let i=ur();Ao()?function Go(){hn.lFrame.isParent=!1}():(i=i.parent,Xs(i,!1));const a=i;!function ru(){hn.lFrame.elementDepthCount--}();const c=_n();return c.firstCreatePass&&(Ki(c,i),hi(i)&&c.queries.elementEnd(i)),null!=a.classesWithoutHost&&function Ht(i){return 0!=(16&i.flags)}(a)&&ag(c,a,st(),a.classesWithoutHost,!0),null!=a.stylesWithoutHost&&function Dn(i){return 0!=(32&i.flags)}(a)&&ag(c,a,st(),a.stylesWithoutHost,!1),kf}function lg(i,a,c,f){return Nf(i,a,c,f),kf(),lg}function ug(i){return!!i&&"function"==typeof i.then}function YC(i){return!!i&&"function"==typeof i.subscribe}const ZC=YC;function Xd(i,a,c,f){const m=st(),v=_n(),w=ur();return function z0(i,a,c,f,m,v,w,D){const R=Io(f),W=i.firstCreatePass&&S0(i),J=a[8],fe=Jm(a);let Ne=!0;if(3&f.type||D){const Et=Ur(f,a),Ut=D?D(Et):Et,en=fe.length,ft=D?On=>D(jn(On[f.index])):f.index;let pn=null;if(!D&&R&&(pn=function QC(i,a,c,f){const m=i.cleanup;if(null!=m)for(let v=0;v<m.length-1;v+=2){const w=m[v];if(w===c&&m[v+1]===f){const D=a[7],R=m[v+2];return D.length>R?D[R]:null}"string"==typeof w&&(v+=2)}return null}(i,a,m,f.index)),null!==pn)(pn.__ngLastListenerFn__||pn).__ngNextListenerFn__=v,pn.__ngLastListenerFn__=v,Ne=!1;else{v=W0(f,a,J,v,!1);const On=c.listen(Ut,m,v);fe.push(v,On),W&&W.push(m,ft,en,en+1)}}else v=W0(f,a,J,v,!1);const Qe=f.outputs;let mt;if(Ne&&null!==Qe&&(mt=Qe[m])){const Et=mt.length;if(Et)for(let Ut=0;Ut<Et;Ut+=2){const xr=a[mt[Ut]][mt[Ut+1]].subscribe(v),Cs=fe.length;fe.push(v,xr),W&&W.push(m,f.index,Cs,-(Cs+1))}}}(v,m,m[11],w,i,a,0,f),Xd}function H0(i,a,c,f){try{return!1!==c(f)}catch(m){return I0(i,m),!1}}function W0(i,a,c,f,m){return function v(w){if(w===Function)return f;Qm(2&i.flags?ns(i.index,a):a);let R=H0(a,0,f,w),L=v.__ngNextListenerFn__;for(;L;)R=H0(a,0,L,w)&&R,L=L.__ngNextListenerFn__;return m&&!1===R&&(w.preventDefault(),w.returnValue=!1),R}}function mb(i,a=""){const c=st(),f=_n(),m=i+22,v=f.firstCreatePass?na(f,m,1,a,null):f.data[m],w=c[m]=function ri(i,a){return i.createText(a)}(c[11],a);Qh(f,c,w,v),Xs(v,!1)}function Rf(i){return fg("",i,""),Rf}function fg(i,a,c){const f=st(),m=function Ou(i,a,c,f){return Hs(i,so(),c)?a+ie(c)+f:sn}(f,i,a,c);return m!==sn&&Xa(f,kr(),m),fg}const Za=void 0;var gg=["en",[["a","p"],["AM","PM"],Za],[["AM","PM"],Za,Za],[["S","M","T","W","T","F","S"],["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],["Su","Mo","Tu","We","Th","Fr","Sa"]],Za,[["J","F","M","A","M","J","J","A","S","O","N","D"],["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],["January","February","March","April","May","June","July","August","September","October","November","December"]],Za,[["B","A"],["BC","AD"],["Before Christ","Anno Domini"]],0,[6,0],["M/d/yy","MMM d, y","MMMM d, y","EEEE, MMMM d, y"],["h:mm a","h:mm:ss a","h:mm:ss a z","h:mm:ss a zzzz"],["{1}, {0}",Za,"{1} 'at' {0}",Za],[".",",",";","%","+","-","E","\xd7","\u2030","\u221e","NaN",":"],["#,##0.###","#,##0%","\xa4#,##0.00","#E0"],"USD","$","US Dollar",{},"ltr",function N1(i){const c=Math.floor(Math.abs(i)),f=i.toString().replace(/^[^.]*\.?/,"").length;return 1===c&&0===f?1:5}];let Lc={};function Jd(i){const a=function k1(i){return i.toLowerCase().replace(/_/g,"-")}(i);let c=Of(a);if(c)return c;const f=a.split("-")[0];if(c=Of(f),c)return c;if("en"===f)return gg;throw new Xe(701,!1)}function Rb(i){return Jd(i)[on.PluralCase]}function Of(i){return i in Lc||(Lc[i]=Zt.ng&&Zt.ng.common&&Zt.ng.common.locales&&Zt.ng.common.locales[i]),Lc[i]}var on=(()=>((on=on||{})[on.LocaleId=0]="LocaleId",on[on.DayPeriodsFormat=1]="DayPeriodsFormat",on[on.DayPeriodsStandalone=2]="DayPeriodsStandalone",on[on.DaysFormat=3]="DaysFormat",on[on.DaysStandalone=4]="DaysStandalone",on[on.MonthsFormat=5]="MonthsFormat",on[on.MonthsStandalone=6]="MonthsStandalone",on[on.Eras=7]="Eras",on[on.FirstDayOfWeek=8]="FirstDayOfWeek",on[on.WeekendRange=9]="WeekendRange",on[on.DateFormat=10]="DateFormat",on[on.TimeFormat=11]="TimeFormat",on[on.DateTimeFormat=12]="DateTimeFormat",on[on.NumberSymbols=13]="NumberSymbols",on[on.NumberFormats=14]="NumberFormats",on[on.CurrencyCode=15]="CurrencyCode",on[on.CurrencySymbol=16]="CurrencySymbol",on[on.CurrencyName=17]="CurrencyName",on[on.Currencies=18]="Currencies",on[on.Directionality=19]="Directionality",on[on.PluralCase=20]="PluralCase",on[on.ExtraData=21]="ExtraData",on))();const Xu="en-US";let Mb=Xu;function xs(i,a,c,f,m){if(i=Dt(i),Array.isArray(i))for(let v=0;v<i.length;v++)xs(i[v],a,c,f,m);else{const v=_n(),w=st();let D=Rl(i)?i:Dt(i.provide),R=Nw(i);const L=ur(),W=1048575&L.providerIndexes,J=L.directiveStart,fe=L.providerIndexes>>20;if(Rl(i)||!i.multi){const Ne=new M(R,m,kc),Qe=Tg(D,a,m?W:W+fe,J);-1===Qe?(mc(Oa(L,w),v,D),Dg(v,i,a.length),a.push(D),L.directiveStart++,L.directiveEnd++,m&&(L.providerIndexes+=1048576),c.push(Ne),w.push(Ne)):(c[Qe]=Ne,w[Qe]=Ne)}else{const Ne=Tg(D,a,W+fe,J),Qe=Tg(D,a,W,W+fe),mt=Ne>=0&&c[Ne],Et=Qe>=0&&c[Qe];if(m&&!Et||!m&&!mt){mc(Oa(L,w),v,D);const Ut=function yS(i,a,c,f,m){const v=new M(i,c,kc);return v.multi=[],v.index=a,v.componentProviders=0,ca(v,m,f&&!c),v}(m?gS:mS,c.length,m,f,R);!m&&Et&&(c[Qe].providerFactory=Ut),Dg(v,i,a.length,0),a.push(D),L.directiveStart++,L.directiveEnd++,m&&(L.providerIndexes+=1048576),c.push(Ut),w.push(Ut)}else Dg(v,i,Ne>-1?Ne:Qe,ca(c[m?Qe:Ne],R,!m&&f));!m&&f&&Et&&c[Qe].componentProviders++}}}function Dg(i,a,c,f){const m=Rl(a),v=function Fv(i){return!!i.useClass}(a);if(m||v){const R=(v?Dt(a.useClass):a).prototype.ngOnDestroy;if(R){const L=i.destroyHooks||(i.destroyHooks=[]);if(!m&&a.multi){const W=L.indexOf(c);-1===W?L.push(c,[f,R]):L[W+1].push(f,R)}else L.push(c,R)}}}function ca(i,a,c){return c&&i.componentProviders++,i.multi.push(a)-1}function Tg(i,a,c,f){for(let m=c;m<f;m++)if(a[m]===i)return m;return-1}function mS(i,a,c,f){return Ng(this.multi,[])}function gS(i,a,c,f){const m=this.multi;let v;if(this.providerFactory){const w=this.providerFactory.componentProviders,D=wl(c,c[1],this.providerFactory.index,f);v=D.slice(0,w),Ng(m,v);for(let R=w;R<D.length;R++)v.push(D[R])}else v=[],Ng(m,v);return v}function Ng(i,a){for(let c=0;c<i.length;c++)a.push((0,i[c])());return a}function e_(i,a=[]){return c=>{c.providersResolver=(f,m)=>function pS(i,a,c){const f=_n();if(f.firstCreatePass){const m=ps(i);xs(c,f.data,f.blueprint,m,!0),xs(a,f.data,f.blueprint,m,!1)}}(f,m?m(i):i,a)}}class Yu{}class t_{}function vS(i,a){return new n_(i,null!=a?a:null)}class n_ extends Yu{constructor(a,c){super(),this._parent=c,this._bootstrapComponents=[],this.destroyCbs=[],this.componentFactoryResolver=new Cf(this);const f=nn(a);this._bootstrapComponents=Ga(f.bootstrap),this._r3Injector=Ol(a,c,[{provide:Yu,useValue:this},{provide:Su,useValue:this.componentFactoryResolver}],vt(a),new Set(["environment"])),this._r3Injector.resolveInjectorInitializers(),this.instance=this._r3Injector.get(a)}get injector(){return this._r3Injector}destroy(){const a=this._r3Injector;!a.destroyed&&a.destroy(),this.destroyCbs.forEach(c=>c()),this.destroyCbs=null}onDestroy(a){this.destroyCbs.push(a)}}class kg extends t_{constructor(a){super(),this.moduleType=a}create(a){return new n_(this.moduleType,a)}}class bS extends Yu{constructor(a,c,f){super(),this.componentFactoryResolver=new Cf(this),this.instance=null;const m=new bm([...a,{provide:Yu,useValue:this},{provide:Su,useValue:this.componentFactoryResolver}],c||vm(),f,new Set(["environment"]));this.injector=m,m.resolveInjectorInitializers()}destroy(){this.injector.destroy()}onDestroy(a){this.injector.onDestroy(a)}}function Ag(i,a,c=null){return new bS(i,a,c).injector}let _S=(()=>{class i{constructor(c){this._injector=c,this.cachedInjectors=new Map}getOrCreateStandaloneInjector(c){if(!c.standalone)return null;if(!this.cachedInjectors.has(c.id)){const f=hm(0,c.type),m=f.length>0?Ag([f],this._injector,`Standalone[${c.type.name}]`):null;this.cachedInjectors.set(c.id,m)}return this.cachedInjectors.get(c.id)}ngOnDestroy(){try{for(const c of this.cachedInjectors.values())null!==c&&c.destroy()}finally{this.cachedInjectors.clear()}}}return i.\u0275prov=Bt({token:i,providedIn:"environment",factory:()=>new i(br(ja))}),i})();function r_(i){i.getStandaloneInjector=a=>a.get(_S).getOrCreateStandaloneInjector(i)}function ih(i){return a=>{setTimeout(i,void 0,a)}}const ai=class Ug extends P.x{constructor(a=!1){super(),this.__isAsync=a}emit(a){super.next(a)}subscribe(a,c,f){var m,v,w;let D=a,R=c||(()=>null),L=f;if(a&&"object"==typeof a){const J=a;D=null===(m=J.next)||void 0===m?void 0:m.bind(J),R=null===(v=J.error)||void 0===v?void 0:v.bind(J),L=null===(w=J.complete)||void 0===w?void 0:w.bind(J)}this.__isAsync&&(R=ih(R),D&&(D=ih(D)),L&&(L=ih(L)));const W=super.subscribe({next:D,error:R,complete:L});return a instanceof ae.w0&&a.add(W),W}};function zg(){return this._results[Fc()]()}class ah{constructor(a=!1){this._emitDistinctChangesOnly=a,this.dirty=!0,this._results=[],this._changesDetected=!1,this._changes=null,this.length=0,this.first=void 0,this.last=void 0;const c=Fc(),f=ah.prototype;f[c]||(f[c]=zg)}get changes(){return this._changes||(this._changes=new ai)}get(a){return this._results[a]}map(a){return this._results.map(a)}filter(a){return this._results.filter(a)}find(a){return this._results.find(a)}reduce(a,c){return this._results.reduce(a,c)}forEach(a){this._results.forEach(a)}some(a){return this._results.some(a)}toArray(){return this._results.slice()}toString(){return this._results.toString()}reset(a,c){const f=this;f.dirty=!1;const m=os(a);(this._changesDetected=!function xd(i,a,c){if(i.length!==a.length)return!1;for(let f=0;f<i.length;f++){let m=i[f],v=a[f];if(c&&(m=c(m),v=c(v)),v!==m)return!1}return!0}(f._results,m,c))&&(f._results=m,f.length=m.length,f.last=m[this.length-1],f.first=m[0])}notifyOnChanges(){this._changes&&(this._changesDetected||!this._emitDistinctChangesOnly)&&this._changes.emit(this)}setDirty(){this.dirty=!0}destroy(){this.changes.complete(),this.changes.unsubscribe()}}let Uc=(()=>{class i{}return i.__NG_ELEMENT_ID__=Qa,i})();const Hg=Uc,Wg=class extends Hg{constructor(a,c,f){super(),this._declarationLView=a,this._declarationTContainer=c,this.elementRef=f}createEmbeddedView(a,c){const f=this._declarationTContainer.tViews,m=pr(this._declarationLView,f,a,16,null,f.declTNode,null,null,null,null,c||null);m[17]=this._declarationLView[this._declarationTContainer.index];const w=this._declarationLView[19];return null!==w&&(m[19]=w.createEmbeddedView(f)),Pl(f,m,a),new Vl(m)}};function Qa(){return lh(ur(),st())}function lh(i,a){return 4&i.type?new Wg(a,i,Ic(i,a)):null}let ch=(()=>{class i{}return i.__NG_ELEMENT_ID__=d_,i})();function d_(){return Kf(ur(),st())}const jg=ch,Gg=class extends jg{constructor(a,c,f){super(),this._lContainer=a,this._hostTNode=c,this._hostLView=f}get element(){return Ic(this._hostTNode,this._hostLView)}get injector(){return new bi(this._hostTNode,this._hostLView)}get parentInjector(){const a=xl(this._hostTNode,this._hostLView);if(gs(a)){const c=Mo(a,this._hostLView),f=ss(a);return new bi(c[1].data[f+8],c)}return new bi(null,this._hostLView)}clear(){for(;this.length>0;)this.remove(this.length-1)}get(a){const c=Kg(this._lContainer);return null!==c&&c[a]||null}get length(){return this._lContainer.length-10}createEmbeddedView(a,c,f){let m,v;"number"==typeof f?m=f:null!=f&&(m=f.index,v=f.injector);const w=a.createEmbeddedView(c||{},v);return this.insert(w,m),w}createComponent(a,c,f,m,v){const w=a&&!function yc(i){return"function"==typeof i}(a);let D;if(w)D=c;else{const J=c||{};D=J.index,f=J.injector,m=J.projectableNodes,v=J.environmentInjector||J.ngModuleRef}const R=w?a:new Gd(ne(a)),L=f||this.parentInjector;if(!v&&null==R.ngModule){const fe=(w?L:this.parentInjector).get(ja,null);fe&&(v=fe)}const W=R.create(L,m,void 0,v);return this.insert(W.hostView,D),W}insert(a,c){const f=a._lView,m=f[1];if(function tu(i){return es(i[3])}(f)){const W=this.indexOf(a);if(-1!==W)this.detach(W);else{const J=f[3],fe=new Gg(J,J[6],J[3]);fe.detach(fe.indexOf(a))}}const v=this._adjustIndex(c),w=this._lContainer;!function gv(i,a,c,f){const m=10+f,v=c.length;f>0&&(c[m-1][4]=a),f<v-10?(a[4]=c[m],vc(c,10+f,a)):(c.push(a),a[4]=null),a[3]=c;const w=a[17];null!==w&&c!==w&&function yv(i,a){const c=i[9];a[16]!==a[3][3][16]&&(i[2]=!0),null===c?i[9]=[a]:c.push(a)}(w,a);const D=a[19];null!==D&&D.insertView(i),a[2]|=64}(m,f,w,v);const D=wv(v,w),R=f[11],L=Yh(R,w[7]);return null!==L&&function Qx(i,a,c,f,m,v){f[0]=m,f[6]=a,gn(i,f,c,1,m,v)}(m,w[6],R,f,L,D),a.attachToViewContainerRef(),vc(Gf(w),v,a),a}move(a,c){return this.insert(a,c)}indexOf(a){const c=Kg(this._lContainer);return null!==c?c.indexOf(a):-1}remove(a){const c=this._adjustIndex(a,-1),f=Jp(this._lContainer,c);f&&(wd(Gf(this._lContainer),c),wc(f[1],f))}detach(a){const c=this._adjustIndex(a,-1),f=Jp(this._lContainer,c);return f&&null!=wd(Gf(this._lContainer),c)?new Vl(f):null}_adjustIndex(a,c=0){return null==a?this.length+c:a}};function Kg(i){return i[8]}function Gf(i){return i[8]||(i[8]=[])}function Kf(i,a){let c;const f=a[i.index];if(es(f))c=f;else{let m;if(8&i.type)m=jn(f);else{const v=a[11];m=v.createComment("");const w=Ur(i,a);ea(v,Yh(v,w),m,function tm(i,a){return i.nextSibling(a)}(v,w),!1)}a[i.index]=c=function xf(i,a,c,f){return new Array(i,!0,!1,a,null,0,f,c,null,null)}(f,a,m,i),Bl(a,c)}return new Gg(c,i,a)}class uh{constructor(a){this.queryList=a,this.matches=null}clone(){return new uh(this.queryList)}setDirty(){this.queryList.setDirty()}}class dh{constructor(a=[]){this.queries=a}createEmbeddedView(a){const c=a.queries;if(null!==c){const f=null!==a.contentQueries?a.contentQueries[0]:c.length,m=[];for(let v=0;v<f;v++){const w=c.getByIndex(v);m.push(this.queries[w.indexInDeclarationView].clone())}return new dh(m)}return null}insertView(a){this.dirtyQueriesWithMatches(a)}detachView(a){this.dirtyQueriesWithMatches(a)}dirtyQueriesWithMatches(a){for(let c=0;c<this.queries.length;c++)null!==ry(a,c).matches&&this.queries[c].setDirty()}}class qf{constructor(a,c,f=null){this.predicate=a,this.flags=c,this.read=f}}class hh{constructor(a=[]){this.queries=a}elementStart(a,c){for(let f=0;f<this.queries.length;f++)this.queries[f].elementStart(a,c)}elementEnd(a){for(let c=0;c<this.queries.length;c++)this.queries[c].elementEnd(a)}embeddedTView(a){let c=null;for(let f=0;f<this.length;f++){const m=null!==c?c.length:0,v=this.getByIndex(f).embeddedTView(a,m);v&&(v.indexInDeclarationView=f,null!==c?c.push(v):c=[v])}return null!==c?new hh(c):null}template(a,c){for(let f=0;f<this.queries.length;f++)this.queries[f].template(a,c)}getByIndex(a){return this.queries[a]}get length(){return this.queries.length}track(a){this.queries.push(a)}}class fh{constructor(a,c=-1){this.metadata=a,this.matches=null,this.indexInDeclarationView=-1,this.crossesNgTemplate=!1,this._appliesToNextNode=!0,this._declarationNodeIndex=c}elementStart(a,c){this.isApplyingToNode(c)&&this.matchTNode(a,c)}elementEnd(a){this._declarationNodeIndex===a.index&&(this._appliesToNextNode=!1)}template(a,c){this.elementStart(a,c)}embeddedTView(a,c){return this.isApplyingToNode(a)?(this.crossesNgTemplate=!0,this.addMatch(-a.index,c),new fh(this.metadata)):null}isApplyingToNode(a){if(this._appliesToNextNode&&1!=(1&this.metadata.flags)){const c=this._declarationNodeIndex;let f=a.parent;for(;null!==f&&8&f.type&&f.index!==c;)f=f.parent;return c===(null!==f?f.index:-1)}return this._appliesToNextNode}matchTNode(a,c){const f=this.metadata.predicate;if(Array.isArray(f))for(let m=0;m<f.length;m++){const v=f[m];this.matchTNodeWithReadOption(a,c,BS(c,v)),this.matchTNodeWithReadOption(a,c,Xi(c,a,v,!1,!1))}else f===Uc?4&c.type&&this.matchTNodeWithReadOption(a,c,-1):this.matchTNodeWithReadOption(a,c,Xi(c,a,f,!1,!1))}matchTNodeWithReadOption(a,c,f){if(null!==f){const m=this.metadata.read;if(null!==m)if(m===Dc||m===ch||m===Uc&&4&c.type)this.addMatch(c.index,-2);else{const v=Xi(c,a,m,!1,!1);null!==v&&this.addMatch(c.index,v)}else this.addMatch(c.index,f)}}addMatch(a,c){null===this.matches?this.matches=[a,c]:this.matches.push(a,c)}}function BS(i,a){const c=i.localNames;if(null!==c)for(let f=0;f<c.length;f+=2)if(c[f]===a)return c[f+1];return null}function f_(i,a,c,f){return-1===c?function qg(i,a){return 11&i.type?Ic(i,a):4&i.type?lh(i,a):null}(a,i):-2===c?function p_(i,a,c){return c===Dc?Ic(a,i):c===Uc?lh(a,i):c===ch?Kf(a,i):void 0}(i,a,f):wl(i,i[1],c,a)}function Xg(i,a,c,f){const m=a[19].queries[f];if(null===m.matches){const v=i.data,w=c.matches,D=[];for(let R=0;R<w.length;R+=2){const L=w[R];D.push(L<0?null:f_(a,v[L],w[R+1],c.metadata.read))}m.matches=D}return m.matches}function Xf(i,a,c,f){const m=i.queries.getByIndex(c),v=m.matches;if(null!==v){const w=Xg(i,a,m,c);for(let D=0;D<v.length;D+=2){const R=v[D];if(R>0)f.push(w[D/2]);else{const L=v[D+1],W=a[-R];for(let J=10;J<W.length;J++){const fe=W[J];fe[17]===fe[3]&&Xf(fe[1],fe,L,f)}if(null!==W[9]){const J=W[9];for(let fe=0;fe<J.length;fe++){const Ne=J[fe];Xf(Ne[1],Ne,L,f)}}}}}return f}function Yg(i){const a=st(),c=_n(),f=lc();Gi(f+1);const m=ry(c,f);if(i.dirty&&function gd(i){return 4==(4&i[2])}(a)===(2==(2&m.metadata.flags))){if(null===m.matches)i.reset([]);else{const v=m.crossesNgTemplate?Xf(c,a,f,[]):Xg(c,a,m,f);i.reset(v,Em),i.notifyOnChanges()}return!0}return!1}function Zg(i,a,c){const f=_n();f.firstCreatePass&&(ny(f,new qf(i,a,c),-1),2==(2&a)&&(f.staticViewQueries=!0)),ty(f,st(),a)}function Qg(i,a,c,f){const m=_n();if(m.firstCreatePass){const v=ur();ny(m,new qf(a,c,f),v.index),function m_(i,a){const c=i.contentQueries||(i.contentQueries=[]);a!==(c.length?c[c.length-1]:-1)&&c.push(i.queries.length-1,a)}(m,i),2==(2&c)&&(m.staticContentQueries=!0)}ty(m,st(),c)}function Jg(){return function ey(i,a){return i[19].queries[a].queryList}(st(),lc())}function ty(i,a,c){const f=new ah(4==(4&c));Ll(i,a,f,f.destroy),null===a[19]&&(a[19]=new dh),a[19].queries.push(new uh(f))}function ny(i,a,c){null===i.queries&&(i.queries=new hh),i.queries.track(new fh(a,c))}function ry(i,a){return i.queries.getByIndex(a)}function mh(...i){}const op=new Gn("Application Initializer");let ip=(()=>{class i{constructor(c){this.appInits=c,this.resolve=mh,this.reject=mh,this.initialized=!1,this.done=!1,this.donePromise=new Promise((f,m)=>{this.resolve=f,this.reject=m})}runInitializers(){if(this.initialized)return;const c=[],f=()=>{this.done=!0,this.resolve()};if(this.appInits)for(let m=0;m<this.appInits.length;m++){const v=this.appInits[m]();if(ug(v))c.push(v);else if(ZC(v)){const w=new Promise((D,R)=>{v.subscribe({complete:D,error:R})});c.push(w)}}Promise.all(c).then(()=>{f()}).catch(m=>{this.reject(m)}),0===c.length&&f(),this.initialized=!0}}return i.\u0275fac=function(c){return new(c||i)(br(op,8))},i.\u0275prov=Bt({token:i,factory:i.\u0275fac,providedIn:"root"}),i})();const Wl=new Gn("AppId",{providedIn:"root",factory:function k_(){return`${hy()}${hy()}${hy()}`}});function hy(){return String.fromCharCode(97+Math.floor(25*Math.random()))}const A_=new Gn("Platform Initializer"),XS=new Gn("Platform ID",{providedIn:"platform",factory:()=>"unknown"}),YS=new Gn("appBootstrapListener"),QS=new Gn("AnimationModuleType");let jD=(()=>{class i{log(c){console.log(c)}warn(c){console.warn(c)}}return i.\u0275fac=function(c){return new(c||i)},i.\u0275prov=Bt({token:i,factory:i.\u0275fac,providedIn:"platform"}),i})();const fy=new Gn("LocaleId",{providedIn:"root",factory:()=>zh(fy,St.Optional|St.SkipSelf)||function JS(){return"undefined"!=typeof $localize&&$localize.locale||Xu}()}),py=new Gn("DefaultCurrencyCode",{providedIn:"root",factory:()=>"USD"});class qD{constructor(a,c){this.ngModuleFactory=a,this.componentFactories=c}}let eE=(()=>{class i{compileModuleSync(c){return new kg(c)}compileModuleAsync(c){return Promise.resolve(this.compileModuleSync(c))}compileModuleAndAllComponentsSync(c){const f=this.compileModuleSync(c),v=Ga(nn(c).declarations).reduce((w,D)=>{const R=ne(D);return R&&w.push(new Gd(R)),w},[]);return new qD(f,v)}compileModuleAndAllComponentsAsync(c){return Promise.resolve(this.compileModuleAndAllComponentsSync(c))}clearCache(){}clearCacheFor(c){}getModuleId(c){}}return i.\u0275fac=function(c){return new(c||i)},i.\u0275prov=Bt({token:i,factory:i.\u0275fac,providedIn:"root"}),i})();const ZD=(()=>Promise.resolve(0))();function my(i){"undefined"==typeof Zone?ZD.then(()=>{i&&i.apply(null,null)}):Zone.current.scheduleMicroTask("scheduleMicrotask",i)}class li{constructor({enableLongStackTrace:a=!1,shouldCoalesceEventChangeDetection:c=!1,shouldCoalesceRunChangeDetection:f=!1}){if(this.hasPendingMacrotasks=!1,this.hasPendingMicrotasks=!1,this.isStable=!0,this.onUnstable=new ai(!1),this.onMicrotaskEmpty=new ai(!1),this.onStable=new ai(!1),this.onError=new ai(!1),"undefined"==typeof Zone)throw new Xe(908,!1);Zone.assertZonePatched();const m=this;if(m._nesting=0,m._outer=m._inner=Zone.current,Zone.AsyncStackTaggingZoneSpec){const v=Zone.AsyncStackTaggingZoneSpec;m._inner=m._inner.fork(new v("Angular"))}Zone.TaskTrackingZoneSpec&&(m._inner=m._inner.fork(new Zone.TaskTrackingZoneSpec)),a&&Zone.longStackTraceZoneSpec&&(m._inner=m._inner.fork(Zone.longStackTraceZoneSpec)),m.shouldCoalesceEventChangeDetection=!f&&c,m.shouldCoalesceRunChangeDetection=f,m.lastRequestAnimationFrameId=-1,m.nativeRequestAnimationFrame=function QD(){let i=Zt.requestAnimationFrame,a=Zt.cancelAnimationFrame;if("undefined"!=typeof Zone&&i&&a){const c=i[Zone.__symbol__("OriginalDelegate")];c&&(i=c);const f=a[Zone.__symbol__("OriginalDelegate")];f&&(a=f)}return{nativeRequestAnimationFrame:i,nativeCancelAnimationFrame:a}}().nativeRequestAnimationFrame,function rE(i){const a=()=>{!function eT(i){i.isCheckStableRunning||-1!==i.lastRequestAnimationFrameId||(i.lastRequestAnimationFrameId=i.nativeRequestAnimationFrame.call(Zt,()=>{i.fakeTopEventTask||(i.fakeTopEventTask=Zone.root.scheduleEventTask("fakeTopEventTask",()=>{i.lastRequestAnimationFrameId=-1,M_(i),i.isCheckStableRunning=!0,gy(i),i.isCheckStableRunning=!1},void 0,()=>{},()=>{})),i.fakeTopEventTask.invoke()}),M_(i))}(i)};i._inner=i._inner.fork({name:"angular",properties:{isAngularZone:!0},onInvokeTask:(c,f,m,v,w,D)=>{try{return O_(i),c.invokeTask(m,v,w,D)}finally{(i.shouldCoalesceEventChangeDetection&&"eventTask"===v.type||i.shouldCoalesceRunChangeDetection)&&a(),sE(i)}},onInvoke:(c,f,m,v,w,D,R)=>{try{return O_(i),c.invoke(m,v,w,D,R)}finally{i.shouldCoalesceRunChangeDetection&&a(),sE(i)}},onHasTask:(c,f,m,v)=>{c.hasTask(m,v),f===m&&("microTask"==v.change?(i._hasPendingMicrotasks=v.microTask,M_(i),gy(i)):"macroTask"==v.change&&(i.hasPendingMacrotasks=v.macroTask))},onHandleError:(c,f,m,v)=>(c.handleError(m,v),i.runOutsideAngular(()=>i.onError.emit(v)),!1)})}(m)}static isInAngularZone(){return"undefined"!=typeof Zone&&!0===Zone.current.get("isAngularZone")}static assertInAngularZone(){if(!li.isInAngularZone())throw new Xe(909,!1)}static assertNotInAngularZone(){if(li.isInAngularZone())throw new Xe(909,!1)}run(a,c,f){return this._inner.run(a,c,f)}runTask(a,c,f,m){const v=this._inner,w=v.scheduleEventTask("NgZoneEvent: "+m,a,JD,mh,mh);try{return v.runTask(w,c,f)}finally{v.cancelTask(w)}}runGuarded(a,c,f){return this._inner.runGuarded(a,c,f)}runOutsideAngular(a){return this._outer.run(a)}}const JD={};function gy(i){if(0==i._nesting&&!i.hasPendingMicrotasks&&!i.isStable)try{i._nesting++,i.onMicrotaskEmpty.emit(null)}finally{if(i._nesting--,!i.hasPendingMicrotasks)try{i.runOutsideAngular(()=>i.onStable.emit(null))}finally{i.isStable=!0}}}function M_(i){i.hasPendingMicrotasks=!!(i._hasPendingMicrotasks||(i.shouldCoalesceEventChangeDetection||i.shouldCoalesceRunChangeDetection)&&-1!==i.lastRequestAnimationFrameId)}function O_(i){i._nesting++,i.isStable&&(i.isStable=!1,i.onUnstable.emit(null))}function sE(i){i._nesting--,gy(i)}class oE{constructor(){this.hasPendingMicrotasks=!1,this.hasPendingMacrotasks=!1,this.isStable=!0,this.onUnstable=new ai,this.onMicrotaskEmpty=new ai,this.onStable=new ai,this.onError=new ai}run(a,c,f){return a.apply(c,f)}runGuarded(a,c,f){return a.apply(c,f)}runOutsideAngular(a){return a()}runTask(a,c,f,m){return a.apply(c,f)}}const iE=new Gn(""),F_=new Gn("");let gh,tT=(()=>{class i{constructor(c,f,m){this._ngZone=c,this.registry=f,this._pendingCount=0,this._isZoneStable=!0,this._didWork=!1,this._callbacks=[],this.taskTrackingZone=null,gh||(function nT(i){gh=i}(m),m.addToWindow(f)),this._watchAngularEvents(),c.run(()=>{this.taskTrackingZone="undefined"==typeof Zone?null:Zone.current.get("TaskTrackingZone")})}_watchAngularEvents(){this._ngZone.onUnstable.subscribe({next:()=>{this._didWork=!0,this._isZoneStable=!1}}),this._ngZone.runOutsideAngular(()=>{this._ngZone.onStable.subscribe({next:()=>{li.assertNotInAngularZone(),my(()=>{this._isZoneStable=!0,this._runCallbacksIfReady()})}})})}increasePendingRequestCount(){return this._pendingCount+=1,this._didWork=!0,this._pendingCount}decreasePendingRequestCount(){if(this._pendingCount-=1,this._pendingCount<0)throw new Error("pending async requests below zero");return this._runCallbacksIfReady(),this._pendingCount}isStable(){return this._isZoneStable&&0===this._pendingCount&&!this._ngZone.hasPendingMacrotasks}_runCallbacksIfReady(){if(this.isStable())my(()=>{for(;0!==this._callbacks.length;){let c=this._callbacks.pop();clearTimeout(c.timeoutId),c.doneCb(this._didWork)}this._didWork=!1});else{let c=this.getPendingTasks();this._callbacks=this._callbacks.filter(f=>!f.updateCb||!f.updateCb(c)||(clearTimeout(f.timeoutId),!1)),this._didWork=!0}}getPendingTasks(){return this.taskTrackingZone?this.taskTrackingZone.macroTasks.map(c=>({source:c.source,creationLocation:c.creationLocation,data:c.data})):[]}addCallback(c,f,m){let v=-1;f&&f>0&&(v=setTimeout(()=>{this._callbacks=this._callbacks.filter(w=>w.timeoutId!==v),c(this._didWork,this.getPendingTasks())},f)),this._callbacks.push({doneCb:c,timeoutId:v,updateCb:m})}whenStable(c,f,m){if(m&&!this.taskTrackingZone)throw new Error('Task tracking zone is required when passing an update callback to whenStable(). Is "zone.js/plugins/task-tracking" loaded?');this.addCallback(c,f,m),this._runCallbacksIfReady()}getPendingRequestCount(){return this._pendingCount}registerApplication(c){this.registry.registerApplication(c,this)}unregisterApplication(c){this.registry.unregisterApplication(c)}findProviders(c,f,m){return[]}}return i.\u0275fac=function(c){return new(c||i)(br(li),br($_),br(F_))},i.\u0275prov=Bt({token:i,factory:i.\u0275fac}),i})(),$_=(()=>{class i{constructor(){this._applications=new Map}registerApplication(c,f){this._applications.set(c,f)}unregisterApplication(c){this._applications.delete(c)}unregisterAllApplications(){this._applications.clear()}getTestability(c){return this._applications.get(c)||null}getAllTestabilities(){return Array.from(this._applications.values())}getAllRootElements(){return Array.from(this._applications.keys())}findTestabilityInTree(c,f=!0){var m;return null!==(m=null==gh?void 0:gh.findTestabilityInTree(this,c,f))&&void 0!==m?m:null}}return i.\u0275fac=function(c){return new(c||i)},i.\u0275prov=Bt({token:i,factory:i.\u0275fac,providedIn:"platform"}),i})(),el=null;const yy=new Gn("AllowMultipleToken"),ap=new Gn("PlatformDestroyListeners");class lE{constructor(a,c){this.name=a,this.token=c}}function jl(i,a,c=[]){const f=`Platform: ${a}`,m=new Gn(f);return(v=[])=>{let w=by();if(!w||w.injector.get(yy,!1)){const D=[...c,...v,{provide:m,useValue:!0}];i?i(D):function cE(i){if(el&&!el.get(yy,!1))throw new Xe(400,!1);el=i;const a=i.get(B_);(function P_(i){const a=i.get(A_,null);a&&a.forEach(c=>c())})(i)}(function L_(i=[],a){return Nc.create({name:a,providers:[{provide:gm,useValue:"platform"},{provide:ap,useValue:new Set([()=>el=null])},...i]})}(D,f))}return function dE(i){const a=by();if(!a)throw new Xe(401,!1);return a}()}}function by(){var i;return null!==(i=null==el?void 0:el.get(B_))&&void 0!==i?i:null}let B_=(()=>{class i{constructor(c){this._injector=c,this._modules=[],this._destroyListeners=[],this._destroyed=!1}bootstrapModuleFactory(c,f){const m=function _y(i,a){let c;return c="noop"===i?new oE:("zone.js"===i?void 0:i)||new li(a),c}(null==f?void 0:f.ngZone,function V_(i){return{enableLongStackTrace:!1,shouldCoalesceEventChangeDetection:!(!i||!i.ngZoneEventCoalescing)||!1,shouldCoalesceRunChangeDetection:!(!i||!i.ngZoneRunCoalescing)||!1}}(f)),v=[{provide:li,useValue:m}];return m.run(()=>{const w=Nc.create({providers:v,parent:this.injector,name:c.moduleType.name}),D=c.create(w),R=D.injector.get(Bd,null);if(!R)throw new Xe(402,!1);return m.runOutsideAngular(()=>{const L=m.onError.subscribe({next:W=>{R.handleError(W)}});D.onDestroy(()=>{up(this._modules,D),L.unsubscribe()})}),function xy(i,a,c){try{const f=c();return ug(f)?f.catch(m=>{throw a.runOutsideAngular(()=>i.handleError(m)),m}):f}catch(f){throw a.runOutsideAngular(()=>i.handleError(f)),f}}(R,m,()=>{const L=D.injector.get(ip);return L.runInitializers(),L.donePromise.then(()=>(function yg(i){qt(i,"Expected localeId to be defined"),"string"==typeof i&&(Mb=i.toLowerCase().replace(/_/g,"-"))}(D.injector.get(fy,Xu)||Xu),this._moduleDoBootstrap(D),D))})})}bootstrapModule(c,f=[]){const m=cp({},f);return function aE(i,a,c){const f=new kg(c);return Promise.resolve(f)}(0,0,c).then(v=>this.bootstrapModuleFactory(v,m))}_moduleDoBootstrap(c){const f=c.injector.get(wy);if(c._bootstrapComponents.length>0)c._bootstrapComponents.forEach(m=>f.bootstrap(m));else{if(!c.instance.ngDoBootstrap)throw new Xe(403,!1);c.instance.ngDoBootstrap(f)}this._modules.push(c)}onDestroy(c){this._destroyListeners.push(c)}get injector(){return this._injector}destroy(){if(this._destroyed)throw new Xe(404,!1);this._modules.slice().forEach(f=>f.destroy()),this._destroyListeners.forEach(f=>f());const c=this._injector.get(ap,null);c&&(c.forEach(f=>f()),c.clear()),this._destroyed=!0}get destroyed(){return this._destroyed}}return i.\u0275fac=function(c){return new(c||i)(br(Nc))},i.\u0275prov=Bt({token:i,factory:i.\u0275fac,providedIn:"platform"}),i})();function cp(i,a){return Array.isArray(a)?a.reduce(cp,i):Object.assign(Object.assign({},i),a)}let wy=(()=>{class i{constructor(c,f,m){this._zone=c,this._injector=f,this._exceptionHandler=m,this._bootstrapListeners=[],this._views=[],this._runningTick=!1,this._stable=!0,this._destroyed=!1,this._destroyListeners=[],this.componentTypes=[],this.components=[],this._onMicrotaskEmptySubscription=this._zone.onMicrotaskEmpty.subscribe({next:()=>{this._zone.run(()=>{this.tick()})}});const v=new Oe.y(D=>{this._stable=this._zone.isStable&&!this._zone.hasPendingMacrotasks&&!this._zone.hasPendingMicrotasks,this._zone.runOutsideAngular(()=>{D.next(this._stable),D.complete()})}),w=new Oe.y(D=>{let R;this._zone.runOutsideAngular(()=>{R=this._zone.onStable.subscribe(()=>{li.assertNotInAngularZone(),my(()=>{!this._stable&&!this._zone.hasPendingMacrotasks&&!this._zone.hasPendingMicrotasks&&(this._stable=!0,D.next(!0))})})});const L=this._zone.onUnstable.subscribe(()=>{li.assertInAngularZone(),this._stable&&(this._stable=!1,this._zone.runOutsideAngular(()=>{D.next(!1)}))});return()=>{R.unsubscribe(),L.unsubscribe()}});this.isStable=function he(...i){const a=(0,ct.yG)(i),c=(0,ct._6)(i,1/0),f=i;return f.length?1===f.length?(0,Le.Xf)(f[0]):(0,ve.J)(c)((0,nt.D)(f,a)):Fe.E}(v,w.pipe(function _e(i={}){const{connector:a=(()=>new P.x),resetOnError:c=!0,resetOnComplete:f=!0,resetOnRefCountZero:m=!0}=i;return v=>{let w,D,R,L=0,W=!1,J=!1;const fe=()=>{null==D||D.unsubscribe(),D=void 0},Ne=()=>{fe(),w=R=void 0,W=J=!1},Qe=()=>{const mt=w;Ne(),null==mt||mt.unsubscribe()};return(0,we.e)((mt,Et)=>{L++,!J&&!W&&fe();const Ut=R=null!=R?R:a();Et.add(()=>{L--,0===L&&!J&&!W&&(D=Ge(Qe,m))}),Ut.subscribe(Et),!w&&L>0&&(w=new Ie.Hp({next:en=>Ut.next(en),error:en=>{J=!0,fe(),D=Ge(Ne,c,en),Ut.error(en)},complete:()=>{W=!0,fe(),D=Ge(Ne,f),Ut.complete()}}),(0,Le.Xf)(mt).subscribe(w))})(v)}}()))}get destroyed(){return this._destroyed}get injector(){return this._injector}bootstrap(c,f){const m=c instanceof Sm;if(!this._injector.get(ip).done)throw!m&&Qt(c),new Xe(405,false);let w;w=m?c:this._injector.get(Su).resolveComponentFactory(c),this.componentTypes.push(w.componentType);const D=function lp(i){return i.isBoundToModule}(w)?void 0:this._injector.get(Yu),L=w.create(Nc.NULL,[],f||w.selector,D),W=L.location.nativeElement,J=L.injector.get(iE,null);return null==J||J.registerApplication(W),L.onDestroy(()=>{this.detachView(L.hostView),up(this.components,L),null==J||J.unregisterApplication(W)}),this._loadComponent(L),L}tick(){if(this._runningTick)throw new Xe(101,!1);try{this._runningTick=!0;for(let c of this._views)c.detectChanges()}catch(c){this._zone.runOutsideAngular(()=>this._exceptionHandler.handleError(c))}finally{this._runningTick=!1}}attachView(c){const f=c;this._views.push(f),f.attachToAppRef(this)}detachView(c){const f=c;up(this._views,f),f.detachFromAppRef()}_loadComponent(c){this.attachView(c.hostView),this.tick(),this.components.push(c),this._injector.get(YS,[]).concat(this._bootstrapListeners).forEach(m=>m(c))}ngOnDestroy(){if(!this._destroyed)try{this._destroyListeners.forEach(c=>c()),this._views.slice().forEach(c=>c.destroy()),this._onMicrotaskEmptySubscription.unsubscribe()}finally{this._destroyed=!0,this._views=[],this._bootstrapListeners=[],this._destroyListeners=[]}}onDestroy(c){return this._destroyListeners.push(c),()=>up(this._destroyListeners,c)}destroy(){if(this._destroyed)throw new Xe(406,!1);const c=this._injector;c.destroy&&!c.destroyed&&c.destroy()}get viewCount(){return this._views.length}warnIfDestroyed(){}}return i.\u0275fac=function(c){return new(c||i)(br(li),br(ja),br(Bd))},i.\u0275prov=Bt({token:i,factory:i.\u0275fac,providedIn:"root"}),i})();function up(i,a){const c=i.indexOf(a);c>-1&&i.splice(c,1)}let zc=!0,dp=!1;function hp(){return dp=!0,zc}function U_(){if(dp)throw new Error("Cannot enable prod mode after platform setup.");zc=!1}let Cy=(()=>{class i{}return i.__NG_ELEMENT_ID__=pE,i})();function pE(i){return function H_(i,a,c){if(Gr(i)&&!c){const f=ns(i.index,a);return new Vl(f,f)}return 47&i.type?new Vl(a[16],a):null}(ur(),st(),16==(16&i))}class eo{constructor(){}supports(a){return Kd(a)}create(a){return new vh(a)}}const cs=(i,a)=>a;class vh{constructor(a){this.length=0,this._linkedRecords=null,this._unlinkedRecords=null,this._previousItHead=null,this._itHead=null,this._itTail=null,this._additionsHead=null,this._additionsTail=null,this._movesHead=null,this._movesTail=null,this._removalsHead=null,this._removalsTail=null,this._identityChangesHead=null,this._identityChangesTail=null,this._trackByFn=a||cs}forEachItem(a){let c;for(c=this._itHead;null!==c;c=c._next)a(c)}forEachOperation(a){let c=this._itHead,f=this._removalsHead,m=0,v=null;for(;c||f;){const w=!f||c&&c.currentIndex<xE(f,m,v)?c:f,D=xE(w,m,v),R=w.currentIndex;if(w===f)m--,f=f._nextRemoved;else if(c=c._next,null==w.previousIndex)m++;else{v||(v=[]);const L=D-m,W=R-m;if(L!=W){for(let fe=0;fe<L;fe++){const Ne=fe<v.length?v[fe]:v[fe]=0,Qe=Ne+fe;W<=Qe&&Qe<L&&(v[fe]=Ne+1)}v[w.previousIndex]=W-L}}D!==R&&a(w,D,R)}}forEachPreviousItem(a){let c;for(c=this._previousItHead;null!==c;c=c._nextPrevious)a(c)}forEachAddedItem(a){let c;for(c=this._additionsHead;null!==c;c=c._nextAdded)a(c)}forEachMovedItem(a){let c;for(c=this._movesHead;null!==c;c=c._nextMoved)a(c)}forEachRemovedItem(a){let c;for(c=this._removalsHead;null!==c;c=c._nextRemoved)a(c)}forEachIdentityChange(a){let c;for(c=this._identityChangesHead;null!==c;c=c._nextIdentityChange)a(c)}diff(a){if(null==a&&(a=[]),!Kd(a))throw new Xe(900,!1);return this.check(a)?this:null}onDestroy(){}check(a){this._reset();let m,v,w,c=this._itHead,f=!1;if(Array.isArray(a)){this.length=a.length;for(let D=0;D<this.length;D++)v=a[D],w=this._trackByFn(D,v),null!==c&&Object.is(c.trackById,w)?(f&&(c=this._verifyReinsertion(c,v,w,D)),Object.is(c.item,v)||this._addIdentityChange(c,v)):(c=this._mismatch(c,v,w,D),f=!0),c=c._next}else m=0,function UC(i,a){if(Array.isArray(i))for(let c=0;c<i.length;c++)a(i[c]);else{const c=i[Fc()]();let f;for(;!(f=c.next()).done;)a(f.value)}}(a,D=>{w=this._trackByFn(m,D),null!==c&&Object.is(c.trackById,w)?(f&&(c=this._verifyReinsertion(c,D,w,m)),Object.is(c.item,D)||this._addIdentityChange(c,D)):(c=this._mismatch(c,D,w,m),f=!0),c=c._next,m++}),this.length=m;return this._truncate(c),this.collection=a,this.isDirty}get isDirty(){return null!==this._additionsHead||null!==this._movesHead||null!==this._removalsHead||null!==this._identityChangesHead}_reset(){if(this.isDirty){let a;for(a=this._previousItHead=this._itHead;null!==a;a=a._next)a._nextPrevious=a._next;for(a=this._additionsHead;null!==a;a=a._nextAdded)a.previousIndex=a.currentIndex;for(this._additionsHead=this._additionsTail=null,a=this._movesHead;null!==a;a=a._nextMoved)a.previousIndex=a.currentIndex;this._movesHead=this._movesTail=null,this._removalsHead=this._removalsTail=null,this._identityChangesHead=this._identityChangesTail=null}}_mismatch(a,c,f,m){let v;return null===a?v=this._itTail:(v=a._prev,this._remove(a)),null!==(a=null===this._unlinkedRecords?null:this._unlinkedRecords.get(f,null))?(Object.is(a.item,c)||this._addIdentityChange(a,c),this._reinsertAfter(a,v,m)):null!==(a=null===this._linkedRecords?null:this._linkedRecords.get(f,m))?(Object.is(a.item,c)||this._addIdentityChange(a,c),this._moveAfter(a,v,m)):a=this._addAfter(new _E(c,f),v,m),a}_verifyReinsertion(a,c,f,m){let v=null===this._unlinkedRecords?null:this._unlinkedRecords.get(f,null);return null!==v?a=this._reinsertAfter(v,a._prev,m):a.currentIndex!=m&&(a.currentIndex=m,this._addToMoves(a,m)),a}_truncate(a){for(;null!==a;){const c=a._next;this._addToRemovals(this._unlink(a)),a=c}null!==this._unlinkedRecords&&this._unlinkedRecords.clear(),null!==this._additionsTail&&(this._additionsTail._nextAdded=null),null!==this._movesTail&&(this._movesTail._nextMoved=null),null!==this._itTail&&(this._itTail._next=null),null!==this._removalsTail&&(this._removalsTail._nextRemoved=null),null!==this._identityChangesTail&&(this._identityChangesTail._nextIdentityChange=null)}_reinsertAfter(a,c,f){null!==this._unlinkedRecords&&this._unlinkedRecords.remove(a);const m=a._prevRemoved,v=a._nextRemoved;return null===m?this._removalsHead=v:m._nextRemoved=v,null===v?this._removalsTail=m:v._prevRemoved=m,this._insertAfter(a,c,f),this._addToMoves(a,f),a}_moveAfter(a,c,f){return this._unlink(a),this._insertAfter(a,c,f),this._addToMoves(a,f),a}_addAfter(a,c,f){return this._insertAfter(a,c,f),this._additionsTail=null===this._additionsTail?this._additionsHead=a:this._additionsTail._nextAdded=a,a}_insertAfter(a,c,f){const m=null===c?this._itHead:c._next;return a._next=m,a._prev=c,null===m?this._itTail=a:m._prev=a,null===c?this._itHead=a:c._next=a,null===this._linkedRecords&&(this._linkedRecords=new bh),this._linkedRecords.put(a),a.currentIndex=f,a}_remove(a){return this._addToRemovals(this._unlink(a))}_unlink(a){null!==this._linkedRecords&&this._linkedRecords.remove(a);const c=a._prev,f=a._next;return null===c?this._itHead=f:c._next=f,null===f?this._itTail=c:f._prev=c,a}_addToMoves(a,c){return a.previousIndex===c||(this._movesTail=null===this._movesTail?this._movesHead=a:this._movesTail._nextMoved=a),a}_addToRemovals(a){return null===this._unlinkedRecords&&(this._unlinkedRecords=new bh),this._unlinkedRecords.put(a),a.currentIndex=null,a._nextRemoved=null,null===this._removalsTail?(this._removalsTail=this._removalsHead=a,a._prevRemoved=null):(a._prevRemoved=this._removalsTail,this._removalsTail=this._removalsTail._nextRemoved=a),a}_addIdentityChange(a,c){return a.item=c,this._identityChangesTail=null===this._identityChangesTail?this._identityChangesHead=a:this._identityChangesTail._nextIdentityChange=a,a}}class _E{constructor(a,c){this.item=a,this.trackById=c,this.currentIndex=null,this.previousIndex=null,this._nextPrevious=null,this._prev=null,this._next=null,this._prevDup=null,this._nextDup=null,this._prevRemoved=null,this._nextRemoved=null,this._nextAdded=null,this._nextMoved=null,this._nextIdentityChange=null}}class lT{constructor(){this._head=null,this._tail=null}add(a){null===this._head?(this._head=this._tail=a,a._nextDup=null,a._prevDup=null):(this._tail._nextDup=a,a._prevDup=this._tail,a._nextDup=null,this._tail=a)}get(a,c){let f;for(f=this._head;null!==f;f=f._nextDup)if((null===c||c<=f.currentIndex)&&Object.is(f.trackById,a))return f;return null}remove(a){const c=a._prevDup,f=a._nextDup;return null===c?this._head=f:c._nextDup=f,null===f?this._tail=c:f._prevDup=c,null===this._head}}class bh{constructor(){this.map=new Map}put(a){const c=a.trackById;let f=this.map.get(c);f||(f=new lT,this.map.set(c,f)),f.add(a)}get(a,c){const m=this.map.get(a);return m?m.get(a,c):null}remove(a){const c=a.trackById;return this.map.get(c).remove(a)&&this.map.delete(c),a}get isEmpty(){return 0===this.map.size}clear(){this.map.clear()}}function xE(i,a,c){const f=i.previousIndex;if(null===f)return f;let m=0;return c&&f<c.length&&(m=c[f]),f+a+m}class wE{constructor(){}supports(a){return a instanceof Map||rg(a)}create(){return new td}}class td{constructor(){this._records=new Map,this._mapHead=null,this._appendAfter=null,this._previousMapHead=null,this._changesHead=null,this._changesTail=null,this._additionsHead=null,this._additionsTail=null,this._removalsHead=null,this._removalsTail=null}get isDirty(){return null!==this._additionsHead||null!==this._changesHead||null!==this._removalsHead}forEachItem(a){let c;for(c=this._mapHead;null!==c;c=c._next)a(c)}forEachPreviousItem(a){let c;for(c=this._previousMapHead;null!==c;c=c._nextPrevious)a(c)}forEachChangedItem(a){let c;for(c=this._changesHead;null!==c;c=c._nextChanged)a(c)}forEachAddedItem(a){let c;for(c=this._additionsHead;null!==c;c=c._nextAdded)a(c)}forEachRemovedItem(a){let c;for(c=this._removalsHead;null!==c;c=c._nextRemoved)a(c)}diff(a){if(a){if(!(a instanceof Map||rg(a)))throw new Xe(900,!1)}else a=new Map;return this.check(a)?this:null}onDestroy(){}check(a){this._reset();let c=this._mapHead;if(this._appendAfter=null,this._forEach(a,(f,m)=>{if(c&&c.key===m)this._maybeAddToChanges(c,f),this._appendAfter=c,c=c._next;else{const v=this._getOrCreateRecordForKey(m,f);c=this._insertBeforeOrAppend(c,v)}}),c){c._prev&&(c._prev._next=null),this._removalsHead=c;for(let f=c;null!==f;f=f._nextRemoved)f===this._mapHead&&(this._mapHead=null),this._records.delete(f.key),f._nextRemoved=f._next,f.previousValue=f.currentValue,f.currentValue=null,f._prev=null,f._next=null}return this._changesTail&&(this._changesTail._nextChanged=null),this._additionsTail&&(this._additionsTail._nextAdded=null),this.isDirty}_insertBeforeOrAppend(a,c){if(a){const f=a._prev;return c._next=a,c._prev=f,a._prev=c,f&&(f._next=c),a===this._mapHead&&(this._mapHead=c),this._appendAfter=a,a}return this._appendAfter?(this._appendAfter._next=c,c._prev=this._appendAfter):this._mapHead=c,this._appendAfter=c,null}_getOrCreateRecordForKey(a,c){if(this._records.has(a)){const m=this._records.get(a);this._maybeAddToChanges(m,c);const v=m._prev,w=m._next;return v&&(v._next=w),w&&(w._prev=v),m._next=null,m._prev=null,m}const f=new CE(a);return this._records.set(a,f),f.currentValue=c,this._addToAdditions(f),f}_reset(){if(this.isDirty){let a;for(this._previousMapHead=this._mapHead,a=this._previousMapHead;null!==a;a=a._next)a._nextPrevious=a._next;for(a=this._changesHead;null!==a;a=a._nextChanged)a.previousValue=a.currentValue;for(a=this._additionsHead;null!=a;a=a._nextAdded)a.previousValue=a.currentValue;this._changesHead=this._changesTail=null,this._additionsHead=this._additionsTail=null,this._removalsHead=null}}_maybeAddToChanges(a,c){Object.is(c,a.currentValue)||(a.previousValue=a.currentValue,a.currentValue=c,this._addToChanges(a))}_addToAdditions(a){null===this._additionsHead?this._additionsHead=this._additionsTail=a:(this._additionsTail._nextAdded=a,this._additionsTail=a)}_addToChanges(a){null===this._changesHead?this._changesHead=this._changesTail=a:(this._changesTail._nextChanged=a,this._changesTail=a)}_forEach(a,c){a instanceof Map?a.forEach(c):Object.keys(a).forEach(f=>c(a[f],f))}}class CE{constructor(a){this.key=a,this.previousValue=null,this.currentValue=null,this._nextPrevious=null,this._next=null,this._prev=null,this._nextAdded=null,this._nextRemoved=null,this._nextChanged=null}}function mp(){return new At([new eo])}let At=(()=>{class i{constructor(c){this.factories=c}static create(c,f){if(null!=f){const m=f.factories.slice();c=c.concat(m)}return new i(c)}static extend(c){return{provide:i,useFactory:f=>i.create(c,f||mp()),deps:[[i,new is,new gu]]}}find(c){const f=this.factories.find(m=>m.supports(c));if(null!=f)return f;throw new Xe(901,!1)}}return i.\u0275prov=Bt({token:i,providedIn:"root",factory:mp}),i})();function q_(){return new Iy([new wE])}let Iy=(()=>{class i{constructor(c){this.factories=c}static create(c,f){if(f){const m=f.factories.slice();c=c.concat(m)}return new i(c)}static extend(c){return{provide:i,useFactory:f=>i.create(c,f||q_()),deps:[[i,new is,new gu]]}}find(c){const f=this.factories.find(m=>m.supports(c));if(f)return f;throw new Xe(901,!1)}}return i.\u0275prov=Bt({token:i,providedIn:"root",factory:q_}),i})();const IE=jl(null,"core",[]);let DE=(()=>{class i{constructor(c){}}return i.\u0275fac=function(c){return new(c||i)(br(wy))},i.\u0275mod=Gs({type:i}),i.\u0275inj=cn({}),i})();function X_(i){return"boolean"==typeof i?i:null!=i&&"false"!==i}},2313:(Lt,ot,Y)=>{"use strict";Y.d(ot,{Dx:()=>Tt,b2:()=>wr,q6:()=>In,se:()=>dt});var P=Y(9808),ae=Y(1223);class Oe extends P.w_{constructor(){super(...arguments),this.supportsDOMEvents=!0}}class ve extends Oe{static makeCurrent(){(0,P.HT)(new ve)}onAndCancel(ge,ne,Re){return ge.addEventListener(ne,Re,!1),()=>{ge.removeEventListener(ne,Re,!1)}}dispatchEvent(ge,ne){ge.dispatchEvent(ne)}remove(ge){ge.parentNode&&ge.parentNode.removeChild(ge)}createElement(ge,ne){return(ne=ne||this.getDefaultDocument()).createElement(ge)}createHtmlDocument(){return document.implementation.createHTMLDocument("fakeTitle")}getDefaultDocument(){return document}isElementNode(ge){return ge.nodeType===Node.ELEMENT_NODE}isShadowRoot(ge){return ge instanceof DocumentFragment}getGlobalEventTarget(ge,ne){return"window"===ne?window:"document"===ne?ge:"body"===ne?ge.body:null}getBaseHref(ge){const ne=function Fe(){return Le=Le||document.querySelector("base"),Le?Le.getAttribute("href"):null}();return null==ne?null:function nt(Q){ct=ct||document.createElement("a"),ct.setAttribute("href",Q);const ge=ct.pathname;return"/"===ge.charAt(0)?ge:`/${ge}`}(ne)}resetBaseElement(){Le=null}getUserAgent(){return window.navigator.userAgent}getCookie(ge){return(0,P.Mx)(document.cookie,ge)}}let ct,Le=null;const he=new ae.OlP("TRANSITION_ID"),we=[{provide:ae.ip1,useFactory:function Ie(Q,ge,ne){return()=>{ne.get(ae.CZH).donePromise.then(()=>{const Re=(0,P.q)(),Je=ge.querySelectorAll(`style[ng-transition="${Q}"]`);for(let Qt=0;Qt<Je.length;Qt++)Re.remove(Je[Qt])})}},deps:[he,P.K0,ae.zs3],multi:!0}];let Ge=(()=>{class Q{build(){return new XMLHttpRequest}}return Q.\u0275fac=function(ne){return new(ne||Q)},Q.\u0275prov=ae.Yz7({token:Q,factory:Q.\u0275fac}),Q})();const $e=new ae.OlP("EventManagerPlugins");let ut=(()=>{class Q{constructor(ne,Re){this._zone=Re,this._eventNameToPlugin=new Map,ne.forEach(Je=>Je.manager=this),this._plugins=ne.slice().reverse()}addEventListener(ne,Re,Je){return this._findPluginFor(Re).addEventListener(ne,Re,Je)}addGlobalEventListener(ne,Re,Je){return this._findPluginFor(Re).addGlobalEventListener(ne,Re,Je)}getZone(){return this._zone}_findPluginFor(ne){const Re=this._eventNameToPlugin.get(ne);if(Re)return Re;const Je=this._plugins;for(let Qt=0;Qt<Je.length;Qt++){const nn=Je[Qt];if(nn.supports(ne))return this._eventNameToPlugin.set(ne,nn),nn}throw new Error(`No event manager plugin found for event ${ne}`)}}return Q.\u0275fac=function(ne){return new(ne||Q)(ae.LFG($e),ae.LFG(ae.R0b))},Q.\u0275prov=ae.Yz7({token:Q,factory:Q.\u0275fac}),Q})();class vt{constructor(ge){this._doc=ge}addGlobalEventListener(ge,ne,Re){const Je=(0,P.q)().getGlobalEventTarget(this._doc,ge);if(!Je)throw new Error(`Unsupported event target ${Je} for event ${ne}`);return this.addEventListener(Je,ne,Re)}}let bt=(()=>{class Q{constructor(){this._stylesSet=new Set}addStyles(ne){const Re=new Set;ne.forEach(Je=>{this._stylesSet.has(Je)||(this._stylesSet.add(Je),Re.add(Je))}),this.onStylesAdded(Re)}onStylesAdded(ne){}getAllStyles(){return Array.from(this._stylesSet)}}return Q.\u0275fac=function(ne){return new(ne||Q)},Q.\u0275prov=ae.Yz7({token:Q,factory:Q.\u0275fac}),Q})(),Jt=(()=>{class Q extends bt{constructor(ne){super(),this._doc=ne,this._hostNodes=new Map,this._hostNodes.set(ne.head,[])}_addStylesToHost(ne,Re,Je){ne.forEach(Qt=>{const nn=this._doc.createElement("style");nn.textContent=Qt,Je.push(Re.appendChild(nn))})}addHost(ne){const Re=[];this._addStylesToHost(this._stylesSet,ne,Re),this._hostNodes.set(ne,Re)}removeHost(ne){const Re=this._hostNodes.get(ne);Re&&Re.forEach(Cn),this._hostNodes.delete(ne)}onStylesAdded(ne){this._hostNodes.forEach((Re,Je)=>{this._addStylesToHost(ne,Je,Re)})}ngOnDestroy(){this._hostNodes.forEach(ne=>ne.forEach(Cn))}}return Q.\u0275fac=function(ne){return new(ne||Q)(ae.LFG(P.K0))},Q.\u0275prov=ae.Yz7({token:Q,factory:Q.\u0275fac}),Q})();function Cn(Q){(0,P.q)().remove(Q)}const Dt={svg:"http://www.w3.org/2000/svg",xhtml:"http://www.w3.org/1999/xhtml",xlink:"http://www.w3.org/1999/xlink",xml:"http://www.w3.org/XML/1998/namespace",xmlns:"http://www.w3.org/2000/xmlns/",math:"http://www.w3.org/1998/MathML/"},at=/%COMP%/g;function K(Q,ge,ne){for(let Re=0;Re<ge.length;Re++){let Je=ge[Re];Array.isArray(Je)?K(Q,Je,ne):(Je=Je.replace(at,Q),ne.push(Je))}return ne}function _t(Q){return ge=>{if("__ngUnwrap__"===ge)return Q;!1===Q(ge)&&(ge.preventDefault(),ge.returnValue=!1)}}let dt=(()=>{class Q{constructor(ne,Re,Je){this.eventManager=ne,this.sharedStylesHost=Re,this.appId=Je,this.rendererByCompId=new Map,this.defaultRenderer=new qe(ne)}createRenderer(ne,Re){if(!ne||!Re)return this.defaultRenderer;switch(Re.encapsulation){case ae.ifc.Emulated:{let Je=this.rendererByCompId.get(Re.id);return Je||(Je=new ce(this.eventManager,this.sharedStylesHost,Re,this.appId),this.rendererByCompId.set(Re.id,Je)),Je.applyToHost(ne),Je}case 1:case ae.ifc.ShadowDom:return new ue(this.eventManager,this.sharedStylesHost,ne,Re);default:if(!this.rendererByCompId.has(Re.id)){const Je=K(Re.id,Re.styles,[]);this.sharedStylesHost.addStyles(Je),this.rendererByCompId.set(Re.id,this.defaultRenderer)}return this.defaultRenderer}}begin(){}end(){}}return Q.\u0275fac=function(ne){return new(ne||Q)(ae.LFG(ut),ae.LFG(Jt),ae.LFG(ae.AFp))},Q.\u0275prov=ae.Yz7({token:Q,factory:Q.\u0275fac}),Q})();class qe{constructor(ge){this.eventManager=ge,this.data=Object.create(null),this.destroyNode=null}destroy(){}createElement(ge,ne){return ne?document.createElementNS(Dt[ne]||ne,ge):document.createElement(ge)}createComment(ge){return document.createComment(ge)}createText(ge){return document.createTextNode(ge)}appendChild(ge,ne){(ht(ge)?ge.content:ge).appendChild(ne)}insertBefore(ge,ne,Re){ge&&(ht(ge)?ge.content:ge).insertBefore(ne,Re)}removeChild(ge,ne){ge&&ge.removeChild(ne)}selectRootElement(ge,ne){let Re="string"==typeof ge?document.querySelector(ge):ge;if(!Re)throw new Error(`The selector "${ge}" did not match any elements`);return ne||(Re.textContent=""),Re}parentNode(ge){return ge.parentNode}nextSibling(ge){return ge.nextSibling}setAttribute(ge,ne,Re,Je){if(Je){ne=Je+":"+ne;const Qt=Dt[Je];Qt?ge.setAttributeNS(Qt,ne,Re):ge.setAttribute(ne,Re)}else ge.setAttribute(ne,Re)}removeAttribute(ge,ne,Re){if(Re){const Je=Dt[Re];Je?ge.removeAttributeNS(Je,ne):ge.removeAttribute(`${Re}:${ne}`)}else ge.removeAttribute(ne)}addClass(ge,ne){ge.classList.add(ne)}removeClass(ge,ne){ge.classList.remove(ne)}setStyle(ge,ne,Re,Je){Je&(ae.JOm.DashCase|ae.JOm.Important)?ge.style.setProperty(ne,Re,Je&ae.JOm.Important?"important":""):ge.style[ne]=Re}removeStyle(ge,ne,Re){Re&ae.JOm.DashCase?ge.style.removeProperty(ne):ge.style[ne]=""}setProperty(ge,ne,Re){ge[ne]=Re}setValue(ge,ne){ge.nodeValue=ne}listen(ge,ne,Re){return"string"==typeof ge?this.eventManager.addGlobalEventListener(ge,ne,_t(Re)):this.eventManager.addEventListener(ge,ne,_t(Re))}}function ht(Q){return"TEMPLATE"===Q.tagName&&void 0!==Q.content}class ce extends qe{constructor(ge,ne,Re,Je){super(ge),this.component=Re;const Qt=K(Je+"-"+Re.id,Re.styles,[]);ne.addStyles(Qt),this.contentAttr=function X(Q){return"_ngcontent-%COMP%".replace(at,Q)}(Je+"-"+Re.id),this.hostAttr=function ze(Q){return"_nghost-%COMP%".replace(at,Q)}(Je+"-"+Re.id)}applyToHost(ge){super.setAttribute(ge,this.hostAttr,"")}createElement(ge,ne){const Re=super.createElement(ge,ne);return super.setAttribute(Re,this.contentAttr,""),Re}}class ue extends qe{constructor(ge,ne,Re,Je){super(ge),this.sharedStylesHost=ne,this.hostEl=Re,this.shadowRoot=Re.attachShadow({mode:"open"}),this.sharedStylesHost.addHost(this.shadowRoot);const Qt=K(Je.id,Je.styles,[]);for(let nn=0;nn<Qt.length;nn++){const Wn=document.createElement("style");Wn.textContent=Qt[nn],this.shadowRoot.appendChild(Wn)}}nodeOrShadowRoot(ge){return ge===this.hostEl?this.shadowRoot:ge}destroy(){this.sharedStylesHost.removeHost(this.shadowRoot)}appendChild(ge,ne){return super.appendChild(this.nodeOrShadowRoot(ge),ne)}insertBefore(ge,ne,Re){return super.insertBefore(this.nodeOrShadowRoot(ge),ne,Re)}removeChild(ge,ne){return super.removeChild(this.nodeOrShadowRoot(ge),ne)}parentNode(ge){return this.nodeOrShadowRoot(super.parentNode(this.nodeOrShadowRoot(ge)))}}let me=(()=>{class Q extends vt{constructor(ne){super(ne)}supports(ne){return!0}addEventListener(ne,Re,Je){return ne.addEventListener(Re,Je,!1),()=>this.removeEventListener(ne,Re,Je)}removeEventListener(ne,Re,Je){return ne.removeEventListener(Re,Je)}}return Q.\u0275fac=function(ne){return new(ne||Q)(ae.LFG(P.K0))},Q.\u0275prov=ae.Yz7({token:Q,factory:Q.\u0275fac}),Q})();const Ae=["alt","control","meta","shift"],Te={"\b":"Backspace","\t":"Tab","\x7f":"Delete","\x1b":"Escape",Del:"Delete",Esc:"Escape",Left:"ArrowLeft",Right:"ArrowRight",Up:"ArrowUp",Down:"ArrowDown",Menu:"ContextMenu",Scroll:"ScrollLock",Win:"OS"},Ve={alt:Q=>Q.altKey,control:Q=>Q.ctrlKey,meta:Q=>Q.metaKey,shift:Q=>Q.shiftKey};let xt=(()=>{class Q extends vt{constructor(ne){super(ne)}supports(ne){return null!=Q.parseEventName(ne)}addEventListener(ne,Re,Je){const Qt=Q.parseEventName(Re),nn=Q.eventCallback(Qt.fullKey,Je,this.manager.getZone());return this.manager.getZone().runOutsideAngular(()=>(0,P.q)().onAndCancel(ne,Qt.domEventName,nn))}static parseEventName(ne){const Re=ne.toLowerCase().split("."),Je=Re.shift();if(0===Re.length||"keydown"!==Je&&"keyup"!==Je)return null;const Qt=Q._normalizeKey(Re.pop());let nn="",Wn=Re.indexOf("code");if(Wn>-1&&(Re.splice(Wn,1),nn="code."),Ae.forEach(As=>{const Rs=Re.indexOf(As);Rs>-1&&(Re.splice(Rs,1),nn+=As+".")}),nn+=Qt,0!=Re.length||0===Qt.length)return null;const lr={};return lr.domEventName=Je,lr.fullKey=nn,lr}static matchEventFullKeyCode(ne,Re){let Je=Te[ne.key]||ne.key,Qt="";return Re.indexOf("code.")>-1&&(Je=ne.code,Qt="code."),!(null==Je||!Je)&&(Je=Je.toLowerCase()," "===Je?Je="space":"."===Je&&(Je="dot"),Ae.forEach(nn=>{nn!==Je&&(0,Ve[nn])(ne)&&(Qt+=nn+".")}),Qt+=Je,Qt===Re)}static eventCallback(ne,Re,Je){return Qt=>{Q.matchEventFullKeyCode(Qt,ne)&&Je.runGuarded(()=>Re(Qt))}}static _normalizeKey(ne){return"esc"===ne?"escape":ne}}return Q.\u0275fac=function(ne){return new(ne||Q)(ae.LFG(P.K0))},Q.\u0275prov=ae.Yz7({token:Q,factory:Q.\u0275fac}),Q})();const In=(0,ae.eFA)(ae._c5,"browser",[{provide:ae.Lbi,useValue:P.bD},{provide:ae.g9A,useValue:function bn(){ve.makeCurrent()},multi:!0},{provide:P.K0,useFactory:function Ee(){return(0,ae.RDi)(document),document},deps:[]}]),un=new ae.OlP(""),kn=[{provide:ae.rWj,useClass:class _e{addToWindow(ge){ae.dqk.getAngularTestability=(Re,Je=!0)=>{const Qt=ge.findTestabilityInTree(Re,Je);if(null==Qt)throw new Error("Could not find testability for element.");return Qt},ae.dqk.getAllAngularTestabilities=()=>ge.getAllTestabilities(),ae.dqk.getAllAngularRootElements=()=>ge.getAllRootElements(),ae.dqk.frameworkStabilizers||(ae.dqk.frameworkStabilizers=[]),ae.dqk.frameworkStabilizers.push(Re=>{const Je=ae.dqk.getAllAngularTestabilities();let Qt=Je.length,nn=!1;const Wn=function(lr){nn=nn||lr,Qt--,0==Qt&&Re(nn)};Je.forEach(function(lr){lr.whenStable(Wn)})})}findTestabilityInTree(ge,ne,Re){if(null==ne)return null;const Je=ge.getTestability(ne);return null!=Je?Je:Re?(0,P.q)().isShadowRoot(ne)?this.findTestabilityInTree(ge,ne.host,!0):this.findTestabilityInTree(ge,ne.parentElement,!0):null}},deps:[]},{provide:ae.lri,useClass:ae.dDg,deps:[ae.R0b,ae.eoX,ae.rWj]},{provide:ae.dDg,useClass:ae.dDg,deps:[ae.R0b,ae.eoX,ae.rWj]}],Fr=[{provide:ae.zSh,useValue:"root"},{provide:ae.qLn,useFactory:function Bt(){return new ae.qLn},deps:[]},{provide:$e,useClass:me,multi:!0,deps:[P.K0,ae.R0b,ae.Lbi]},{provide:$e,useClass:xt,multi:!0,deps:[P.K0]},{provide:dt,useClass:dt,deps:[ut,Jt,ae.AFp]},{provide:ae.FYo,useExisting:dt},{provide:bt,useExisting:Jt},{provide:Jt,useClass:Jt,deps:[P.K0]},{provide:ut,useClass:ut,deps:[$e,ae.R0b]},{provide:P.JF,useClass:Ge,deps:[]},[]];let wr=(()=>{class Q{constructor(ne){}static withServerTransition(ne){return{ngModule:Q,providers:[{provide:ae.AFp,useValue:ne.appId},{provide:he,useExisting:ae.AFp},we]}}}return Q.\u0275fac=function(ne){return new(ne||Q)(ae.LFG(un,12))},Q.\u0275mod=ae.oAB({type:Q}),Q.\u0275inj=ae.cJS({providers:[...Fr,...kn],imports:[P.ez,ae.hGG]}),Q})(),Tt=(()=>{class Q{constructor(ne){this._doc=ne}getTitle(){return this._doc.title}setTitle(ne){this._doc.title=ne||""}}return Q.\u0275fac=function(ne){return new(ne||Q)(ae.LFG(P.K0))},Q.\u0275prov=ae.Yz7({token:Q,factory:function(ne){let Re=null;return Re=ne?new ne:function Dr(){return new Tt((0,ae.LFG)(P.K0))}(),Re},providedIn:"root"}),Q})();"undefined"!=typeof window&&window},6210:(Lt,ot,Y)=>{"use strict";Y.d(ot,{F0:()=>Ar,Bz:()=>bc});var P=Y(1223),ae=Y(2076),Oe=Y(7669);function ve(...C){const E=(0,Oe.yG)(C);return(0,ae.D)(C,E)}var Le=Y(7579);class Fe extends Le.x{constructor(E){super(),this._value=E}get value(){return this.getValue()}_subscribe(E){const x=super._subscribe(E);return!x.closed&&E.next(this._value),x}getValue(){const{hasError:E,thrownError:x,_value:N}=this;if(E)throw x;return this._throwIfClosed(),N}next(E){super.next(this._value=E)}}const nt=(0,Y(3888).d)(C=>function(){C(this),this.name="EmptyError",this.message="no elements in sequence"});var he=Y(9751);const{isArray:Ie}=Array,{getPrototypeOf:we,prototype:_e,keys:Ge}=Object;var vt=Y(4671),bt=Y(4004);const{isArray:Jt}=Array;var Ze=Y(5403),Xe=Y(9672);function Ue(...C){const E=(0,Oe.yG)(C),x=(0,Oe.jO)(C),{args:N,keys:F}=function $e(C){if(1===C.length){const E=C[0];if(Ie(E))return{args:E,keys:null};if(function ut(C){return C&&"object"==typeof C&&we(C)===_e}(E)){const x=Ge(E);return{args:x.map(N=>E[N]),keys:x}}}return{args:C,keys:null}}(C);if(0===N.length)return(0,ae.D)([],E);const z=new he.y(function ie(C,E,x=vt.y){return N=>{X(E,()=>{const{length:F}=C,z=new Array(F);let ee=F,re=F;for(let ye=0;ye<F;ye++)X(E,()=>{const lt=(0,ae.D)(C[ye],E);let $t=!1;lt.subscribe((0,Ze.x)(N,Ct=>{z[ye]=Ct,$t||($t=!0,re--),re||N.next(x(z.slice()))},()=>{--ee||N.complete()}))},N)},N)}}(N,E,F?ee=>function at(C,E){return C.reduce((x,N,F)=>(x[N]=E[F],x),{})}(F,ee):vt.y));return x?z.pipe(function Dt(C){return(0,bt.U)(E=>function Cn(C,E){return Jt(E)?C(...E):C(E)}(C,E))}(x)):z}function X(C,E,x){C?(0,Xe.f)(x,C,E):E()}var ze=Y(8189);function _t(...C){return function K(){return(0,ze.J)(1)}()((0,ae.D)(C,(0,Oe.yG)(C)))}var Ot=Y(8421);function dt(C){return new he.y(E=>{(0,Ot.Xf)(C()).subscribe(E)})}var qe=Y(9635),xe=Y(576);function et(C,E){const x=(0,xe.m)(C)?C:()=>C,N=F=>F.error(x());return new he.y(E?F=>E.schedule(N,0,F):N)}var ht=Y(515),ce=Y(727),ue=Y(4482);function me(){return(0,ue.e)((C,E)=>{let x=null;C._refCount++;const N=(0,Ze.x)(E,void 0,void 0,void 0,()=>{if(!C||C._refCount<=0||0<--C._refCount)return void(x=null);const F=C._connection,z=x;x=null,F&&(!z||F===z)&&F.unsubscribe(),E.unsubscribe()});C.subscribe(N),N.closed||(x=C.connect())})}class Ae extends he.y{constructor(E,x){super(),this.source=E,this.subjectFactory=x,this._subject=null,this._refCount=0,this._connection=null,(0,ue.A)(E)&&(this.lift=E.lift)}_subscribe(E){return this.getSubject().subscribe(E)}getSubject(){const E=this._subject;return(!E||E.isStopped)&&(this._subject=this.subjectFactory()),this._subject}_teardown(){this._refCount=0;const{_connection:E}=this;this._subject=this._connection=null,null==E||E.unsubscribe()}connect(){let E=this._connection;if(!E){E=this._connection=new ce.w0;const x=this.getSubject();E.add(this.source.subscribe((0,Ze.x)(x,void 0,()=>{this._teardown(),x.complete()},N=>{this._teardown(),x.error(N)},()=>this._teardown()))),E.closed&&(this._connection=null,E=ce.w0.EMPTY)}return E}refCount(){return me()(this)}}var Te=Y(9808);function Ve(C,E){return(0,ue.e)((x,N)=>{let F=null,z=0,ee=!1;const re=()=>ee&&!F&&N.complete();x.subscribe((0,Ze.x)(N,ye=>{null==F||F.unsubscribe();let lt=0;const $t=z++;(0,Ot.Xf)(C(ye,$t)).subscribe(F=(0,Ze.x)(N,Ct=>N.next(E?E(ye,Ct,$t,lt++):Ct),()=>{F=null,re()}))},()=>{ee=!0,re()}))})}function xt(C){return C<=0?()=>ht.E:(0,ue.e)((E,x)=>{let N=0;E.subscribe((0,Ze.x)(x,F=>{++N<=C&&(x.next(F),C<=N&&x.complete())}))})}function qt(C,E){return(0,ue.e)((x,N)=>{let F=0;x.subscribe((0,Ze.x)(N,z=>C.call(E,z,F++)&&N.next(z)))})}var it=Y(5577);function ln(C){return(0,ue.e)((E,x)=>{let N=!1;E.subscribe((0,Ze.x)(x,F=>{N=!0,x.next(F)},()=>{N||x.next(C),x.complete()}))})}function G(C=bn){return(0,ue.e)((E,x)=>{let N=!1;E.subscribe((0,Ze.x)(x,F=>{N=!0,x.next(F)},()=>N?x.complete():x.error(C())))})}function bn(){return new nt}function Bt(C,E){const x=arguments.length>=2;return N=>N.pipe(C?qt((F,z)=>C(F,z,N)):vt.y,xt(1),x?ln(E):G(()=>new nt))}function Ee(C,E){return(0,xe.m)(E)?(0,it.z)(C,E,1):(0,it.z)(C,1)}function cn(C,E,x){const N=(0,xe.m)(C)||E||x?{next:C,error:E,complete:x}:C;return N?(0,ue.e)((F,z)=>{var ee;null===(ee=N.subscribe)||void 0===ee||ee.call(N);let re=!0;F.subscribe((0,Ze.x)(z,ye=>{var lt;null===(lt=N.next)||void 0===lt||lt.call(N,ye),z.next(ye)},()=>{var ye;re=!1,null===(ye=N.complete)||void 0===ye||ye.call(N),z.complete()},ye=>{var lt;re=!1,null===(lt=N.error)||void 0===lt||lt.call(N,ye),z.error(ye)},()=>{var ye,lt;re&&(null===(ye=N.unsubscribe)||void 0===ye||ye.call(N)),null===(lt=N.finalize)||void 0===lt||lt.call(N)}))}):vt.y}function In(C){return(0,ue.e)((E,x)=>{let z,N=null,F=!1;N=E.subscribe((0,Ze.x)(x,void 0,void 0,ee=>{z=(0,Ot.Xf)(C(ee,In(C)(E))),N?(N.unsubscribe(),N=null,z.subscribe(x)):F=!0})),F&&(N.unsubscribe(),N=null,z.subscribe(x))})}function un(C,E,x,N,F){return(z,ee)=>{let re=x,ye=E,lt=0;z.subscribe((0,Ze.x)(ee,$t=>{const Ct=lt++;ye=re?C(ye,$t,Ct):(re=!0,$t),N&&ee.next(ye)},F&&(()=>{re&&ee.next(ye),ee.complete()})))}}function kn(C,E){return(0,ue.e)(un(C,E,arguments.length>=2,!0))}function Fr(C){return C<=0?()=>ht.E:(0,ue.e)((E,x)=>{let N=[];E.subscribe((0,Ze.x)(x,F=>{N.push(F),C<N.length&&N.shift()},()=>{for(const F of N)x.next(F);x.complete()},void 0,()=>{N=null}))})}function wr(C,E){const x=arguments.length>=2;return N=>N.pipe(C?qt((F,z)=>C(F,z,N)):vt.y,Fr(1),x?ln(E):G(()=>new nt))}function $r(C){return(0,ue.e)((E,x)=>{try{E.subscribe(x)}finally{x.add(C)}})}var Dr=Y(2313);const Tt="primary",St=Symbol("RouteTitle");class Rt{constructor(E){this.params=E||{}}has(E){return Object.prototype.hasOwnProperty.call(this.params,E)}get(E){if(this.has(E)){const x=this.params[E];return Array.isArray(x)?x[0]:x}return null}getAll(E){if(this.has(E)){const x=this.params[E];return Array.isArray(x)?x:[x]}return[]}get keys(){return Object.keys(this.params)}}function Ft(C){return new Rt(C)}function Kn(C,E,x){const N=x.path.split("/");if(N.length>C.length||"full"===x.pathMatch&&(E.hasChildren()||N.length<C.length))return null;const F={};for(let z=0;z<N.length;z++){const ee=N[z],re=C[z];if(ee.startsWith(":"))F[ee.substring(1)]=re;else if(ee!==re.path)return null}return{consumed:C.slice(0,N.length),posParams:F}}function An(C,E){const x=C?Object.keys(C):void 0,N=E?Object.keys(E):void 0;if(!x||!N||x.length!=N.length)return!1;let F;for(let z=0;z<x.length;z++)if(F=x[z],!Cr(C[F],E[F]))return!1;return!0}function Cr(C,E){if(Array.isArray(C)&&Array.isArray(E)){if(C.length!==E.length)return!1;const x=[...C].sort(),N=[...E].sort();return x.every((F,z)=>N[z]===F)}return C===E}function qn(C){return Array.prototype.concat.apply([],C)}function bo(C){return C.length>0?C[C.length-1]:null}function zn(C,E){for(const x in C)C.hasOwnProperty(x)&&E(C[x],x)}function Zt(C){return(0,P.CqO)(C)?C:(0,P.QGY)(C)?(0,ae.D)(Promise.resolve(C)):ve(C)}const Wt={exact:function _o(C,E,x){if(!Gs(C.segments,E.segments)||!Qr(C.segments,E.segments,x)||C.numberOfChildren!==E.numberOfChildren)return!1;for(const N in E.children)if(!C.children[N]||!_o(C.children[N],E.children[N],x))return!1;return!0},subset:ds},Sn={exact:function ya(C,E){return An(C,E)},subset:function er(C,E){return Object.keys(E).length<=Object.keys(C).length&&Object.keys(E).every(x=>Cr(C[x],E[x]))},ignored:()=>!0};function Pr(C,E,x){return Wt[x.paths](C.root,E.root,x.matrixParams)&&Sn[x.queryParams](C.queryParams,E.queryParams)&&!("exact"===x.fragment&&C.fragment!==E.fragment)}function ds(C,E,x){return Sr(C,E,E.segments,x)}function Sr(C,E,x,N){if(C.segments.length>x.length){const F=C.segments.slice(0,x.length);return!(!Gs(F,x)||E.hasChildren()||!Qr(F,x,N))}if(C.segments.length===x.length){if(!Gs(C.segments,x)||!Qr(C.segments,x,N))return!1;for(const F in E.children)if(!C.children[F]||!ds(C.children[F],E.children[F],N))return!1;return!0}{const F=x.slice(0,C.segments.length),z=x.slice(C.segments.length);return!!(Gs(C.segments,F)&&Qr(C.segments,F,N)&&C.children[Tt])&&Sr(C.children[Tt],E,z,N)}}function Qr(C,E,x){return E.every((N,F)=>Sn[x](C[F].parameters,N.parameters))}class Jr{constructor(E,x,N){this.root=E,this.queryParams=x,this.fragment=N}get queryParamMap(){return this._queryParamMap||(this._queryParamMap=Ft(this.queryParams)),this._queryParamMap}toString(){return ge.serialize(this)}}class dn{constructor(E,x){this.segments=E,this.children=x,this.parent=null,zn(x,(N,F)=>N.parent=this)}hasChildren(){return this.numberOfChildren>0}get numberOfChildren(){return Object.keys(this.children).length}toString(){return ne(this)}}class Uo{constructor(E,x){this.path=E,this.parameters=x}get parameterMap(){return this._parameterMap||(this._parameterMap=Ft(this.parameters)),this._parameterMap}toString(){return Rs(this)}}function Gs(C,E){return C.length===E.length&&C.every((x,N)=>x.path===E[N].path)}let va=(()=>{class C{}return C.\u0275fac=function(x){return new(x||C)},C.\u0275prov=P.Yz7({token:C,factory:function(){return new Q},providedIn:"root"}),C})();class Q{parse(E){const x=new xo(E);return new Jr(x.parseRootSegment(),x.parseQueryParams(),x.parseFragment())}serialize(E){const x=`/${Re(E.root,!0)}`,N=function Tr(C){const E=Object.keys(C).map(x=>{const N=C[x];return Array.isArray(N)?N.map(F=>`${Qt(x)}=${Qt(F)}`).join("&"):`${Qt(x)}=${Qt(N)}`}).filter(x=>!!x);return E.length?`?${E.join("&")}`:""}(E.queryParams);return`${x}${N}${"string"==typeof E.fragment?`#${function nn(C){return encodeURI(C)}(E.fragment)}`:""}`}}const ge=new Q;function ne(C){return C.segments.map(E=>Rs(E)).join("/")}function Re(C,E){if(!C.hasChildren())return ne(C);if(E){const x=C.children[Tt]?Re(C.children[Tt],!1):"",N=[];return zn(C.children,(F,z)=>{z!==Tt&&N.push(`${z}:${Re(F,!1)}`)}),N.length>0?`${x}(${N.join("//")})`:x}{const x=function Jl(C,E){let x=[];return zn(C.children,(N,F)=>{F===Tt&&(x=x.concat(E(N,F)))}),zn(C.children,(N,F)=>{F!==Tt&&(x=x.concat(E(N,F)))}),x}(C,(N,F)=>F===Tt?[Re(C.children[Tt],!1)]:[`${F}:${Re(N,!1)}`]);return 1===Object.keys(C.children).length&&null!=C.children[Tt]?`${ne(C)}/${x[0]}`:`${ne(C)}/(${x.join("//")})`}}function Je(C){return encodeURIComponent(C).replace(/%40/g,"@").replace(/%3A/gi,":").replace(/%24/g,"$").replace(/%2C/gi,",")}function Qt(C){return Je(C).replace(/%3B/gi,";")}function Wn(C){return Je(C).replace(/\(/g,"%28").replace(/\)/g,"%29").replace(/%26/gi,"&")}function lr(C){return decodeURIComponent(C)}function As(C){return lr(C.replace(/\+/g,"%20"))}function Rs(C){return`${Wn(C.path)}${function Ks(C){return Object.keys(C).map(E=>`;${Wn(E)}=${Wn(C[E])}`).join("")}(C.parameters)}`}const ec=/^[^\/()?;=#]+/;function Lr(C){const E=C.match(ec);return E?E[0]:""}const kt=/^[^=?&#]+/,Bn=/^[^&#]+/;class xo{constructor(E){this.url=E,this.remaining=E}parseRootSegment(){return this.consumeOptional("/"),""===this.remaining||this.peekStartsWith("?")||this.peekStartsWith("#")?new dn([],{}):new dn([],this.parseChildren())}parseQueryParams(){const E={};if(this.consumeOptional("?"))do{this.parseQueryParam(E)}while(this.consumeOptional("&"));return E}parseFragment(){return this.consumeOptional("#")?decodeURIComponent(this.remaining):null}parseChildren(){if(""===this.remaining)return{};this.consumeOptional("/");const E=[];for(this.peekStartsWith("(")||E.push(this.parseSegment());this.peekStartsWith("/")&&!this.peekStartsWith("//")&&!this.peekStartsWith("/(");)this.capture("/"),E.push(this.parseSegment());let x={};this.peekStartsWith("/(")&&(this.capture("/"),x=this.parseParens(!0));let N={};return this.peekStartsWith("(")&&(N=this.parseParens(!1)),(E.length>0||Object.keys(x).length>0)&&(N[Tt]=new dn(E,x)),N}parseSegment(){const E=Lr(this.remaining);if(""===E&&this.peekStartsWith(";"))throw new P.vHH(4009,!1);return this.capture(E),new Uo(lr(E),this.parseMatrixParams())}parseMatrixParams(){const E={};for(;this.consumeOptional(";");)this.parseParam(E);return E}parseParam(E){const x=Lr(this.remaining);if(!x)return;this.capture(x);let N="";if(this.consumeOptional("=")){const F=Lr(this.remaining);F&&(N=F,this.capture(N))}E[lr(x)]=lr(N)}parseQueryParam(E){const x=function an(C){const E=C.match(kt);return E?E[0]:""}(this.remaining);if(!x)return;this.capture(x);let N="";if(this.consumeOptional("=")){const ee=function Wr(C){const E=C.match(Bn);return E?E[0]:""}(this.remaining);ee&&(N=ee,this.capture(N))}const F=As(x),z=As(N);if(E.hasOwnProperty(F)){let ee=E[F];Array.isArray(ee)||(ee=[ee],E[F]=ee),ee.push(z)}else E[F]=z}parseParens(E){const x={};for(this.capture("(");!this.consumeOptional(")")&&this.remaining.length>0;){const N=Lr(this.remaining),F=this.remaining[N.length];if("/"!==F&&")"!==F&&";"!==F)throw new P.vHH(4010,!1);let z;N.indexOf(":")>-1?(z=N.slice(0,N.indexOf(":")),this.capture(z),this.capture(":")):E&&(z=Tt);const ee=this.parseChildren();x[z]=1===Object.keys(ee).length?ee[Tt]:new dn([],ee),this.consumeOptional("//")}return x}peekStartsWith(E){return this.remaining.startsWith(E)}consumeOptional(E){return!!this.peekStartsWith(E)&&(this.remaining=this.remaining.substring(E.length),!0)}capture(E){if(!this.consumeOptional(E))throw new P.vHH(4011,!1)}}function tr(C){return C.segments.length>0?new dn([],{[Tt]:C}):C}function Ms(C){const E={};for(const N of Object.keys(C.children)){const z=Ms(C.children[N]);(z.segments.length>0||z.hasChildren())&&(E[N]=z)}return function nr(C){if(1===C.numberOfChildren&&C.children[Tt]){const E=C.children[Tt];return new dn(C.segments.concat(E.segments),E.children)}return C}(new dn(C.segments,E))}function hs(C){return C instanceof Jr}function $i(C,E,x,N,F){var z;if(0===x.length)return fs(E.root,E.root,E.root,N,F);const re=function So(C){if("string"==typeof C[0]&&1===C.length&&"/"===C[0])return new Br(!0,0,C);let E=0,x=!1;const N=C.reduce((F,z,ee)=>{if("object"==typeof z&&null!=z){if(z.outlets){const re={};return zn(z.outlets,(ye,lt)=>{re[lt]="string"==typeof ye?ye.split("/"):ye}),[...F,{outlets:re}]}if(z.segmentPath)return[...F,z.segmentPath]}return"string"!=typeof z?[...F,z]:0===ee?(z.split("/").forEach((re,ye)=>{0==ye&&"."===re||(0==ye&&""===re?x=!0:".."===re?E++:""!=re&&F.push(re))}),F):[...F,z]},[]);return new Br(x,E,N)}(x);return re.toRoot()?fs(E.root,E.root,new dn([],{}),N,F):function ye($t){var Ct;const jt=function sl(C,E,x,N){if(C.isAbsolute)return new Eo(E.root,!0,0);if(-1===N)return new Eo(x,x===E.root,0);return function ol(C,E,x){let N=C,F=E,z=x;for(;z>F;){if(z-=F,N=N.parent,!N)throw new P.vHH(4005,!1);F=N.segments.length}return new Eo(N,!1,F-z)}(x,N+(ro(C.commands[0])?0:1),C.numberOfDoubleDots)}(re,E,null===(Ct=C.snapshot)||void 0===Ct?void 0:Ct._urlSegment,$t),Mn=jt.processChildren?hi(jt.segmentGroup,jt.index,re.commands):es(jt.segmentGroup,jt.index,re.commands);return fs(E.root,jt.segmentGroup,Mn,N,F)}(null===(z=C.snapshot)||void 0===z?void 0:z._lastPathIndex)}function ro(C){return"object"==typeof C&&null!=C&&!C.outlets&&!C.segmentPath}function cr(C){return"object"==typeof C&&null!=C&&C.outlets}function fs(C,E,x,N,F){let ee,z={};N&&zn(N,(ye,lt)=>{z[lt]=Array.isArray(ye)?ye.map($t=>`${$t}`):`${ye}`}),ee=C===E?x:Os(C,E,x);const re=tr(Ms(ee));return new Jr(re,z,F)}function Os(C,E,x){const N={};return zn(C.children,(F,z)=>{N[z]=F===E?x:Os(F,E,x)}),new dn(C.segments,N)}class Br{constructor(E,x,N){if(this.isAbsolute=E,this.numberOfDoubleDots=x,this.commands=N,E&&N.length>0&&ro(N[0]))throw new P.vHH(4003,!1);const F=N.find(cr);if(F&&F!==bo(N))throw new P.vHH(4004,!1)}toRoot(){return this.isAbsolute&&1===this.commands.length&&"/"==this.commands[0]}}class Eo{constructor(E,x,N){this.segmentGroup=E,this.processChildren=x,this.index=N}}function es(C,E,x){if(C||(C=new dn([],{})),0===C.segments.length&&C.hasChildren())return hi(C,E,x);const N=function Gr(C,E,x){let N=0,F=E;const z={match:!1,pathIndex:0,commandIndex:0};for(;F<C.segments.length;){if(N>=x.length)return z;const ee=C.segments[F],re=x[N];if(cr(re))break;const ye=`${re}`,lt=N<x.length-1?x[N+1]:null;if(F>0&&void 0===ye)break;if(ye&&lt&&"object"==typeof lt&&void 0===lt.outlets){if(!tc(ye,lt,ee))return z;N+=2}else{if(!tc(ye,{},ee))return z;N++}F++}return{match:!0,pathIndex:F,commandIndex:N}}(C,E,x),F=x.slice(N.commandIndex);if(N.match&&N.pathIndex<C.segments.length){const z=new dn(C.segments.slice(0,N.pathIndex),{});return z.children[Tt]=new dn(C.segments.slice(N.pathIndex),C.children),hi(z,0,F)}return N.match&&0===F.length?new dn(C.segments,{}):N.match&&!C.hasChildren()?Io(C,E,x):N.match?hi(C,0,F):Io(C,E,x)}function hi(C,E,x){if(0===x.length)return new dn(C.segments,{});{const N=function jr(C){return cr(C[0])?C[0].outlets:{[Tt]:C}}(x),F={};return zn(N,(z,ee)=>{"string"==typeof z&&(z=[z]),null!==z&&(F[ee]=es(C.children[ee],E,z))}),zn(C.children,(z,ee)=>{void 0===N[ee]&&(F[ee]=z)}),new dn(C.segments,F)}}function Io(C,E,x){const N=C.segments.slice(0,E);let F=0;for(;F<x.length;){const z=x[F];if(cr(z)){const ye=ps(z.outlets);return new dn(N,ye)}if(0===F&&ro(x[0])){N.push(new Uo(C.segments[E].path,il(x[0]))),F++;continue}const ee=cr(z)?z.outlets[Tt]:`${z}`,re=F<x.length-1?x[F+1]:null;ee&&re&&ro(re)?(N.push(new Uo(ee,il(re))),F+=2):(N.push(new Uo(ee,{})),F++)}return new dn(N,{})}function ps(C){const E={};return zn(C,(x,N)=>{"string"==typeof x&&(x=[x]),null!==x&&(E[N]=Io(new dn([],{}),0,x))}),E}function il(C){const E={};return zn(C,(x,N)=>E[N]=`${x}`),E}function tc(C,E,x){return C==x.path&&An(E,x.parameters)}class qs{constructor(E,x){this.id=E,this.url=x}}class ba extends qs{constructor(E,x,N="imperative",F=null){super(E,x),this.type=0,this.navigationTrigger=N,this.restoredState=F}toString(){return`NavigationStart(id: ${this.id}, url: '${this.url}')`}}class zo extends qs{constructor(E,x,N){super(E,x),this.urlAfterRedirects=N,this.type=1}toString(){return`NavigationEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}')`}}class _a extends qs{constructor(E,x,N,F){super(E,x),this.reason=N,this.code=F,this.type=2}toString(){return`NavigationCancel(id: ${this.id}, url: '${this.url}')`}}class nc extends qs{constructor(E,x,N,F){super(E,x),this.error=N,this.target=F,this.type=3}toString(){return`NavigationError(id: ${this.id}, url: '${this.url}', error: ${this.error})`}}class Xc extends qs{constructor(E,x,N,F){super(E,x),this.urlAfterRedirects=N,this.state=F,this.type=4}toString(){return`RoutesRecognized(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}}class Yc extends qs{constructor(E,x,N,F){super(E,x),this.urlAfterRedirects=N,this.state=F,this.type=7}toString(){return`GuardsCheckStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}}class Zc extends qs{constructor(E,x,N,F,z){super(E,x),this.urlAfterRedirects=N,this.state=F,this.shouldActivate=z,this.type=8}toString(){return`GuardsCheckEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state}, shouldActivate: ${this.shouldActivate})`}}class fd extends qs{constructor(E,x,N,F){super(E,x),this.urlAfterRedirects=N,this.state=F,this.type=5}toString(){return`ResolveStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}}class pd extends qs{constructor(E,x,N,F){super(E,x),this.urlAfterRedirects=N,this.state=F,this.type=6}toString(){return`ResolveEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}}class Qc{constructor(E){this.route=E,this.type=9}toString(){return`RouteConfigLoadStart(path: ${this.route.path})`}}class rc{constructor(E){this.route=E,this.type=10}toString(){return`RouteConfigLoadEnd(path: ${this.route.path})`}}class Jc{constructor(E){this.snapshot=E,this.type=11}toString(){return`ChildActivationStart(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}}class al{constructor(E){this.snapshot=E,this.type=12}toString(){return`ChildActivationEnd(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}}class md{constructor(E){this.snapshot=E,this.type=13}toString(){return`ActivationStart(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}}class sc{constructor(E){this.snapshot=E,this.type=14}toString(){return`ActivationEnd(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}}class Pi{constructor(E,x,N){this.routerEvent=E,this.position=x,this.anchor=N,this.type=15}toString(){return`Scroll(anchor: '${this.anchor}', position: '${this.position?`${this.position[0]}, ${this.position[1]}`:null}')`}}class xa{constructor(E){this._root=E}get root(){return this._root.value}parent(E){const x=this.pathFromRoot(E);return x.length>1?x[x.length-2]:null}children(E){const x=wa(E,this._root);return x?x.children.map(N=>N.value):[]}firstChild(E){const x=wa(E,this._root);return x&&x.children.length>0?x.children[0].value:null}siblings(E){const x=oc(E,this._root);return x.length<2?[]:x[x.length-2].children.map(F=>F.value).filter(F=>F!==E)}pathFromRoot(E){return oc(E,this._root).map(x=>x.value)}}function wa(C,E){if(C===E.value)return E;for(const x of E.children){const N=wa(C,x);if(N)return N}return null}function oc(C,E){if(C===E.value)return[E];for(const x of E.children){const N=oc(C,x);if(N.length)return N.unshift(E),N}return[]}class Vr{constructor(E,x){this.value=E,this.children=x}toString(){return`TreeNode(${this.value})`}}function Do(C){const E={};return C&&C.children.forEach(x=>E[x.value.outlet]=x),E}class fi extends xa{constructor(E,x){super(E),this.snapshot=x,Ca(this,E)}toString(){return this.snapshot.toString()}}function Li(C,E){const x=function ic(C,E){const ee=new Bi([],{},{},"",{},Tt,E,null,C.root,-1,{});return new Vi("",new Vr(ee,[]))}(C,E),N=new Fe([new Uo("",{})]),F=new Fe({}),z=new Fe({}),ee=new Fe({}),re=new Fe(""),ye=new To(N,F,ee,re,z,Tt,E,x.root);return ye.snapshot=x.root,new fi(new Vr(ye,[]),x)}class To{constructor(E,x,N,F,z,ee,re,ye){var lt,$t;this.url=E,this.params=x,this.queryParams=N,this.fragment=F,this.data=z,this.outlet=ee,this.component=re,this.title=null!==($t=null===(lt=this.data)||void 0===lt?void 0:lt.pipe((0,bt.U)(Ct=>Ct[St])))&&void 0!==$t?$t:ve(void 0),this._futureSnapshot=ye}get routeConfig(){return this._futureSnapshot.routeConfig}get root(){return this._routerState.root}get parent(){return this._routerState.parent(this)}get firstChild(){return this._routerState.firstChild(this)}get children(){return this._routerState.children(this)}get pathFromRoot(){return this._routerState.pathFromRoot(this)}get paramMap(){return this._paramMap||(this._paramMap=this.params.pipe((0,bt.U)(E=>Ft(E)))),this._paramMap}get queryParamMap(){return this._queryParamMap||(this._queryParamMap=this.queryParams.pipe((0,bt.U)(E=>Ft(E)))),this._queryParamMap}toString(){return this.snapshot?this.snapshot.toString():`Future(${this._futureSnapshot})`}}function ll(C,E="emptyOnly"){const x=C.pathFromRoot;let N=0;if("always"!==E)for(N=x.length-1;N>=1;){const F=x[N],z=x[N-1];if(F.routeConfig&&""===F.routeConfig.path)N--;else{if(z.component)break;N--}}return function cl(C){return C.reduce((E,x)=>{var N;return{params:Object.assign(Object.assign({},E.params),x.params),data:Object.assign(Object.assign({},E.data),x.data),resolve:Object.assign(Object.assign(Object.assign(Object.assign({},x.data),E.resolve),null===(N=x.routeConfig)||void 0===N?void 0:N.data),x._resolvedData)}},{params:{},data:{},resolve:{}})}(x.slice(N))}class Bi{constructor(E,x,N,F,z,ee,re,ye,lt,$t,Ct,jt){var Mn;this.url=E,this.params=x,this.queryParams=N,this.fragment=F,this.data=z,this.outlet=ee,this.component=re,this.title=null===(Mn=this.data)||void 0===Mn?void 0:Mn[St],this.routeConfig=ye,this._urlSegment=lt,this._lastPathIndex=$t,this._correctedLastPathIndex=null!=jt?jt:$t,this._resolve=Ct}get root(){return this._routerState.root}get parent(){return this._routerState.parent(this)}get firstChild(){return this._routerState.firstChild(this)}get children(){return this._routerState.children(this)}get pathFromRoot(){return this._routerState.pathFromRoot(this)}get paramMap(){return this._paramMap||(this._paramMap=Ft(this.params)),this._paramMap}get queryParamMap(){return this._queryParamMap||(this._queryParamMap=Ft(this.queryParams)),this._queryParamMap}toString(){return`Route(url:'${this.url.map(N=>N.toString()).join("/")}', path:'${this.routeConfig?this.routeConfig.path:""}')`}}class Vi extends xa{constructor(E,x){super(x),this.url=E,Ca(this,x)}toString(){return ts(this._root)}}function Ca(C,E){E.value._routerState=C,E.children.forEach(x=>Ca(C,x))}function ts(C){const E=C.children.length>0?` { ${C.children.map(ts).join(", ")} } `:"";return`${C.value}${E}`}function No(C){if(C.snapshot){const E=C.snapshot,x=C._futureSnapshot;C.snapshot=x,An(E.queryParams,x.queryParams)||C.queryParams.next(x.queryParams),E.fragment!==x.fragment&&C.fragment.next(x.fragment),An(E.params,x.params)||C.params.next(x.params),function no(C,E){if(C.length!==E.length)return!1;for(let x=0;x<C.length;++x)if(!An(C[x],E[x]))return!1;return!0}(E.url,x.url)||C.url.next(x.url),An(E.data,x.data)||C.data.next(x.data)}else C.snapshot=C._futureSnapshot,C.data.next(C._futureSnapshot.data)}function Ui(C,E){const x=An(C.params,E.params)&&function Ql(C,E){return Gs(C,E)&&C.every((x,N)=>An(x.parameters,E[N].parameters))}(C.url,E.url);return x&&!(!C.parent!=!E.parent)&&(!C.parent||Ui(C.parent,E.parent))}function pi(C,E,x){if(x&&C.shouldReuseRoute(E.value,x.value.snapshot)){const N=x.value;N._futureSnapshot=E.value;const F=function eu(C,E,x){return E.children.map(N=>{for(const F of x.children)if(C.shouldReuseRoute(N.value,F.value.snapshot))return pi(C,N,F);return pi(C,N)})}(C,E,x);return new Vr(N,F)}{if(C.shouldAttach(E.value)){const z=C.retrieve(E.value);if(null!==z){const ee=z.route;return ee.value._futureSnapshot=E.value,ee.children=E.children.map(re=>pi(C,re)),ee}}const N=function jn(C){return new To(new Fe(C.url),new Fe(C.params),new Fe(C.queryParams),new Fe(C.fragment),new Fe(C.data),C.outlet,C.component,C)}(E.value),F=E.children.map(z=>pi(C,z));return new Vr(N,F)}}const ul="ngNavigationCancelingError";function dl(C,E){const{redirectTo:x,navigationBehaviorOptions:N}=hs(E)?{redirectTo:E,navigationBehaviorOptions:void 0}:E,F=Wo(!1,0,E);return F.url=x,F.navigationBehaviorOptions=N,F}function Wo(C,E,x){const N=new Error("NavigationCancelingError: "+(C||""));return N[ul]=!0,N.cancellationCode=E,x&&(N.url=x),N}function Ur(C){return jo(C)&&hs(C.url)}function jo(C){return C&&C[ul]}class zi{constructor(){this.outlet=null,this.route=null,this.resolver=null,this.injector=null,this.children=new Fs,this.attachRef=null}}let Fs=(()=>{class C{constructor(){this.contexts=new Map}onChildOutletCreated(x,N){const F=this.getOrCreateContext(x);F.outlet=N,this.contexts.set(x,F)}onChildOutletDestroyed(x){const N=this.getContext(x);N&&(N.outlet=null,N.attachRef=null)}onOutletDeactivated(){const x=this.contexts;return this.contexts=new Map,x}onOutletReAttached(x){this.contexts=x}getOrCreateContext(x){let N=this.getContext(x);return N||(N=new zi,this.contexts.set(x,N)),N}getContext(x){return this.contexts.get(x)||null}}return C.\u0275fac=function(x){return new(x||C)},C.\u0275prov=P.Yz7({token:C,factory:C.\u0275fac,providedIn:"root"}),C})();const ns=!1;let gd=(()=>{class C{constructor(x,N,F,z,ee){this.parentContexts=x,this.location=N,this.changeDetector=z,this.environmentInjector=ee,this.activated=null,this._activatedRoute=null,this.activateEvents=new P.vpe,this.deactivateEvents=new P.vpe,this.attachEvents=new P.vpe,this.detachEvents=new P.vpe,this.name=F||Tt,x.onChildOutletCreated(this.name,this)}ngOnDestroy(){var x;(null===(x=this.parentContexts.getContext(this.name))||void 0===x?void 0:x.outlet)===this&&this.parentContexts.onChildOutletDestroyed(this.name)}ngOnInit(){if(!this.activated){const x=this.parentContexts.getContext(this.name);x&&x.route&&(x.attachRef?this.attach(x.attachRef,x.route):this.activateWith(x.route,x.injector))}}get isActivated(){return!!this.activated}get component(){if(!this.activated)throw new P.vHH(4012,ns);return this.activated.instance}get activatedRoute(){if(!this.activated)throw new P.vHH(4012,ns);return this._activatedRoute}get activatedRouteData(){return this._activatedRoute?this._activatedRoute.snapshot.data:{}}detach(){if(!this.activated)throw new P.vHH(4012,ns);this.location.detach();const x=this.activated;return this.activated=null,this._activatedRoute=null,this.detachEvents.emit(x.instance),x}attach(x,N){this.activated=x,this._activatedRoute=N,this.location.insert(x.hostView),this.attachEvents.emit(x.instance)}deactivate(){if(this.activated){const x=this.component;this.activated.destroy(),this.activated=null,this._activatedRoute=null,this.deactivateEvents.emit(x)}}activateWith(x,N){if(this.isActivated)throw new P.vHH(4013,ns);this._activatedRoute=x;const F=this.location,ee=x._futureSnapshot.component,re=this.parentContexts.getOrCreateContext(this.name).children,ye=new Ea(x,re,F.injector);if(N&&function tu(C){return!!C.resolveComponentFactory}(N)){const lt=N.resolveComponentFactory(ee);this.activated=F.createComponent(lt,F.length,ye)}else this.activated=F.createComponent(ee,{index:F.length,injector:ye,environmentInjector:null!=N?N:this.environmentInjector});this.changeDetector.markForCheck(),this.activateEvents.emit(this.activated.instance)}}return C.\u0275fac=function(x){return new(x||C)(P.Y36(Fs),P.Y36(P.s_b),P.$8M("name"),P.Y36(P.sBO),P.Y36(P.lqb))},C.\u0275dir=P.lG2({type:C,selectors:[["router-outlet"]],outputs:{activateEvents:"activate",deactivateEvents:"deactivate",attachEvents:"attach",detachEvents:"detach"},exportAs:["outlet"],standalone:!0}),C})();class Ea{constructor(E,x,N){this.route=E,this.childContexts=x,this.parent=N}get(E,x){return E===To?this.route:E===Fs?this.childContexts:this.parent.get(E,x)}}let ko=(()=>{class C{}return C.\u0275fac=function(x){return new(x||C)},C.\u0275cmp=P.Xpm({type:C,selectors:[["ng-component"]],standalone:!0,features:[P.jDz],decls:1,vars:0,template:function(x,N){1&x&&P._UZ(0,"router-outlet")},dependencies:[gd],encapsulation:2}),C})();function Ia(C,E){var x;return C.providers&&!C._injector&&(C._injector=(0,P.MMx)(C.providers,E,`Route: ${C.path}`)),null!==(x=C._injector)&&void 0!==x?x:E}function Hi(C){const E=C.children&&C.children.map(Hi),x=E?Object.assign(Object.assign({},C),{children:E}):Object.assign({},C);return!x.component&&!x.loadComponent&&(E||x.loadChildren)&&x.outlet&&x.outlet!==Tt&&(x.component=ko),x}function ms(C){return C.outlet||Tt}function st(C,E){const x=C.filter(N=>ms(N)===E);return x.push(...C.filter(N=>ms(N)!==E)),x}function _n(C){var E;if(!C)return null;if(null!==(E=C.routeConfig)&&void 0!==E&&E._injector)return C.routeConfig._injector;for(let x=C.parent;x;x=x.parent){const N=x.routeConfig;if(null!=N&&N._loadedInjector)return N._loadedInjector;if(null!=N&&N._injector)return N._injector}return null}class rr{constructor(E,x,N,F){this.routeReuseStrategy=E,this.futureState=x,this.currState=N,this.forwardEvent=F}activate(E){const x=this.futureState._root,N=this.currState?this.currState._root:null;this.deactivateChildRoutes(x,N,E),No(this.futureState.root),this.activateChildRoutes(x,N,E)}deactivateChildRoutes(E,x,N){const F=Do(x);E.children.forEach(z=>{const ee=z.value.outlet;this.deactivateRoutes(z,F[ee],N),delete F[ee]}),zn(F,(z,ee)=>{this.deactivateRouteAndItsChildren(z,N)})}deactivateRoutes(E,x,N){const F=E.value,z=x?x.value:null;if(F===z)if(F.component){const ee=N.getContext(F.outlet);ee&&this.deactivateChildRoutes(E,x,ee.children)}else this.deactivateChildRoutes(E,x,N);else z&&this.deactivateRouteAndItsChildren(x,N)}deactivateRouteAndItsChildren(E,x){E.value.component&&this.routeReuseStrategy.shouldDetach(E.value.snapshot)?this.detachAndStoreRouteSubtree(E,x):this.deactivateRouteAndOutlet(E,x)}detachAndStoreRouteSubtree(E,x){const N=x.getContext(E.value.outlet),F=N&&E.value.component?N.children:x,z=Do(E);for(const ee of Object.keys(z))this.deactivateRouteAndItsChildren(z[ee],F);if(N&&N.outlet){const ee=N.outlet.detach(),re=N.children.onOutletDeactivated();this.routeReuseStrategy.store(E.value.snapshot,{componentRef:ee,route:E,contexts:re})}}deactivateRouteAndOutlet(E,x){const N=x.getContext(E.value.outlet),F=N&&E.value.component?N.children:x,z=Do(E);for(const ee of Object.keys(z))this.deactivateRouteAndItsChildren(z[ee],F);N&&N.outlet&&(N.outlet.deactivate(),N.children.onOutletDeactivated(),N.attachRef=null,N.resolver=null,N.route=null)}activateChildRoutes(E,x,N){const F=Do(x);E.children.forEach(z=>{this.activateRoutes(z,F[z.value.outlet],N),this.forwardEvent(new sc(z.value.snapshot))}),E.children.length&&this.forwardEvent(new al(E.value.snapshot))}activateRoutes(E,x,N){var F;const z=E.value,ee=x?x.value:null;if(No(z),z===ee)if(z.component){const re=N.getOrCreateContext(z.outlet);this.activateChildRoutes(E,x,re.children)}else this.activateChildRoutes(E,x,N);else if(z.component){const re=N.getOrCreateContext(z.outlet);if(this.routeReuseStrategy.shouldAttach(z.snapshot)){const ye=this.routeReuseStrategy.retrieve(z.snapshot);this.routeReuseStrategy.store(z.snapshot,null),re.children.onOutletReAttached(ye.contexts),re.attachRef=ye.componentRef,re.route=ye.route.value,re.outlet&&re.outlet.attach(ye.componentRef,ye.route.value),No(ye.route.value),this.activateChildRoutes(E,null,re.children)}else{const ye=_n(z.snapshot),lt=null!==(F=null==ye?void 0:ye.get(P._Vd))&&void 0!==F?F:null;re.attachRef=null,re.route=z,re.resolver=lt,re.injector=ye,re.outlet&&re.outlet.activateWith(z,re.injector),this.activateChildRoutes(E,null,re.children)}}else this.activateChildRoutes(E,null,N)}}class ur{constructor(E){this.path=E,this.route=this.path[this.path.length-1]}}class Wi{constructor(E,x){this.component=E,this.route=x}}function ji(C,E,x){const N=C._root;return Go(N,E?E._root:null,x,[N.value])}function Ao(C,E){const x=Symbol(),N=E.get(C,x);return N===x?"function"!=typeof C||(0,P.Z0I)(C)?E.get(C):C:N}function Go(C,E,x,N,F={canDeactivateChecks:[],canActivateChecks:[]}){const z=Do(E);return C.children.forEach(ee=>{(function su(C,E,x,N,F={canDeactivateChecks:[],canActivateChecks:[]}){const z=C.value,ee=E?E.value:null,re=x?x.getContext(C.value.outlet):null;if(ee&&z.routeConfig===ee.routeConfig){const ye=function ou(C,E,x){if("function"==typeof x)return x(C,E);switch(x){case"pathParamsChange":return!Gs(C.url,E.url);case"pathParamsOrQueryParamsChange":return!Gs(C.url,E.url)||!An(C.queryParams,E.queryParams);case"always":return!0;case"paramsOrQueryParamsChange":return!Ui(C,E)||!An(C.queryParams,E.queryParams);default:return!Ui(C,E)}}(ee,z,z.routeConfig.runGuardsAndResolvers);ye?F.canActivateChecks.push(new ur(N)):(z.data=ee.data,z._resolvedData=ee._resolvedData),Go(C,E,z.component?re?re.children:null:x,N,F),ye&&re&&re.outlet&&re.outlet.isActivated&&F.canDeactivateChecks.push(new Wi(re.outlet.component,ee))}else ee&&iu(E,re,F),F.canActivateChecks.push(new ur(N)),Go(C,null,z.component?re?re.children:null:x,N,F)})(ee,z[ee.value.outlet],x,N.concat([ee.value]),F),delete z[ee.value.outlet]}),zn(z,(ee,re)=>iu(ee,x.getContext(re),F)),F}function iu(C,E,x){const N=Do(C),F=C.value;zn(N,(z,ee)=>{iu(z,F.component?E?E.children.getContext(ee):null:E,x)}),x.canDeactivateChecks.push(new Wi(F.component&&E&&E.outlet&&E.outlet.isActivated?E.outlet.component:null,F))}function Ko(C){return"function"==typeof C}function mi(C){return C instanceof nt||"EmptyError"===(null==C?void 0:C.name)}const gi=Symbol("INITIAL_VALUE");function Ro(){return Ve(C=>Ue(C.map(E=>E.pipe(xt(1),function Pt(...C){const E=(0,Oe.yG)(C);return(0,ue.e)((x,N)=>{(E?_t(C,x,E):_t(C,x)).subscribe(N)})}(gi)))).pipe((0,bt.U)(E=>{for(const x of E)if(!0!==x){if(x===gi)return gi;if(!1===x||x instanceof Jr)return x}return!0}),qt(E=>E!==gi),xt(1)))}function Na(C){return(0,qe.z)(cn(E=>{if(hs(E))throw dl(0,E)}),(0,bt.U)(E=>!0===E))}const ka={matched:!1,consumedSegments:[],remainingSegments:[],parameters:{},positionalParamSegments:{}};function kr(C,E,x,N,F){const z=$s(C,E,x);return z.matched?function cu(C,E,x,N){const F=E.canMatch;return F&&0!==F.length?ve(F.map(ee=>{const re=Ao(ee,C);return Zt(function au(C){return C&&Ko(C.canMatch)}(re)?re.canMatch(E,x):C.runInContext(()=>re(E,x)))})).pipe(Ro(),Na()):ve(!0)}(N=Ia(E,N),E,x).pipe((0,bt.U)(ee=>!0===ee?z:Object.assign({},ka))):ve(z)}function $s(C,E,x){var N;if(""===E.path)return"full"===E.pathMatch&&(C.hasChildren()||x.length>0)?Object.assign({},ka):{matched:!0,consumedSegments:[],remainingSegments:x,parameters:{},positionalParamSegments:{}};const z=(E.matcher||Kn)(x,C,E);if(!z)return Object.assign({},ka);const ee={};zn(z.posParams,(ye,lt)=>{ee[lt]=ye.path});const re=z.consumed.length>0?Object.assign(Object.assign({},ee),z.consumed[z.consumed.length-1].parameters):ee;return{matched:!0,consumedSegments:z.consumed,remainingSegments:x.slice(z.consumed.length),parameters:re,positionalParamSegments:null!==(N=z.posParams)&&void 0!==N?N:{}}}function Fn(C,E,x,N,F="corrected"){if(x.length>0&&function _l(C,E,x){return x.some(N=>Ra(C,E,N)&&ms(N)!==Tt)}(C,x,N)){const ee=new dn(E,function dc(C,E,x,N){const F={};F[Tt]=N,N._sourceSegment=C,N._segmentIndexShift=E.length;for(const z of x)if(""===z.path&&ms(z)!==Tt){const ee=new dn([],{});ee._sourceSegment=C,ee._segmentIndexShift=E.length,F[ms(z)]=ee}return F}(C,E,N,new dn(x,C.children)));return ee._sourceSegment=C,ee._segmentIndexShift=E.length,{segmentGroup:ee,slicedSegments:[]}}if(0===x.length&&function hc(C,E,x){return x.some(N=>Ra(C,E,N))}(C,x,N)){const ee=new dn(C.segments,function Aa(C,E,x,N,F,z){const ee={};for(const re of N)if(Ra(C,x,re)&&!F[ms(re)]){const ye=new dn([],{});ye._sourceSegment=C,ye._segmentIndexShift="legacy"===z?C.segments.length:E.length,ee[ms(re)]=ye}return Object.assign(Object.assign({},F),ee)}(C,E,x,N,C.children,F));return ee._sourceSegment=C,ee._segmentIndexShift=E.length,{segmentGroup:ee,slicedSegments:x}}const z=new dn(C.segments,C.children);return z._sourceSegment=C,z._segmentIndexShift=E.length,{segmentGroup:z,slicedSegments:x}}function Ra(C,E,x){return(!(C.hasChildren()||E.length>0)||"full"!==x.pathMatch)&&""===x.path}function fc(C,E,x,N){return!!(ms(C)===N||N!==Tt&&Ra(E,x,C))&&("**"===C.path||$s(E,C,x).matched)}function Ki(C,E,x){return 0===E.length&&!C.children[x]}const qo=!1;class Xo{constructor(E){this.segmentGroup=E||null}}class Ma{constructor(E){this.urlTree=E}}function yi(C){return et(new Xo(C))}function k(C){return et(new Ma(C))}class oe{constructor(E,x,N,F,z){this.injector=E,this.configLoader=x,this.urlSerializer=N,this.urlTree=F,this.config=z,this.allowRedirects=!0}apply(){const E=Fn(this.urlTree.root,[],[],this.config).segmentGroup,x=new dn(E.segments,E.children);return this.expandSegmentGroup(this.injector,this.config,x,Tt).pipe((0,bt.U)(z=>this.createUrlTree(Ms(z),this.urlTree.queryParams,this.urlTree.fragment))).pipe(In(z=>{if(z instanceof Ma)return this.allowRedirects=!1,this.match(z.urlTree);throw z instanceof Xo?this.noMatchError(z):z}))}match(E){return this.expandSegmentGroup(this.injector,this.config,E.root,Tt).pipe((0,bt.U)(F=>this.createUrlTree(Ms(F),E.queryParams,E.fragment))).pipe(In(F=>{throw F instanceof Xo?this.noMatchError(F):F}))}noMatchError(E){return new P.vHH(4002,qo)}createUrlTree(E,x,N){const F=tr(E);return new Jr(F,x,N)}expandSegmentGroup(E,x,N,F){return 0===N.segments.length&&N.hasChildren()?this.expandChildren(E,x,N).pipe((0,bt.U)(z=>new dn([],z))):this.expandSegment(E,N,x,N.segments,F,!0)}expandChildren(E,x,N){const F=[];for(const z of Object.keys(N.children))"primary"===z?F.unshift(z):F.push(z);return(0,ae.D)(F).pipe(Ee(z=>{const ee=N.children[z],re=st(x,z);return this.expandSegmentGroup(E,re,ee,z).pipe((0,bt.U)(ye=>({segment:ye,outlet:z})))}),kn((z,ee)=>(z[ee.outlet]=ee.segment,z),{}),wr())}expandSegment(E,x,N,F,z,ee){return(0,ae.D)(N).pipe(Ee(re=>this.expandSegmentAgainstRoute(E,x,N,re,F,z,ee).pipe(In(lt=>{if(lt instanceof Xo)return ve(null);throw lt}))),Bt(re=>!!re),In((re,ye)=>{if(mi(re))return Ki(x,F,z)?ve(new dn([],{})):yi(x);throw re}))}expandSegmentAgainstRoute(E,x,N,F,z,ee,re){return fc(F,x,z,ee)?void 0===F.redirectTo?this.matchSegmentAgainstRoute(E,x,F,z,ee):re&&this.allowRedirects?this.expandSegmentAgainstRouteUsingRedirect(E,x,N,F,z,ee):yi(x):yi(x)}expandSegmentAgainstRouteUsingRedirect(E,x,N,F,z,ee){return"**"===F.path?this.expandWildCardWithParamsAgainstRouteUsingRedirect(E,N,F,ee):this.expandRegularSegmentAgainstRouteUsingRedirect(E,x,N,F,z,ee)}expandWildCardWithParamsAgainstRouteUsingRedirect(E,x,N,F){const z=this.applyRedirectCommands([],N.redirectTo,{});return N.redirectTo.startsWith("/")?k(z):this.lineralizeSegments(N,z).pipe((0,it.z)(ee=>{const re=new dn(ee,{});return this.expandSegment(E,re,x,ee,F,!1)}))}expandRegularSegmentAgainstRouteUsingRedirect(E,x,N,F,z,ee){const{matched:re,consumedSegments:ye,remainingSegments:lt,positionalParamSegments:$t}=$s(x,F,z);if(!re)return yi(x);const Ct=this.applyRedirectCommands(ye,F.redirectTo,$t);return F.redirectTo.startsWith("/")?k(Ct):this.lineralizeSegments(F,Ct).pipe((0,it.z)(jt=>this.expandSegment(E,x,N,jt.concat(lt),ee,!1)))}matchSegmentAgainstRoute(E,x,N,F,z){return"**"===N.path?(E=Ia(N,E),N.loadChildren?(N._loadedRoutes?ve({routes:N._loadedRoutes,injector:N._loadedInjector}):this.configLoader.loadChildren(E,N)).pipe((0,bt.U)(re=>(N._loadedRoutes=re.routes,N._loadedInjector=re.injector,new dn(F,{})))):ve(new dn(F,{}))):kr(x,N,F,E).pipe(Ve(({matched:ee,consumedSegments:re,remainingSegments:ye})=>{var lt;return ee?(E=null!==(lt=N._injector)&&void 0!==lt?lt:E,this.getChildConfig(E,N,F).pipe((0,it.z)(Ct=>{var jt;const Mn=null!==(jt=Ct.injector)&&void 0!==jt?jt:E,ys=Ct.routes,{segmentGroup:Bs,slicedSegments:vs}=Fn(x,re,ye,ys),Vs=new dn(Bs.segments,Bs.children);if(0===vs.length&&Vs.hasChildren())return this.expandChildren(Mn,ys,Vs).pipe((0,bt.U)(zh=>new dn(re,zh)));if(0===ys.length&&0===vs.length)return ve(new dn(re,{}));const Ci=ms(N)===z;return this.expandSegment(Mn,Vs,ys,vs,Ci?Tt:z,!0).pipe((0,bt.U)(ao=>new dn(re.concat(ao.segments),ao.children)))}))):yi(x)}))}getChildConfig(E,x,N){return x.children?ve({routes:x.children,injector:E}):x.loadChildren?void 0!==x._loadedRoutes?ve({routes:x._loadedRoutes,injector:x._loadedInjector}):function uc(C,E,x,N){const F=E.canLoad;return void 0===F||0===F.length?ve(!0):ve(F.map(ee=>{const re=Ao(ee,C);return Zt(function Ys(C){return C&&Ko(C.canLoad)}(re)?re.canLoad(E,x):C.runInContext(()=>re(E,x)))})).pipe(Ro(),Na())}(E,x,N).pipe((0,it.z)(F=>F?this.configLoader.loadChildren(E,x).pipe(cn(z=>{x._loadedRoutes=z.routes,x._loadedInjector=z.injector})):function M(C){return et(Wo(qo,3))}())):ve({routes:[],injector:E})}lineralizeSegments(E,x){let N=[],F=x.root;for(;;){if(N=N.concat(F.segments),0===F.numberOfChildren)return ve(N);if(F.numberOfChildren>1||!F.children[Tt])return et(new P.vHH(4e3,qo));F=F.children[Tt]}}applyRedirectCommands(E,x,N){return this.applyRedirectCreateUrlTree(x,this.urlSerializer.parse(x),E,N)}applyRedirectCreateUrlTree(E,x,N,F){const z=this.createSegmentGroup(E,x.root,N,F);return new Jr(z,this.createQueryParams(x.queryParams,this.urlTree.queryParams),x.fragment)}createQueryParams(E,x){const N={};return zn(E,(F,z)=>{if("string"==typeof F&&F.startsWith(":")){const re=F.substring(1);N[z]=x[re]}else N[z]=F}),N}createSegmentGroup(E,x,N,F){const z=this.createSegments(E,x.segments,N,F);let ee={};return zn(x.children,(re,ye)=>{ee[ye]=this.createSegmentGroup(E,re,N,F)}),new dn(z,ee)}createSegments(E,x,N,F){return x.map(z=>z.path.startsWith(":")?this.findPosParam(E,z,F):this.findOrReturn(z,N))}findPosParam(E,x,N){const F=N[x.path.substring(1)];if(!F)throw new P.vHH(4001,qo);return F}findOrReturn(E,x){let N=0;for(const F of x){if(F.path===E.path)return x.splice(N),F;N++}return E}}class Ht{}class Rn{constructor(E,x,N,F,z,ee,re,ye){this.injector=E,this.rootComponentType=x,this.config=N,this.urlTree=F,this.url=z,this.paramsInheritanceStrategy=ee,this.relativeLinkResolution=re,this.urlSerializer=ye}recognize(){const E=Fn(this.urlTree.root,[],[],this.config.filter(x=>void 0===x.redirectTo),this.relativeLinkResolution).segmentGroup;return this.processSegmentGroup(this.injector,this.config,E,Tt).pipe((0,bt.U)(x=>{if(null===x)return null;const N=new Bi([],Object.freeze({}),Object.freeze(Object.assign({},this.urlTree.queryParams)),this.urlTree.fragment,{},Tt,this.rootComponentType,null,this.urlTree.root,-1,{}),F=new Vr(N,x),z=new Vi(this.url,F);return this.inheritParamsAndData(z._root),z}))}inheritParamsAndData(E){const x=E.value,N=ll(x,this.paramsInheritanceStrategy);x.params=Object.freeze(N.params),x.data=Object.freeze(N.data),E.children.forEach(F=>this.inheritParamsAndData(F))}processSegmentGroup(E,x,N,F){return 0===N.segments.length&&N.hasChildren()?this.processChildren(E,x,N):this.processSegment(E,x,N,N.segments,F)}processChildren(E,x,N){return(0,ae.D)(Object.keys(N.children)).pipe(Ee(F=>{const z=N.children[F],ee=st(x,F);return this.processSegmentGroup(E,ee,z,F)}),kn((F,z)=>F&&z?(F.push(...z),F):null),function us(C,E=!1){return(0,ue.e)((x,N)=>{let F=0;x.subscribe((0,Ze.x)(N,z=>{const ee=C(z,F++);(ee||E)&&N.next(z),!ee&&N.complete()}))})}(F=>null!==F),ln(null),wr(),(0,bt.U)(F=>{if(null===F)return null;const z=or(F);return function yn(C){C.sort((E,x)=>E.value.outlet===Tt?-1:x.value.outlet===Tt?1:E.value.outlet.localeCompare(x.value.outlet))}(z),z}))}processSegment(E,x,N,F,z){return(0,ae.D)(x).pipe(Ee(ee=>{var re;return this.processSegmentAgainstRoute(null!==(re=ee._injector)&&void 0!==re?re:E,ee,N,F,z)}),Bt(ee=>!!ee),In(ee=>{if(mi(ee))return Ki(N,F,z)?ve([]):ve(null);throw ee}))}processSegmentAgainstRoute(E,x,N,F,z){var ee,re;if(x.redirectTo||!fc(x,N,F,z))return ve(null);let ye;if("**"===x.path){const lt=F.length>0?bo(F).parameters:{},$t=ss(N)+F.length;ye=ve({snapshot:new Bi(F,lt,Object.freeze(Object.assign({},this.urlTree.queryParams)),this.urlTree.fragment,Mo(x),ms(x),null!==(re=null!==(ee=x.component)&&void 0!==ee?ee:x._loadedComponent)&&void 0!==re?re:null,x,gs(N),$t,Yo(x),$t),consumedSegments:[],remainingSegments:[]})}else ye=kr(N,x,F,E).pipe((0,bt.U)(({matched:lt,consumedSegments:$t,remainingSegments:Ct,parameters:jt})=>{var Mn,ys;if(!lt)return null;const Bs=ss(N)+$t.length;return{snapshot:new Bi($t,jt,Object.freeze(Object.assign({},this.urlTree.queryParams)),this.urlTree.fragment,Mo(x),ms(x),null!==(ys=null!==(Mn=x.component)&&void 0!==Mn?Mn:x._loadedComponent)&&void 0!==ys?ys:null,x,gs(N),Bs,Yo(x),Bs),consumedSegments:$t,remainingSegments:Ct}}));return ye.pipe(Ve(lt=>{var $t,Ct;if(null===lt)return ve(null);const{snapshot:jt,consumedSegments:Mn,remainingSegments:ys}=lt;E=null!==($t=x._injector)&&void 0!==$t?$t:E;const Bs=null!==(Ct=x._loadedInjector)&&void 0!==Ct?Ct:E,vs=function sr(C){return C.children?C.children:C.loadChildren?C._loadedRoutes:[]}(x),{segmentGroup:Vs,slicedSegments:Ci}=Fn(N,Mn,ys,vs.filter(ao=>void 0===ao.redirectTo),this.relativeLinkResolution);if(0===Ci.length&&Vs.hasChildren())return this.processChildren(Bs,vs,Vs).pipe((0,bt.U)(ao=>null===ao?null:[new Vr(jt,ao)]));if(0===vs.length&&0===Ci.length)return ve([new Vr(jt,[])]);const br=ms(x)===z;return this.processSegment(Bs,vs,Vs,Ci,br?Tt:z).pipe((0,bt.U)(ao=>null===ao?null:[new Vr(jt,ao)]))}))}}function $n(C){const E=C.value.routeConfig;return E&&""===E.path&&void 0===E.redirectTo}function or(C){const E=[],x=new Set;for(const N of C){if(!$n(N)){E.push(N);continue}const F=E.find(z=>N.value.routeConfig===z.value.routeConfig);void 0!==F?(F.children.push(...N.children),x.add(F)):E.push(N)}for(const N of x){const F=or(N.children);E.push(new Vr(N.value,F))}return E.filter(N=>!x.has(N))}function gs(C){let E=C;for(;E._sourceSegment;)E=E._sourceSegment;return E}function ss(C){var E,x;let N=C,F=null!==(E=N._segmentIndexShift)&&void 0!==E?E:0;for(;N._sourceSegment;)N=N._sourceSegment,F+=null!==(x=N._segmentIndexShift)&&void 0!==x?x:0;return F-1}function Mo(C){return C.data||{}}function Yo(C){return C.resolve||{}}function Js(C){return"string"==typeof C.title||null===C.title}function Oa(C){return Ve(E=>{const x=C(E);return x?(0,ae.D)(x).pipe((0,bt.U)(()=>E)):ve(E)})}let vi=(()=>{class C{buildTitle(x){var N;let F,z=x.root;for(;void 0!==z;)F=null!==(N=this.getResolvedTitleForRoute(z))&&void 0!==N?N:F,z=z.children.find(ee=>ee.outlet===Tt);return F}getResolvedTitleForRoute(x){return x.data[St]}}return C.\u0275fac=function(x){return new(x||C)},C.\u0275prov=P.Yz7({token:C,factory:function(){return(0,P.f3M)(qi)},providedIn:"root"}),C})(),qi=(()=>{class C extends vi{constructor(x){super(),this.title=x}updateTitle(x){const N=this.buildTitle(x);void 0!==N&&this.title.setTitle(N)}}return C.\u0275fac=function(x){return new(x||C)(P.LFG(Dr.Dx))},C.\u0275prov=P.Yz7({token:C,factory:C.\u0275fac,providedIn:"root"}),C})();class mc{}class hu extends class bd{shouldDetach(E){return!1}store(E,x){}shouldAttach(E){return!1}retrieve(E){return null}shouldReuseRoute(E,x){return E.routeConfig===x.routeConfig}}{}const fu=new P.OlP("",{providedIn:"root",factory:()=>({})}),Lh=new P.OlP("ROUTES");let Xi=(()=>{class C{constructor(x,N){this.injector=x,this.compiler=N,this.componentLoaders=new WeakMap,this.childrenLoaders=new WeakMap}loadComponent(x){if(this.componentLoaders.get(x))return this.componentLoaders.get(x);if(x._loadedComponent)return ve(x._loadedComponent);this.onLoadStartListener&&this.onLoadStartListener(x);const N=Zt(x.loadComponent()).pipe(cn(z=>{this.onLoadEndListener&&this.onLoadEndListener(x),x._loadedComponent=z}),$r(()=>{this.componentLoaders.delete(x)})),F=new Ae(N,()=>new Le.x).pipe(me());return this.componentLoaders.set(x,F),F}loadChildren(x,N){if(this.childrenLoaders.get(N))return this.childrenLoaders.get(N);if(N._loadedRoutes)return ve({routes:N._loadedRoutes,injector:N._loadedInjector});this.onLoadStartListener&&this.onLoadStartListener(N);const z=this.loadModuleFactoryOrRoutes(N.loadChildren).pipe((0,bt.U)(re=>{this.onLoadEndListener&&this.onLoadEndListener(N);let ye,lt,$t=!1;Array.isArray(re)?lt=re:(ye=re.create(x).injector,lt=qn(ye.get(Lh,[],P.XFs.Self|P.XFs.Optional)));return{routes:lt.map(Hi),injector:ye}}),$r(()=>{this.childrenLoaders.delete(N)})),ee=new Ae(z,()=>new Le.x).pipe(me());return this.childrenLoaders.set(N,ee),ee}loadModuleFactoryOrRoutes(x){return Zt(x()).pipe((0,it.z)(N=>N instanceof P.YKP||Array.isArray(N)?ve(N):(0,ae.D)(this.compiler.compileModuleAsync(N))))}}return C.\u0275fac=function(x){return new(x||C)(P.LFG(P.zs3),P.LFG(P.Sil))},C.\u0275prov=P.Yz7({token:C,factory:C.\u0275fac,providedIn:"root"}),C})();class wl{}class Bh{shouldProcessUrl(E){return!0}extract(E){return E}merge(E,x){return E}}function Yi(C){throw C}function bi(C,E,x){return E.parse("/")}const Vh={paths:"exact",fragment:"ignored",matrixParams:"ignored",queryParams:"exact"},Fa={paths:"subset",fragment:"ignored",matrixParams:"ignored",queryParams:"subset"};function pu(){var C,E;const x=(0,P.f3M)(va),N=(0,P.f3M)(Fs),F=(0,P.f3M)(Te.Ye),z=(0,P.f3M)(P.zs3),ee=(0,P.f3M)(P.Sil),re=null!==(C=(0,P.f3M)(Lh,{optional:!0}))&&void 0!==C?C:[],ye=null!==(E=(0,P.f3M)(fu,{optional:!0}))&&void 0!==E?E:{},lt=(0,P.f3M)(qi),$t=(0,P.f3M)(vi,{optional:!0}),Ct=(0,P.f3M)(wl,{optional:!0}),jt=(0,P.f3M)(mc,{optional:!0}),Mn=new Ar(null,x,N,F,z,ee,qn(re));return Ct&&(Mn.urlHandlingStrategy=Ct),jt&&(Mn.routeReuseStrategy=jt),Mn.titleStrategy=null!=$t?$t:lt,function Kr(C,E){C.errorHandler&&(E.errorHandler=C.errorHandler),C.malformedUriErrorHandler&&(E.malformedUriErrorHandler=C.malformedUriErrorHandler),C.onSameUrlNavigation&&(E.onSameUrlNavigation=C.onSameUrlNavigation),C.paramsInheritanceStrategy&&(E.paramsInheritanceStrategy=C.paramsInheritanceStrategy),C.relativeLinkResolution&&(E.relativeLinkResolution=C.relativeLinkResolution),C.urlUpdateStrategy&&(E.urlUpdateStrategy=C.urlUpdateStrategy),C.canceledNavigationResolution&&(E.canceledNavigationResolution=C.canceledNavigationResolution)}(ye,Mn),Mn}let Ar=(()=>{class C{constructor(x,N,F,z,ee,re,ye){this.rootComponentType=x,this.urlSerializer=N,this.rootContexts=F,this.location=z,this.config=ye,this.lastSuccessfulNavigation=null,this.currentNavigation=null,this.disposed=!1,this.navigationId=0,this.currentPageId=0,this.isNgZoneEnabled=!1,this.events=new Le.x,this.errorHandler=Yi,this.malformedUriErrorHandler=bi,this.navigated=!1,this.lastSuccessfulId=-1,this.afterPreactivation=()=>ve(void 0),this.urlHandlingStrategy=new Bh,this.routeReuseStrategy=new hu,this.onSameUrlNavigation="ignore",this.paramsInheritanceStrategy="emptyOnly",this.urlUpdateStrategy="deferred",this.relativeLinkResolution="corrected",this.canceledNavigationResolution="replace",this.configLoader=ee.get(Xi),this.configLoader.onLoadEndListener=jt=>this.triggerEvent(new rc(jt)),this.configLoader.onLoadStartListener=jt=>this.triggerEvent(new Qc(jt)),this.ngModule=ee.get(P.h0i),this.console=ee.get(P.c2e);const Ct=ee.get(P.R0b);this.isNgZoneEnabled=Ct instanceof P.R0b&&P.R0b.isInAngularZone(),this.resetConfig(ye),this.currentUrlTree=function di(){return new Jr(new dn([],{}),{},null)}(),this.rawUrlTree=this.currentUrlTree,this.browserUrlTree=this.currentUrlTree,this.routerState=Li(this.currentUrlTree,this.rootComponentType),this.transitions=new Fe({id:0,targetPageId:0,currentUrlTree:this.currentUrlTree,currentRawUrl:this.currentUrlTree,extractedUrl:this.urlHandlingStrategy.extract(this.currentUrlTree),urlAfterRedirects:this.urlHandlingStrategy.extract(this.currentUrlTree),rawUrl:this.currentUrlTree,extras:{},resolve:null,reject:null,promise:Promise.resolve(!0),source:"imperative",restoredState:null,currentSnapshot:this.routerState.snapshot,targetSnapshot:null,currentRouterState:this.routerState,targetRouterState:null,guards:{canActivateChecks:[],canDeactivateChecks:[]},guardsResult:null}),this.navigations=this.setupNavigations(this.transitions),this.processNavigations()}get browserPageId(){var x;return null===(x=this.location.getState())||void 0===x?void 0:x.\u0275routerPageId}setupNavigations(x){const N=this.events;return x.pipe(qt(F=>0!==F.id),(0,bt.U)(F=>Object.assign(Object.assign({},F),{extractedUrl:this.urlHandlingStrategy.extract(F.rawUrl)})),Ve(F=>{let z=!1,ee=!1;return ve(F).pipe(cn(re=>{this.currentNavigation={id:re.id,initialUrl:re.rawUrl,extractedUrl:re.extractedUrl,trigger:re.source,extras:re.extras,previousNavigation:this.lastSuccessfulNavigation?Object.assign(Object.assign({},this.lastSuccessfulNavigation),{previousNavigation:null}):null}}),Ve(re=>{const ye=this.browserUrlTree.toString(),lt=!this.navigated||re.extractedUrl.toString()!==ye||ye!==this.currentUrlTree.toString();if(("reload"===this.onSameUrlNavigation||lt)&&this.urlHandlingStrategy.shouldProcessUrl(re.rawUrl))return Zi(re.source)&&(this.browserUrlTree=re.extractedUrl),ve(re).pipe(Ve(Ct=>{const jt=this.transitions.getValue();return N.next(new ba(Ct.id,this.serializeUrl(Ct.extractedUrl),Ct.source,Ct.restoredState)),jt!==this.transitions.getValue()?ht.E:Promise.resolve(Ct)}),function Pe(C,E,x,N){return Ve(F=>function H(C,E,x,N,F){return new oe(C,E,x,N,F).apply()}(C,E,x,F.extractedUrl,N).pipe((0,bt.U)(z=>Object.assign(Object.assign({},F),{urlAfterRedirects:z}))))}(this.ngModule.injector,this.configLoader,this.urlSerializer,this.config),cn(Ct=>{this.currentNavigation=Object.assign(Object.assign({},this.currentNavigation),{finalUrl:Ct.urlAfterRedirects}),F.urlAfterRedirects=Ct.urlAfterRedirects}),function Zo(C,E,x,N,F,z){return(0,it.z)(ee=>function Tn(C,E,x,N,F,z,ee="emptyOnly",re="legacy"){return new Rn(C,E,x,N,F,ee,re,z).recognize().pipe(Ve(ye=>null===ye?function Dn(C){return new he.y(E=>E.error(C))}(new Ht):ve(ye)))}(C,E,x,ee.urlAfterRedirects,N.serialize(ee.urlAfterRedirects),N,F,z).pipe((0,bt.U)(re=>Object.assign(Object.assign({},ee),{targetSnapshot:re}))))}(this.ngModule.injector,this.rootComponentType,this.config,this.urlSerializer,this.paramsInheritanceStrategy,this.relativeLinkResolution),cn(Ct=>{if(F.targetSnapshot=Ct.targetSnapshot,"eager"===this.urlUpdateStrategy){if(!Ct.extras.skipLocationChange){const Mn=this.urlHandlingStrategy.merge(Ct.urlAfterRedirects,Ct.rawUrl);this.setBrowserUrl(Mn,Ct)}this.browserUrlTree=Ct.urlAfterRedirects}const jt=new Xc(Ct.id,this.serializeUrl(Ct.extractedUrl),this.serializeUrl(Ct.urlAfterRedirects),Ct.targetSnapshot);N.next(jt)}));if(lt&&this.rawUrlTree&&this.urlHandlingStrategy.shouldProcessUrl(this.rawUrlTree)){const{id:jt,extractedUrl:Mn,source:ys,restoredState:Bs,extras:vs}=re,Vs=new ba(jt,this.serializeUrl(Mn),ys,Bs);N.next(Vs);const Ci=Li(Mn,this.rootComponentType).snapshot;return ve(F=Object.assign(Object.assign({},re),{targetSnapshot:Ci,urlAfterRedirects:Mn,extras:Object.assign(Object.assign({},vs),{skipLocationChange:!1,replaceUrl:!1})}))}return this.rawUrlTree=re.rawUrl,re.resolve(null),ht.E}),cn(re=>{const ye=new Yc(re.id,this.serializeUrl(re.extractedUrl),this.serializeUrl(re.urlAfterRedirects),re.targetSnapshot);this.triggerEvent(ye)}),(0,bt.U)(re=>F=Object.assign(Object.assign({},re),{guards:ji(re.targetSnapshot,re.currentSnapshot,this.rootContexts)})),function lc(C,E){return(0,it.z)(x=>{const{targetSnapshot:N,currentSnapshot:F,guards:{canActivateChecks:z,canDeactivateChecks:ee}}=x;return 0===ee.length&&0===z.length?ve(Object.assign(Object.assign({},x),{guardsResult:!0})):function Gi(C,E,x,N){return(0,ae.D)(C).pipe((0,it.z)(F=>function cc(C,E,x,N,F){const z=E&&E.routeConfig?E.routeConfig.canDeactivate:null;return z&&0!==z.length?ve(z.map(re=>{var ye;const lt=null!==(ye=_n(E))&&void 0!==ye?ye:F,$t=Ao(re,lt);return Zt(function rs(C){return C&&Ko(C.canDeactivate)}($t)?$t.canDeactivate(C,E,x,N):lt.runInContext(()=>$t(C,E,x,N))).pipe(Bt())})).pipe(Ro()):ve(!0)}(F.component,F.route,x,E,N)),Bt(F=>!0!==F,!0))}(ee,N,F,C).pipe((0,it.z)(re=>re&&function Nr(C){return"boolean"==typeof C}(re)?function vd(C,E,x,N){return(0,ae.D)(E).pipe(Ee(F=>_t(function yl(C,E){return null!==C&&E&&E(new Jc(C)),ve(!0)}(F.route.parent,N),function gl(C,E){return null!==C&&E&&E(new md(C)),ve(!0)}(F.route,N),function bl(C,E,x){const N=E[E.length-1],z=E.slice(0,E.length-1).reverse().map(ee=>function Xs(C){const E=C.routeConfig?C.routeConfig.canActivateChild:null;return E&&0!==E.length?{node:C,guards:E}:null}(ee)).filter(ee=>null!==ee).map(ee=>dt(()=>ve(ee.guards.map(ye=>{var lt;const $t=null!==(lt=_n(ee.node))&&void 0!==lt?lt:x,Ct=Ao(ye,$t);return Zt(function so(C){return C&&Ko(C.canActivateChild)}(Ct)?Ct.canActivateChild(N,C):$t.runInContext(()=>Ct(N,C))).pipe(Bt())})).pipe(Ro())));return ve(z).pipe(Ro())}(C,F.path,x),function vl(C,E,x){const N=E.routeConfig?E.routeConfig.canActivate:null;if(!N||0===N.length)return ve(!0);const F=N.map(z=>dt(()=>{var ee;const re=null!==(ee=_n(E))&&void 0!==ee?ee:x,ye=Ao(z,re);return Zt(function ml(C){return C&&Ko(C.canActivate)}(ye)?ye.canActivate(E,C):re.runInContext(()=>ye(E,C))).pipe(Bt())}));return ve(F).pipe(Ro())}(C,F.route,x))),Bt(F=>!0!==F,!0))}(N,z,C,E):ve(re)),(0,bt.U)(re=>Object.assign(Object.assign({},x),{guardsResult:re})))})}(this.ngModule.injector,re=>this.triggerEvent(re)),cn(re=>{if(F.guardsResult=re.guardsResult,hs(re.guardsResult))throw dl(0,re.guardsResult);const ye=new Zc(re.id,this.serializeUrl(re.extractedUrl),this.serializeUrl(re.urlAfterRedirects),re.targetSnapshot,!!re.guardsResult);this.triggerEvent(ye)}),qt(re=>!!re.guardsResult||(this.restoreHistory(re),this.cancelNavigationTransition(re,"",3),!1)),Oa(re=>{if(re.guards.canActivateChecks.length)return ve(re).pipe(cn(ye=>{const lt=new fd(ye.id,this.serializeUrl(ye.extractedUrl),this.serializeUrl(ye.urlAfterRedirects),ye.targetSnapshot);this.triggerEvent(lt)}),Ve(ye=>{let lt=!1;return ve(ye).pipe(function $h(C,E){return(0,it.z)(x=>{const{targetSnapshot:N,guards:{canActivateChecks:F}}=x;if(!F.length)return ve(x);let z=0;return(0,ae.D)(F).pipe(Ee(ee=>function uu(C,E,x,N){const F=C.routeConfig,z=C._resolve;return void 0!==(null==F?void 0:F.title)&&!Js(F)&&(z[St]=F.title),function pc(C,E,x,N){const F=function du(C){return[...Object.keys(C),...Object.getOwnPropertySymbols(C)]}(C);if(0===F.length)return ve({});const z={};return(0,ae.D)(F).pipe((0,it.z)(ee=>function Qs(C,E,x,N){var F;const z=null!==(F=_n(E))&&void 0!==F?F:N,ee=Ao(C,z);return Zt(ee.resolve?ee.resolve(E,x):z.runInContext(()=>ee(E,x)))}(C[ee],E,x,N).pipe(Bt(),cn(re=>{z[ee]=re}))),Fr(1),function vr(C){return(0,bt.U)(()=>C)}(z),In(ee=>mi(ee)?ht.E:et(ee)))}(z,C,E,N).pipe((0,bt.U)(ee=>(C._resolvedData=ee,C.data=ll(C,x).resolve,F&&Js(F)&&(C.data[St]=F.title),null)))}(ee.route,N,C,E)),cn(()=>z++),Fr(1),(0,it.z)(ee=>z===F.length?ve(x):ht.E))})}(this.paramsInheritanceStrategy,this.ngModule.injector),cn({next:()=>lt=!0,complete:()=>{lt||(this.restoreHistory(ye),this.cancelNavigationTransition(ye,"",2))}}))}),cn(ye=>{const lt=new pd(ye.id,this.serializeUrl(ye.extractedUrl),this.serializeUrl(ye.urlAfterRedirects),ye.targetSnapshot);this.triggerEvent(lt)}))}),Oa(re=>{const ye=lt=>{var $t;const Ct=[];(null===($t=lt.routeConfig)||void 0===$t?void 0:$t.loadComponent)&&!lt.routeConfig._loadedComponent&&Ct.push(this.configLoader.loadComponent(lt.routeConfig).pipe(cn(jt=>{lt.component=jt}),(0,bt.U)(()=>{})));for(const jt of lt.children)Ct.push(...ye(jt));return Ct};return Ue(ye(re.targetSnapshot.root)).pipe(ln(),xt(1))}),Oa(()=>this.afterPreactivation()),(0,bt.U)(re=>{const ye=function Sa(C,E,x){const N=pi(C,E._root,x?x._root:void 0);return new fi(N,E)}(this.routeReuseStrategy,re.targetSnapshot,re.currentRouterState);return F=Object.assign(Object.assign({},re),{targetRouterState:ye})}),cn(re=>{this.currentUrlTree=re.urlAfterRedirects,this.rawUrlTree=this.urlHandlingStrategy.merge(re.urlAfterRedirects,re.rawUrl),this.routerState=re.targetRouterState,"deferred"===this.urlUpdateStrategy&&(re.extras.skipLocationChange||this.setBrowserUrl(this.rawUrlTree,re),this.browserUrlTree=re.urlAfterRedirects)}),((C,E,x)=>(0,bt.U)(N=>(new rr(E,N.targetRouterState,N.currentRouterState,x).activate(C),N)))(this.rootContexts,this.routeReuseStrategy,re=>this.triggerEvent(re)),cn({next(){z=!0},complete(){z=!0}}),$r(()=>{var re;z||ee||this.cancelNavigationTransition(F,"",1),(null===(re=this.currentNavigation)||void 0===re?void 0:re.id)===F.id&&(this.currentNavigation=null)}),In(re=>{var ye;if(ee=!0,jo(re)){Ur(re)||(this.navigated=!0,this.restoreHistory(F,!0));const lt=new _a(F.id,this.serializeUrl(F.extractedUrl),re.message,re.cancellationCode);if(N.next(lt),Ur(re)){const $t=this.urlHandlingStrategy.merge(re.url,this.rawUrlTree),Ct={skipLocationChange:F.extras.skipLocationChange,replaceUrl:"eager"===this.urlUpdateStrategy||Zi(F.source)};this.scheduleNavigation($t,"imperative",null,Ct,{resolve:F.resolve,reject:F.reject,promise:F.promise})}else F.resolve(!1)}else{this.restoreHistory(F,!0);const lt=new nc(F.id,this.serializeUrl(F.extractedUrl),re,null!==(ye=F.targetSnapshot)&&void 0!==ye?ye:void 0);N.next(lt);try{F.resolve(this.errorHandler(re))}catch($t){F.reject($t)}}return ht.E}))}))}resetRootComponentType(x){this.rootComponentType=x,this.routerState.root.component=this.rootComponentType}setTransition(x){this.transitions.next(Object.assign(Object.assign({},this.transitions.value),x))}initialNavigation(){this.setUpLocationChangeListener(),0===this.navigationId&&this.navigateByUrl(this.location.path(!0),{replaceUrl:!0})}setUpLocationChangeListener(){this.locationSubscription||(this.locationSubscription=this.location.subscribe(x=>{const N="popstate"===x.type?"popstate":"hashchange";"popstate"===N&&setTimeout(()=>{var F;const z={replaceUrl:!0},ee=null!==(F=x.state)&&void 0!==F&&F.navigationId?x.state:null;if(ee){const ye=Object.assign({},ee);delete ye.navigationId,delete ye.\u0275routerPageId,0!==Object.keys(ye).length&&(z.state=ye)}const re=this.parseUrl(x.url);this.scheduleNavigation(re,N,ee,z)},0)}))}get url(){return this.serializeUrl(this.currentUrlTree)}getCurrentNavigation(){return this.currentNavigation}triggerEvent(x){this.events.next(x)}resetConfig(x){this.config=x.map(Hi),this.navigated=!1,this.lastSuccessfulId=-1}ngOnDestroy(){this.dispose()}dispose(){this.transitions.complete(),this.locationSubscription&&(this.locationSubscription.unsubscribe(),this.locationSubscription=void 0),this.disposed=!0}createUrlTree(x,N={}){const{relativeTo:F,queryParams:z,fragment:ee,queryParamsHandling:re,preserveFragment:ye}=N,lt=F||this.routerState.root,$t=ye?this.currentUrlTree.fragment:ee;let Ct=null;switch(re){case"merge":Ct=Object.assign(Object.assign({},this.currentUrlTree.queryParams),z);break;case"preserve":Ct=this.currentUrlTree.queryParams;break;default:Ct=z||null}return null!==Ct&&(Ct=this.removeEmptyProps(Ct)),$i(lt,this.currentUrlTree,x,Ct,null!=$t?$t:null)}navigateByUrl(x,N={skipLocationChange:!1}){const F=hs(x)?x:this.parseUrl(x),z=this.urlHandlingStrategy.merge(F,this.rawUrlTree);return this.scheduleNavigation(z,"imperative",null,N)}navigate(x,N={skipLocationChange:!1}){return function Un(C){for(let E=0;E<C.length;E++){if(null==C[E])throw new P.vHH(4008,false)}}(x),this.navigateByUrl(this.createUrlTree(x,N),N)}serializeUrl(x){return this.urlSerializer.serialize(x)}parseUrl(x){let N;try{N=this.urlSerializer.parse(x)}catch(F){N=this.malformedUriErrorHandler(F,this.urlSerializer,x)}return N}isActive(x,N){let F;if(F=!0===N?Object.assign({},Vh):!1===N?Object.assign({},Fa):N,hs(x))return Pr(this.currentUrlTree,x,F);const z=this.parseUrl(x);return Pr(this.currentUrlTree,z,F)}removeEmptyProps(x){return Object.keys(x).reduce((N,F)=>{const z=x[F];return null!=z&&(N[F]=z),N},{})}processNavigations(){this.navigations.subscribe(x=>{var N;this.navigated=!0,this.lastSuccessfulId=x.id,this.currentPageId=x.targetPageId,this.events.next(new zo(x.id,this.serializeUrl(x.extractedUrl),this.serializeUrl(this.currentUrlTree))),this.lastSuccessfulNavigation=this.currentNavigation,null===(N=this.titleStrategy)||void 0===N||N.updateTitle(this.routerState.snapshot),x.resolve(!0)},x=>{this.console.warn(`Unhandled Navigation Error: ${x}`)})}scheduleNavigation(x,N,F,z,ee){var re,ye;if(this.disposed)return Promise.resolve(!1);let lt,$t,Ct;ee?(lt=ee.resolve,$t=ee.reject,Ct=ee.promise):Ct=new Promise((ys,Bs)=>{lt=ys,$t=Bs});const jt=++this.navigationId;let Mn;return"computed"===this.canceledNavigationResolution?(0===this.currentPageId&&(F=this.location.getState()),Mn=F&&F.\u0275routerPageId?F.\u0275routerPageId:z.replaceUrl||z.skipLocationChange?null!==(re=this.browserPageId)&&void 0!==re?re:0:(null!==(ye=this.browserPageId)&&void 0!==ye?ye:0)+1):Mn=0,this.setTransition({id:jt,targetPageId:Mn,source:N,restoredState:F,currentUrlTree:this.currentUrlTree,currentRawUrl:this.rawUrlTree,rawUrl:x,extras:z,resolve:lt,reject:$t,promise:Ct,currentSnapshot:this.routerState.snapshot,currentRouterState:this.routerState}),Ct.catch(ys=>Promise.reject(ys))}setBrowserUrl(x,N){const F=this.urlSerializer.serialize(x),z=Object.assign(Object.assign({},N.extras.state),this.generateNgRouterState(N.id,N.targetPageId));this.location.isCurrentPathEqualTo(F)||N.extras.replaceUrl?this.location.replaceState(F,"",z):this.location.go(F,"",z)}restoreHistory(x,N=!1){var F,z;if("computed"===this.canceledNavigationResolution){const ee=this.currentPageId-x.targetPageId;"popstate"!==x.source&&"eager"!==this.urlUpdateStrategy&&this.currentUrlTree!==(null===(F=this.currentNavigation)||void 0===F?void 0:F.finalUrl)||0===ee?this.currentUrlTree===(null===(z=this.currentNavigation)||void 0===z?void 0:z.finalUrl)&&0===ee&&(this.resetState(x),this.browserUrlTree=x.currentUrlTree,this.resetUrlToCurrentUrlTree()):this.location.historyGo(ee)}else"replace"===this.canceledNavigationResolution&&(N&&this.resetState(x),this.resetUrlToCurrentUrlTree())}resetState(x){this.routerState=x.currentRouterState,this.currentUrlTree=x.currentUrlTree,this.rawUrlTree=this.urlHandlingStrategy.merge(this.currentUrlTree,x.rawUrl)}resetUrlToCurrentUrlTree(){this.location.replaceState(this.urlSerializer.serialize(this.rawUrlTree),"",this.generateNgRouterState(this.lastSuccessfulId,this.currentPageId))}cancelNavigationTransition(x,N,F){const z=new _a(x.id,this.serializeUrl(x.extractedUrl),N,F);this.triggerEvent(z),x.resolve(!1)}generateNgRouterState(x,N){return"computed"===this.canceledNavigationResolution?{navigationId:x,\u0275routerPageId:N}:{navigationId:x}}}return C.\u0275fac=function(x){P.$Z()},C.\u0275prov=P.Yz7({token:C,factory:function(){return pu()},providedIn:"root"}),C})();function Zi(C){return"imperative"!==C}class $a{}let Gn=(()=>{class C{constructor(x,N,F,z,ee){this.router=x,this.injector=F,this.preloadingStrategy=z,this.loader=ee}setUpPreloading(){this.subscription=this.router.events.pipe(qt(x=>x instanceof zo),Ee(()=>this.preload())).subscribe(()=>{})}preload(){return this.processRoutes(this.injector,this.router.config)}ngOnDestroy(){this.subscription&&this.subscription.unsubscribe()}processRoutes(x,N){var F,z,ee;const re=[];for(const ye of N){ye.providers&&!ye._injector&&(ye._injector=(0,P.MMx)(ye.providers,x,`Route: ${ye.path}`));const lt=null!==(F=ye._injector)&&void 0!==F?F:x,$t=null!==(z=ye._loadedInjector)&&void 0!==z?z:lt;ye.loadChildren&&!ye._loadedRoutes&&void 0===ye.canLoad||ye.loadComponent&&!ye._loadedComponent?re.push(this.preloadConfig(lt,ye)):(ye.children||ye._loadedRoutes)&&re.push(this.processRoutes($t,null!==(ee=ye.children)&&void 0!==ee?ee:ye._loadedRoutes))}return(0,ae.D)(re).pipe((0,ze.J)())}preloadConfig(x,N){return this.preloadingStrategy.preload(N,()=>{let F;F=N.loadChildren&&void 0===N.canLoad?this.loader.loadChildren(x,N):ve(null);const z=F.pipe((0,it.z)(ee=>{var re;return null===ee?ve(void 0):(N._loadedRoutes=ee.routes,N._loadedInjector=ee.injector,this.processRoutes(null!==(re=ee.injector)&&void 0!==re?re:x,ee.routes))}));if(N.loadComponent&&!N._loadedComponent){const ee=this.loader.loadComponent(N);return(0,ae.D)([z,ee]).pipe((0,ze.J)())}return z})}}return C.\u0275fac=function(x){return new(x||C)(P.LFG(Ar),P.LFG(P.Sil),P.LFG(P.lqb),P.LFG($a),P.LFG(Xi))},C.\u0275prov=P.Yz7({token:C,factory:C.\u0275fac,providedIn:"root"}),C})();const _i=new P.OlP("");let Lp=(()=>{class C{constructor(x,N,F={}){this.router=x,this.viewportScroller=N,this.options=F,this.lastId=0,this.lastSource="imperative",this.restoredId=0,this.store={},F.scrollPositionRestoration=F.scrollPositionRestoration||"disabled",F.anchorScrolling=F.anchorScrolling||"disabled"}init(){"disabled"!==this.options.scrollPositionRestoration&&this.viewportScroller.setHistoryScrollRestoration("manual"),this.routerEventsSubscription=this.createScrollEvents(),this.scrollEventsSubscription=this.consumeScrollEvents()}createScrollEvents(){return this.router.events.subscribe(x=>{x instanceof ba?(this.store[this.lastId]=this.viewportScroller.getScrollPosition(),this.lastSource=x.navigationTrigger,this.restoredId=x.restoredState?x.restoredState.navigationId:0):x instanceof zo&&(this.lastId=x.id,this.scheduleScrollEvent(x,this.router.parseUrl(x.urlAfterRedirects).fragment))})}consumeScrollEvents(){return this.router.events.subscribe(x=>{x instanceof Pi&&(x.position?"top"===this.options.scrollPositionRestoration?this.viewportScroller.scrollToPosition([0,0]):"enabled"===this.options.scrollPositionRestoration&&this.viewportScroller.scrollToPosition(x.position):x.anchor&&"enabled"===this.options.anchorScrolling?this.viewportScroller.scrollToAnchor(x.anchor):"disabled"!==this.options.scrollPositionRestoration&&this.viewportScroller.scrollToPosition([0,0]))})}scheduleScrollEvent(x,N){this.router.triggerEvent(new Pi(x,"popstate"===this.lastSource?this.store[this.restoredId]:null,N))}ngOnDestroy(){this.routerEventsSubscription&&this.routerEventsSubscription.unsubscribe(),this.scrollEventsSubscription&&this.scrollEventsSubscription.unsubscribe()}}return C.\u0275fac=function(x){P.$Z()},C.\u0275prov=P.Yz7({token:C,factory:C.\u0275fac}),C})();function oo(C,E){return{\u0275kind:C,\u0275providers:E}}function wi(C){return[{provide:Lh,multi:!0,useValue:C}]}function Pa(){const C=(0,P.f3M)(P.zs3);return E=>{var x,N;const F=C.get(P.z2F);if(E!==F.components[0])return;const z=C.get(Ar),ee=C.get(Vp);1===C.get(Er)&&z.initialNavigation(),null===(x=C.get(xd,null,P.XFs.Optional))||void 0===x||x.setUpPreloading(),null===(N=C.get(_i,null,P.XFs.Optional))||void 0===N||N.init(),z.resetRootComponentType(F.componentTypes[0]),ee.closed||(ee.next(),ee.unsubscribe())}}const Vp=new P.OlP("",{factory:()=>new Le.x}),Er=new P.OlP("",{providedIn:"root",factory:()=>1});const xd=new P.OlP("");function os(C){return oo(0,[{provide:xd,useExisting:Gn},{provide:$a,useExisting:C}])}const Jo=new P.OlP("ROUTER_FORROOT_GUARD"),Cd=[Te.Ye,{provide:va,useClass:Q},{provide:Ar,useFactory:pu},Fs,{provide:To,useFactory:function Bp(C){return C.routerState.root},deps:[Ar]},Xi];function mu(){return new P.PXZ("Router",Ar)}let bc=(()=>{class C{constructor(x){}static forRoot(x,N){return{ngModule:C,providers:[Cd,[],wi(x),{provide:Jo,useFactory:Ls,deps:[[Ar,new P.FiY,new P.tp0]]},{provide:fu,useValue:N||{}},null!=N&&N.useHash?{provide:Te.S$,useClass:Te.Do}:{provide:Te.S$,useClass:Te.b0},{provide:_i,useFactory:()=>{const C=(0,P.f3M)(Ar),E=(0,P.f3M)(Te.EM),x=(0,P.f3M)(fu);return x.scrollOffset&&E.setOffset(x.scrollOffset),new Lp(C,E,x)}},null!=N&&N.preloadingStrategy?os(N.preloadingStrategy).\u0275providers:[],{provide:P.PXZ,multi:!0,useFactory:mu},null!=N&&N.initialNavigation?Sd(N):[],[{provide:Ba,useFactory:Pa},{provide:P.tb,multi:!0,useExisting:Ba}]]}}static forChild(x){return{ngModule:C,providers:[wi(x)]}}}return C.\u0275fac=function(x){return new(x||C)(P.LFG(Jo,8))},C.\u0275mod=P.oAB({type:C}),C.\u0275inj=P.cJS({imports:[ko]}),C})();function Ls(C){return"guarded"}function Sd(C){return["disabled"===C.initialNavigation?oo(3,[{provide:P.ip1,multi:!0,useFactory:()=>{const E=(0,P.f3M)(Ar);return()=>{E.setUpLocationChangeListener()}}},{provide:Er,useValue:2}]).\u0275providers:[],"enabledBlocking"===C.initialNavigation?oo(2,[{provide:Er,useValue:0},{provide:P.ip1,multi:!0,deps:[P.zs3],useFactory:E=>{const x=E.get(Te.V_,Promise.resolve());let N=!1;return()=>x.then(()=>new Promise(z=>{const ee=E.get(Ar),re=E.get(Vp);(function F(z){E.get(Ar).events.pipe(qt(re=>re instanceof zo||re instanceof _a||re instanceof nc),(0,bt.U)(re=>re instanceof zo||re instanceof _a&&(0===re.code||1===re.code)&&null),qt(re=>null!==re),xt(1)).subscribe(()=>{z()})})(()=>{z(!0),N=!0}),ee.afterPreactivation=()=>(z(!0),N||re.closed?ve(void 0):re),ee.initialNavigation()}))}}]).\u0275providers:[]]}const Ba=new P.OlP("")},7582:(Lt,ot,Y)=>{"use strict";function _e(ce,ue,me,Ae){return new(me||(me=Promise))(function(Ve,xt){function Pt(ln){try{it(Ae.next(ln))}catch(G){xt(G)}}function qt(ln){try{it(Ae.throw(ln))}catch(G){xt(G)}}function it(ln){ln.done?Ve(ln.value):function Te(Ve){return Ve instanceof me?Ve:new me(function(xt){xt(Ve)})}(ln.value).then(Pt,qt)}it((Ae=Ae.apply(ce,ue||[])).next())})}function at(ce){return this instanceof at?(this.v=ce,this):new at(ce)}function Ze(ce,ue,me){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var Te,Ae=me.apply(ce,ue||[]),Ve=[];return Te={},Pt("next"),Pt("throw"),Pt("return",function xt(Bt){return function(Ee){return Promise.resolve(Ee).then(Bt,G)}}),Te[Symbol.asyncIterator]=function(){return this},Te;function Pt(Bt,Ee){Ae[Bt]&&(Te[Bt]=function(cn){return new Promise(function(In,un){Ve.push([Bt,cn,In,un])>1||qt(Bt,cn)})},Ee&&(Te[Bt]=Ee(Te[Bt])))}function qt(Bt,Ee){try{!function it(Bt){Bt.value instanceof at?Promise.resolve(Bt.value.v).then(ln,G):bn(Ve[0][2],Bt)}(Ae[Bt](Ee))}catch(cn){bn(Ve[0][3],cn)}}function ln(Bt){qt("next",Bt)}function G(Bt){qt("throw",Bt)}function bn(Bt,Ee){Bt(Ee),Ve.shift(),Ve.length&&qt(Ve[0][0],Ve[0][1])}}function Ue(ce){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var me,ue=ce[Symbol.asyncIterator];return ue?ue.call(ce):(ce=function vt(ce){var ue="function"==typeof Symbol&&Symbol.iterator,me=ue&&ce[ue],Ae=0;if(me)return me.call(ce);if(ce&&"number"==typeof ce.length)return{next:function(){return ce&&Ae>=ce.length&&(ce=void 0),{value:ce&&ce[Ae++],done:!ce}}};throw new TypeError(ue?"Object is not iterable.":"Symbol.iterator is not defined.")}(ce),me={},Ae("next"),Ae("throw"),Ae("return"),me[Symbol.asyncIterator]=function(){return this},me);function Ae(Ve){me[Ve]=ce[Ve]&&function(xt){return new Promise(function(Pt,qt){!function Te(Ve,xt,Pt,qt){Promise.resolve(qt).then(function(it){Ve({value:it,done:Pt})},xt)}(Pt,qt,(xt=ce[Ve](xt)).done,xt.value)})}}}Y.d(ot,{FC:()=>Ze,KL:()=>Ue,mG:()=>_e,qq:()=>at}),"function"==typeof SuppressedError&&SuppressedError}},Lt=>{Lt(Lt.s=9799)}]);